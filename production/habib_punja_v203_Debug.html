<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Habib Punja v2.0.2 DEBUG</title>

    <style>
        :root {
            --bg-1: #0b1b13;
            --bg-2: #0f2a1c;
            --surface: #132e21;
            --gold: #ffd54a;
            --gold-2: #ffea8a;
            --accent: #4ade80;
            --accent-2: #22c55e;
            --danger: #ef4444;
            --muted: #cbd5e1;
            --ring: 0 0 0 2px rgba(255,213,74,.25),0 10px 30px rgba(0,0,0,.35);
            --radius: 14px;
            --card-w: 64px;
            --card-h: 92px;
            --elev: 0 10px 25px rgba(0,0,0,.35)
        }

        * {
            box-sizing: border-box
        }

        html, body {
            height: 100%
        }

        body {
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,'Noto Sans',sans-serif;
            background: radial-gradient(1200px 800px at 30% -10%,#154d34 0%,transparent 60%),radial-gradient(1400px 900px at 120% 10%,#0b3d28 0%,transparent 55%),linear-gradient(180deg,var(--bg-1),var(--bg-2));
            color: #fff;
            min-height: 100vh;
            padding: 24px
        }

        .game-container {
            max-width: 1280px;
            margin: 0 auto
        }

        .game-header {
            text-align: center;
            margin-bottom: 18px
        }

            .game-header h1 {
                font-size: clamp(1.6rem,3vw,2.4rem);
                color: var(--gold);
                letter-spacing: .5px;
                text-shadow: 0 1px 0 #000,0 0 24px rgba(255,213,74,.25)
            }

        .game-info {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg,rgba(255,215,0,.10),rgba(255,255,255,.04));
            padding: 16px 18px;
            border-radius: var(--radius);
            border: 1px solid rgba(255,215,0,.25);
            box-shadow: var(--elev)
        }

        .current-hand {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--gold)
        }

        .requirements {
            font-size: .95rem;
            color: var(--gold-2)
        }

            .requirements.ready {
                color: var(--accent)
            }

        .turn-indicator {
            padding: 8px 14px;
            background: linear-gradient(180deg,var(--accent),var(--accent-2));
            border-radius: 999px;
            font-weight: 800;
            color: #052e1a;
            text-shadow: 0 1px 0 rgba(255,255,255,.35);
            box-shadow: var(--ring)
        }

        .leaderboard {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border: 1px solid rgba(255,255,255,.15);
            border-radius: var(--radius);
            padding: 12px 14px;
            margin: 16px 0 20px;
            box-shadow: var(--elev)
        }

            .leaderboard h3 {
                color: var(--gold);
                margin-bottom: 6px;
                text-align: center;
                font-size: 1rem
            }

        .leaderboard-entries {
            display: flex;
            gap: 10px
        }

        .leaderboard-entry {
            flex: 1;
            text-align: center;
            padding: 8px 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.12)
        }

            .leaderboard-entry.first {
                background: linear-gradient(180deg,rgba(255,215,0,.20),rgba(255,215,0,.08));
                border-color: rgba(255,215,0,.65)
            }

            .leaderboard-entry.last {
                background: linear-gradient(180deg,rgba(239,68,68,.22),rgba(239,68,68,.08));
                border-color: rgba(239,68,68,.55)
            }

        .leaderboard-name {
            font-weight: 800;
            font-size: .9rem;
            margin-bottom: 2px
        }

        .leaderboard-score {
            font-size: 1.05rem;
            font-weight: 800;
            color: var(--gold)
        }

        .players-section {
            display: grid;
            grid-template-columns: 1fr minmax(420px,1.2fr) 1fr;
            gap: 16px;
            margin-bottom: 22px
        }

        @media(max-width:980px) {
            .players-section {
                grid-template-columns: 1fr
            }

            .center-area {
                order: 3
            }
        }

        .player-area {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border-radius: var(--radius);
            padding: 16px;
            min-height: 180px;
            border: 1px solid rgba(255,255,255,.15);
            box-shadow: var(--elev);
            transition: box-shadow .2s,border-color .2s
        }

            .player-area.active-turn {
                box-shadow: 0 0 0 2px var(--gold),0 12px 30px rgba(0,0,0,.45)
            }

        .player-name {
            font-weight: 900;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--player-color);
            color: var(--player-color);
            letter-spacing: .3px
        }

        .ai-status {
            margin-top: 12px;
            padding: 12px;
            border-radius: 10px;
            background: rgba(0,0,0,.35);
            border: 1px solid var(--player-color);
            min-height: 56px;
            font-size: .9rem;
            line-height: 1.5
        }

            .ai-status.active {
                background: linear-gradient(180deg,rgba(255,215,0,.18),rgba(255,215,0,.08));
                border-color: var(--gold);
                box-shadow: var(--ring)
            }

        .ai-status-title {
            font-weight: 800;
            color: var(--player-color);
            margin-bottom: 4px
        }

        /* ============================================
   🎨 FIX 7B: Custom Confirmation Modal
   ============================================ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

            .modal-overlay.active {
                display: flex;
            }

        .modal-content {
            background: linear-gradient(135deg, var(--surface) 0%, var(--bg-2) 100%);
            border: 2px solid var(--gold);
            border-radius: var(--radius);
            padding: 32px;
            max-width: 450px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), var(--ring);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .modal-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 800;
            color: var(--gold);
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .modal-message {
            font-size: 16px;
            color: var(--muted);
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 700;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

            .modal-btn.cancel {
                background: linear-gradient(180deg, var(--accent), var(--accent-2));
                border-color: var(--accent);
                color: #052e1a;
            }

                .modal-btn.cancel:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
                }

            .modal-btn.confirm {
                background: linear-gradient(180deg, var(--danger), #dc2626);
                border-color: var(--danger);
                color: white;
            }

                .modal-btn.confirm:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
                }

        .center-area {
            display: flex;
            flex-direction: column;
            align-items: center
        }

        .deck-area {
            display: flex;
            gap: 18px;
            margin-bottom: 16px
        }

        .deck, .discard-pile {
            width: 92px;
            height: 132px;
            border: 1px solid rgba(255,255,255,.35);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform .18s,box-shadow .18s;
            box-shadow: var(--elev);
            position: relative;
            overflow: hidden
        }

            .deck::after, .discard-pile::after {
                content: '';
                position: absolute;
                inset: 0;
                opacity: .2;
                background: radial-gradient(500px 180px at 20% -10%,#fff,transparent 60%);
                pointer-events: none
            }

        .deck {
            background: linear-gradient(160deg,#2b5fff,#17318f)
        }

        .discard-pile {
            background: linear-gradient(160deg,#ff7b2b,#8f3c17)
        }

            .deck:hover, .discard-pile:hover {
                transform: translateY(-4px) scale(1.03)
            }

        .published-sequences {
            width: 100%;
            min-height: 150px;
            border: 1px dashed rgba(255,215,0,.55);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            background: linear-gradient(180deg,rgba(255,215,0,.12),rgba(255,215,0,.04))
        }

            .published-sequences > div:first-child {
                font-size: 1.05rem;
                font-weight: 900;
                color: var(--gold);
                margin-bottom: 10px;
                letter-spacing: .4px
            }

        .player-published {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px
        }

            .player-published h5 {
                margin-bottom: 8px;
                color: var(--gold);
                font-size: .95rem;
                font-weight: 900
            }

        .published-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            max-width: 100%
        }

            .published-cards .card {
                flex: 0 0 auto;
                transform: scale(0.7)
            }

        .hand-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px
        }

        .players-section .player-area .hand-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            justify-items: center
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 900;
            cursor: move;
            user-select: none;
            position: relative;
            padding: 4px;
            background: linear-gradient(180deg,#fbfbfb,#f0f0f0);
            box-shadow: 0 6px 16px rgba(0,0,0,.25);
            transition: transform .16s ease,box-shadow .16s ease,border-color .16s ease
        }

            .card::before {
                content: '';
                position: absolute;
                inset: 0;
                border-radius: 10px;
                pointer-events: none;
                background: radial-gradient(800px 200px at 20% -10%,rgba(255,255,255,.8),transparent 60%);
                opacity: .35
            }

            .card:hover {
                transform: translateY(-8px) rotate(-.4deg);
                box-shadow: 0 12px 28px rgba(0,0,0,.35)
            }

            .card.dragging {
                opacity: .7;
                transform: rotate(3deg) scale(1.05)
            }

            .card.drag-over {
                border-left: 4px solid var(--accent)
            }

            .card.red {
                color: #db1f2f
            }

            .card.black {
                color: #0f172a
            }

            .card.red.heart {
                color: #e31c23
            }

            .card.red.diamond {
                color: #ff6b35
            }

            .card.selected {
                outline: 3px solid var(--gold);
                outline-offset: 0;
                transform: translateY(-12px) scale(1.02);
                box-shadow: 0 14px 34px rgba(255,213,74,.45)
            }

        .card-rank {
            font-size: 17px;
            line-height: 1;
            margin-bottom: 2px
        }

        .card-suit {
            font-size: 30px;
            line-height: 1
        }

        .btn {
            background: linear-gradient(180deg,#3ddc84,#1fae63);
            color: #052e1a;
            border: none;
            padding: 12px 18px;
            border-radius: 12px;
            cursor: pointer;
            margin: 0 6px 10px;
            font-size: 15px;
            font-weight: 900;
            letter-spacing: .2px;
            transition: transform .12s,box-shadow .12s;
            box-shadow: 0 6px 16px rgba(0,0,0,.25)
        }

            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 22px rgba(0,0,0,.35)
            }

            .btn:disabled {
                background: #6b7280;
                color: #1f2937;
                cursor: not-allowed;
                opacity: .7;
                box-shadow: none
            }

        .buy-info {
            background: rgba(255,193,7,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem
        }

        .selection-info {
            background: rgba(255,215,0,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem;
            font-weight: 900
        }

        .publish-selector {
            display: none;
            background: linear-gradient(135deg,rgba(255,215,0,.22),rgba(255,215,0,.08));
            border: 2px solid var(--gold);
            border-radius: 14px;
            padding: 18px;
            margin: 12px 0
        }

            .publish-selector.active {
                display: block
            }

            .publish-selector h3 {
                color: var(--gold);
                margin-bottom: 12px;
                text-align: center;
                font-size: 1.05rem
            }

        .publish-options {
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .publish-option {
            background: rgba(255,255,255,.05);
            border: 1px solid rgba(255,255,255,.20);
            border-radius: 12px;
            padding: 12px
        }

            .publish-option h4 {
                color: var(--gold-2);
                margin-bottom: 8px;
                font-size: .95rem
            }

        .option-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            justify-content: center
        }

        .publish-controls {
            text-align: center;
            margin-top: 10px
        }

        .add-to-published {
            margin-top: 8px;
            padding: 8px 12px;
            font-size: .85rem;
            background: #0ea5e9;
            color: #062232
        }

            .add-to-published:hover {
                background: #0284c7;
                color: #001824
            }

        .game-controls {
            text-align: center;
            margin-top: 14px
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0
            }

            to {
                transform: translateX(0);
                opacity: 1
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1
            }

            to {
                transform: translateX(400px);
                opacity: 0
            }
        }

        @keyframes victoryPulse {
            0%, 100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.05)
            }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none
        }

        .debug-ribbon {
            position: fixed;
            top: 16px;
            right: -52px;
            transform: rotate(45deg);
            background: #f97316;
            color: #1b1208;
            font-weight: 900;
            letter-spacing: .3px;
            padding: 8px 64px;
            box-shadow: 0 10px 24px rgba(0,0,0,.35);
            z-index: 9999;
            border: 2px solid rgba(0,0,0,.25)
        }

        .fix-badge {
            position: fixed;
            top: 80px;
            right: 16px;
            background: linear-gradient(135deg, #f97316, #ea580c);
            color: #fff;
            font-weight: 900;
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 9998;
            font-size: 0.9rem;
            border: 2px solid rgba(255,255,255,0.3)
        }

        .debug-cheatsheet {
            position: fixed;
            bottom: 16px;
            right: 16px;
            z-index: 9999;
            width: min(480px,92vw);
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(249,115,22,.6);
            border-radius: 14px;
            box-shadow: 0 14px 34px rgba(0,0,0,.45);
            color: #fff
        }

            .debug-cheatsheet summary {
                cursor: pointer;
                padding: 10px 14px;
                font-weight: 900;
                color: #ffedd5
            }

            .debug-cheatsheet pre {
                margin: 0;
                padding: 12px 14px;
                overflow: auto;
                font-size: .9rem;
                line-height: 1.45;
                color: #fde68a;
                background: transparent;
                border-top: 1px solid rgba(249,115,22,.35)
            }
    </style>
</head>
<body>
    <div class="debug-ribbon">DEBUG v2.0.2</div>
    <div class="fix-badge">🔧 DEBUG v2.0.2 Upated Buying Window </div>
    <div class="game-container">
        <div class="game-header"><h1>Habib Punja v2.0.1 DEBUG</h1></div>
        <div class="game-info">
            <div class="current-hand">Hand <span id="currentHand">1</span>: <span id="handRequirements">Two Triples</span></div>
            <div class="requirements" id="detailedRequirements">Two Triples</div>
            <div class="turn-indicator" id="turnIndicator">Your Turn</div>
        </div>
        <div class="leaderboard"><div class="leaderboard-entries" id="leaderboardEntries"></div></div>
        <div class="players-section">
            <div class="player-area" style="--player-color: #e74c3c;">
                <div class="player-name">Habot <span class="buy-info">Buys: <span id="player2Buys">3</span></span></div>
                <div class="hand-cards" id="player2Cards"></div>
                <div class="ai-status" id="habot-status">
                    <div class="ai-status-title">Habot's Status:</div>
                    <div class="ai-status-action" id="habot-action">Waiting...</div>
                </div>
            </div>
            <div class="center-area">
                <div class="deck-area">
                    <div class="deck" onclick="drawFromDeck()"><div>Draw<br>Deck</div></div>
                    <div class="discard-pile" onclick="drawFromDiscard()"><div id="topDiscard">Discard<br>Pile</div></div>
                </div>
                <div class="published-sequences">
                    <div>Published Sequences</div>
                    <div id="player1Published" class="player-published"><h5>Your Published Sequences:</h5><div class="published-cards" id="player1Cards"></div></div>
                    <div id="player2Published" class="player-published"><h5>Habot's Published Sequences:</h5><div class="published-cards" id="player2CardsPublished"></div></div>
                    <div id="player3Published" class="player-published"><h5>Jabot's Published Sequences:</h5><div class="published-cards" id="player3CardsPublished"></div></div>
                </div>
            </div>
            <div class="player-area" style="--player-color: #9b59b6;">
                <div class="player-name">Jabot <span class="buy-info">Buys: <span id="player3Buys">3</span></span></div>
                <div class="hand-cards" id="player3Cards"></div>
                <div class="ai-status" id="jabot-status">
                    <div class="ai-status-title">Jabot's Status:</div>
                    <div class="ai-status-action" id="jabot-action">Waiting...</div>
                </div>
            </div>
        </div>
        <div class="player-area" style="--player-color: #4a90e2;">
            <div class="player-name">Your Hand <span class="buy-info">Buys: <span id="playerBuys">3</span></span><span id="selectionInfo" class="selection-info" style="display:none;">Selected: <span id="selectedCount">0</span></span></div>
            <div class="hand-cards" id="playerCards"></div>
            <div class="publish-selector" id="publishSelector">
                <h3>Choose Cards to Publish</h3>
                <div class="publish-options" id="publishOptions"></div>
                <div class="publish-controls">
                    <button class="btn" onclick="confirmManualPublish()">Publish Selected</button>
                    <button class="btn" onclick="cancelManualPublish()">Cancel</button>
                </div>
            </div>
            <div id="addToPublishedSection" style="display:none; margin-top:15px;">
                <strong style="color:#ffd700;">Add Selected Card To:</strong>
                <button class="btn add-to-published" onclick="addToPublished(0)">Your Sequences</button>
                <button class="btn add-to-published" onclick="addToPublished(1)">Habot's Sequences</button>
                <button class="btn add-to-published" onclick="addToPublished(2)">Jabot's Sequences</button>
            </div>
        </div>
        <div class="game-controls">
            <button class="btn" id="publishBtn" onclick="publishSequences()" disabled>Publish Sequences</button>
            <button class="btn" onclick="sortByRank()">Sort by Rank</button>
            <button class="btn" onclick="sortBySuit()">Sort by Suit</button>
            <button class="btn" id="discardBtn" onclick="discardCard()" disabled>Discard Selected</button>
            <button class="btn" id="buyBtn" onclick="buyCard()" disabled>Buy from Discard <span id="buyTimer" style="display:none;"></span></button>
            <button class="btn" onclick="sortByQuantity()">Sort by Quantity</button>
            <button class="btn" onclick="newGame()">New Game</button>
        </div>
    </div>

    <!-- ============================================
     🎨 FIX 7B: Custom Confirmation Modal
     ============================================ -->
    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-icon">⚠️</div>
            <div class="modal-title" id="modalTitle">Confirm Action</div>
            <div class="modal-message" id="modalMessage">Are you sure?</div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="modalCancel">Continue Playing</button>
                <button class="modal-btn confirm" id="modalConfirm">Start New Game</button>
            </div>
        </div>
    </div>

    <details class="debug-cheatsheet">
        <summary>🔧 Debug Cheatsheet v2.0.1</summary>
        <pre>game.debugHelp()           - Full command list
game.debugEndgameTest()    - v2.0.1 endgame test
game.debugAceLadderTest()  - FIX 1: Both ends test
game.debug1CardTest()      - 1-card rule test
game.debugSetHand(3)       - Jump to hand 3
game.debugShowAllHands()   - See all cards
game.debugInstantAI()      - Toggle AI speed
game.debugFix5Test()       - FIX 5: Duplicate cards
game.debugFix6Test()       - FIX 6: Ambiguous Card Assignment
</pre>

    </details>
    <script>
        window.addEventListener('error', function (e) {
            if (e.message && e.message.includes('runtime.lastError')) {
                e.preventDefault();
                console.log('⚠️ Browser extension error caught and ignored');
                return false;
            }
        });
        console.log('%c✅ v2.0.1 DEBUG', 'color:#f97316;font-size:18px;font-weight:bold');
        console.log('%c  FIX 1: Ladder Extension - Explicit LOW + HIGH support', 'color:#4ade80');
        console.log('%c  FIX 2: AI Takes Card Toast - Shows AI name + card', 'color:#4ade80');
        console.log('%c  FIX 3: Reduced Buy Window - 5s after publishing', 'color:#4ade80');
        console.log('%c  FIX 4: Endgame Protection - AI avoids helping opponents with ≤2 cards', 'color:#4ade80');
        console.log('%c  FIX 5: Duplicate Card Prevention - Validates card selection', 'color:#4ade80');
        console.log('%c🛠️ DEBUG MODE ACTIVE', 'color:#ff6b35;font-size:24px;font-weight:bold');
        console.log('%c✅ Type: game.debugHelp()', 'color:#ffd700;font-size:16px');

        class Card {
            constructor(rank, suit) { this.rank = rank; this.suit = suit; this.id = Math.random().toString(36).substr(2, 9) }
            toString() { return `${this.rank}${this.suit}` }
            getValue() { if (this.rank === 'A') return 1; if (this.rank === 'J') return 11; if (this.rank === 'Q') return 12; if (this.rank === 'K') return 13; return parseInt(this.rank) }
            getColor() { return (this.suit === '♥' || this.suit === '♦') ? 'red' : 'black' }
            getPenaltyValue() { if (this.rank === 'A') return 20; if (['K', 'Q', 'J'].includes(this.rank)) return 15; return this.getValue() }
        }

        let game = null;
        let persistentScores = [0, 0, 0];

        class GameState {
            constructor(carryOverScores = false) {
                this.currentHand = 1; this.players = 3; this.currentPlayer = 0;
                this.deck = []; this.discardPile = [];
                this.playerHands = [[], [], []]; this.playerBuys = [3, 3, 3];
                this.publishedSequences = [[], [], []]; this.gamePhase = 'draw';
                this.selectedCards = [];
                this.playerScores = carryOverScores ? [...persistentScores] : [0, 0, 0];
                this.lastDiscard = null; this.justPublished = false;
                this.lastDiscardByPlayer = -1; this.aiJustPublished = [false, false, false];
                this.turnCounter = 0;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                this.lastAIDiscard = [null, null, null];
                this.aiPersonality = { 1: 'rabbit', 2: 'tortoise' };
                this.lastCardWarningShown = null;
                this.aiInstant = false;
                this.handReqs = {
                    1: { name: "Two Triples", seqs: ["triple", "triple"], cards: 10 },
                    2: { name: "Triple + Ladder", seqs: ["triple", "ladder"], cards: 10 },
                    3: { name: "Two Ladders", seqs: ["ladder", "ladder"], cards: 10 },
                    4: { name: "Three Triples", seqs: ["triple", "triple", "triple"], cards: 10 },
                    5: { name: "2 Triples + Ladder", seqs: ["triple", "triple", "ladder"], cards: 10 },
                    6: { name: "Triple + 2 Ladders", seqs: ["triple", "ladder", "ladder"], cards: 10 },
                    7: { name: "Three Ladders", seqs: ["ladder", "ladder", "ladder"], cards: 10 }
                };
                this.initDeck(); this.deal(); this.updateUI();
                console.log('%c====== GAME STARTED (v2.0.1 DEBUG) ======', 'color:#28a745;font-size:14px;font-weight:bold');
            }

            debugHelp() {
                console.log('%c\n🛠️ DEBUG COMMAND REFERENCE v2.0.1', 'color:#ff6b35;font-size:18px;font-weight:bold');
                console.log('%c\n📋 QUICK TESTS:', 'color:#ffd700;font-weight:bold');
                console.log('  game.debugFix4Test()       - v2.0.1 FIX 4: Endgame protection');  // ✅ ADD THIS
                console.log('  game.debugEndgameTest()    - v2.0.0 FIX: AI protects dangerous cards');
                console.log('  game.debugAceLadderTest()  - v2.0.1 FIX 1: Both ends ladder extension');
                console.log('  game.debug1CardTest()      - 1-card rule enforcement');
                console.log('  game.debugFix5Test()       - v2.0.1 FIX 5: Duplicate card selection');
                console.log('  game.debugFix6Test()       - v2.0.2 FIX 6: Ambiguous Card Assignment');
                console.log('%c\n🎮 HAND CONTROL:', 'color:#ffd700;font-weight:bold');
                console.log('  game.debugSetHand(3)       - Jump to hand 3');
                console.log('  game.debugNextHand()       - Next hand');
                console.log('%c\n🃏 CARD MANAGEMENT:', 'color:#ffd700;font-weight:bold');
                console.log('  game.debugGiveCards(["K♠"]) - Get specific cards');
                console.log('  game.debugSetHandSize(1)   - Set hand size');
                console.log('%c\n👁️ VISIBILITY:', 'color:#ffd700;font-weight:bold');
                console.log('  game.debugShowAllHands()   - See all hands');
                console.log('  game.debugStatus()         - Show game state');
                console.log('%c\n⚡ SPEED:', 'color:#ffd700;font-weight:bold');
                console.log('  game.debugInstantAI()      - Toggle AI speed');
            }

            debugEndgameTest() {
                console.log('%c🧪 v2.0.1 ENDGAME TEST (FIX 4)', 'color:#ff6b35;font-weight:bold');
                this.playerHands[0] = [new Card('K', '♠'), new Card('Q', '♠'), new Card('J', '♠')];
                this.publishedSequences[0] = [new Card('5', '♥'), new Card('6', '♥'), new Card('7', '♥'), new Card('8', '♥')];
                this.playerHands[1] = [new Card('9', '♥'), new Card('10', '♥')];
                this.publishedSequences[1] = [new Card('K', '♥'), new Card('K', '♦'), new Card('K', '♣')];
                this.gamePhase = 'discard'; this.currentPlayer = 0;
                this.updateUI();
                console.log('%c✅ SETUP: Opponent has 2 cards + published. Your 9♥ would help them win.', 'color:#28a745');
                console.log('Expected: AI should NOT discard 9♥ or 10♥ (dangerous cards)');
            }

            debugAceLadderTest() {
                console.log('%c🧪 FIX 1: ACE LADDER TEST (Both Ends)', 'color:#ff6b35;font-weight:bold');
                this.debugSetHand(3);
                const testCards = [new Card('9', '♠'), new Card('10', '♠'), new Card('J', '♠'), new Card('Q', '♠'),
                new Card('K', '♠'), new Card('A', '♠'), new Card('2', '♥'), new Card('3', '♥'), new Card('4', '♥'), new Card('5', '♥')];
                this.playerHands[0] = testCards;
                const ladder1 = [testCards[0], testCards[1], testCards[2], testCards[3]];
                const ladder2 = [testCards[6], testCards[7], testCards[8], testCards[9]];
                this.publishedSequences[0] = [...ladder1, ...ladder2];
                this.playerHands[0] = [testCards[4], testCards[5]];
                this.gamePhase = 'discard'; this.updateUI();
                console.log('%c✅ TEST: K♠ extends to HIGH end (9-10-J-Q-K), A♠ wraps to LOW end (A-K-Q-J)', 'color:#28a745');
            }

            debug1CardTest() {
                console.log('%c🧪 1-CARD RULE TEST', 'color:#ff6b35;font-weight:bold');
                this.playerHands[0] = [new Card('K', '♠')];
                this.publishedSequences[0] = [new Card('J', '♠'), new Card('Q', '♠'), new Card('A', '♠')];
                this.gamePhase = 'discard'; this.selectedCards = [0];
                this.updateUI();
                console.log('%c✅ TEST: "Add to Published" buttons should NOT appear (only 1 card left)', 'color:#28a745');
            }

            debugFix5Test() {
                console.log('%c🧪 FIX 5 TEST: Duplicate Card Selection', 'color:#ff6b35;font-weight:bold;font-size:16px');
                this.debugSetHand(2);
                this.playerHands[0] = [
                    new Card('J', '♥'), new Card('J', '♦'), new Card('J', '♣'),
                    new Card('10', '♦'), new Card('J', '♦'), new Card('Q', '♦'), new Card('K', '♦'),
                    new Card('4', '♥'), new Card('6', '♥'), new Card('7', '♥')
                ];
                this.gamePhase = 'discard'; this.currentPlayer = 0;
                this.updateUI();
                console.log('%c✅ TEST SETUP:', 'color:#28a745;font-weight:bold');
                console.log('  Hand has: 2 J♦ cards (indices 1 and 4)');
                console.log('  Triple: J♥ J♦ J♣ (uses J♦ at index 1)');
                console.log('  Ladder: 10♦ J♦ Q♦ K♦ (uses J♦ at index 4)');
                console.log('\n%c▶️ Now click "Publish Sequences" and select both', 'color:#4a90e2');
                console.log('  Expected: Error message about duplicate card');
            }

            debugFix6Test() {
                console.log('%c🧪 FIX 6 TEST: Ambiguous Card Assignment', 'color:#ff6b35;font-weight:bold;font-size:16px');

                this.currentHand = 5;
                this.publishedSequences[0] = [
                    new Card('J', '♥'), new Card('J', '♦'), new Card('J', '♣'),
                    new Card('7', '♥'), new Card('8', '♥'), new Card('9', '♥'), new Card('10', '♥')
                ];
                this.playerHands[0] = [new Card('J', '♥'), new Card('Q', '♥')];
                this.gamePhase = 'discard';
                this.currentPlayer = 0;
                this.selectedCards = [0];
                this.updateUI();

                console.log('%c✅ TEST SETUP:', 'color:#28a745;font-weight:bold');
                console.log('  Published: J♥ J♦ J♣ (triple) + 7♥ 8♥ 9♥ 10♥ (ladder)');
                console.log('  Hand: J♥ (selected) + Q♥');
                console.log('  J♥ could extend BOTH triple AND ladder!');
                console.log('\n%c▶️ Click "Add Selected Card To: Your Sequences"', 'color:#4a90e2');
                console.log('  Expected: Modal asking "Add to Triple or Ladder?"');
            }

            debugSetHand(handNum) {
                if (handNum < 1 || handNum > 7) { console.error('Hand must be 1-7'); return }
                console.log(`%c🎯 Jumping to Hand ${handNum}...`, 'color:#4a90e2;font-weight:bold');
                this.currentHand = handNum; this.playerBuys = handNum === 7 ? [2, 2, 2] : [3, 3, 3];
                this.publishedSequences = [[], [], []]; this.playerHands = [[], [], []]; this.selectedCards = [];
                this.gamePhase = 'draw'; this.currentPlayer = 0; this.justPublished = false; this.aiJustPublished = [false, false, false];
                this.lastDiscard = null; this.lastDiscardByPlayer = -1; this.discardPile = [];
                this.turnCounter = 0; this.lastAIDiscard = [null, null, null];
                this.initDeck(); this.deal(); this.updateUI();
                console.log(`%c✅ Now at Hand ${handNum}: ${this.handReqs[handNum].name}`, 'color:#28a745');
            }

            debugNextHand() {
                if (this.currentHand < 7) this.debugSetHand(this.currentHand + 1);
                else console.log('%c⚠️ Already at final hand', 'color:#ffc107');
            }

            debugGiveCards(cardStrings) {
                console.log('%c🎁 Adding cards...', 'color:#4a90e2;font-weight:bold');
                cardStrings.forEach(str => {
                    const rank = str.slice(0, -1); const suit = str.slice(-1);
                    const card = new Card(rank, suit); this.playerHands[0].push(card);
                    console.log(`  Added: ${card.toString()}`);
                });
                this.updateUI(); console.log('%c✅ Cards added!', 'color:#28a745');
            }

            debugSetHandSize(size) {
                console.log(`%c🎯 Setting hand to ${size} card(s)...`, 'color:#4a90e2;font-weight:bold');
                this.playerHands[0] = [];
                for (let i = 0; i < size; i++) this.playerHands[0].push(new Card('K', '♠'));
                this.selectedCards = []; this.updateUI();
                console.log(`%c✅ Hand now has ${size} card(s)!`, 'color:#28a745');
            }

            debugShowAllHands() {
                console.log('%c👁️ ALL HANDS:', 'color:#ff6b35;font-size:16px;font-weight:bold');
                console.log('\n🎮 YOUR HAND:', this.playerHands[0].map(c => c.toString()).join(', '));
                console.log('🤖 HABOT:', this.playerHands[1].map(c => c.toString()).join(', '));
                console.log('🤖 JABOT:', this.playerHands[2].map(c => c.toString()).join(', '));
            }

            debugStatus() {
                console.log('%c📊 GAME STATUS:', 'color:#ff6b35;font-size:16px;font-weight:bold');
                console.log(`Hand: ${this.currentHand} (${this.handReqs[this.currentHand].name})`);
                console.log(`Phase: ${this.gamePhase}`);
                console.log(`Current Player: ${this.currentPlayer === 0 ? 'YOU' : this.currentPlayer === 1 ? 'Habot' : 'Jabot'}`);
                console.log(`Your Cards: ${this.playerHands[0].length}`);
                console.log(`Published: ${this.publishedSequences[0].length} cards`);
            }

            debugFix4Test() {
                console.log('%c🧪 FIX 4 TEST: Endgame Protection', 'color:#ff6b35;font-weight:bold;font-size:16px');

                // Set up Hand 3 (2 Ladders)
                this.debugSetHand(3);

                // Human: 1 card left + published ladder (A-K-Q-J♣)
                this.publishedSequences[0] = [
                    new Card('A', '♣'),
                    new Card('K', '♣'),
                    new Card('Q', '♣'),
                    new Card('J', '♣')
                ];
                this.playerHands[0] = [new Card('2', '♥')]; // 1 random card left

                // Jabot (AI 2): Has 10♣ that would WIN the game for human
                this.playerHands[2] = [
                    new Card('7', '♠'),
                    new Card('4', '♦'),
                    new Card('4', '♦'),
                    new Card('3', '♦'),
                    new Card('10', '♣')  // 🚨 THE DANGEROUS CARD
                ];
                this.publishedSequences[2] = []; // NOT published

                // Habot (AI 1): Random cards, not published
                this.playerHands[1] = [
                    new Card('9', '♥'),
                    new Card('8', '♥'),
                    new Card('6', '♣')
                ];
                this.publishedSequences[1] = [];

                // Set Jabot's turn to discard
                this.currentPlayer = 2;
                this.gamePhase = 'discard';
                this.updateUI();

                console.log('%c✅ TEST SETUP:', 'color:#28a745;font-weight:bold');
                console.log('  Human: Published A-K-Q-J♣, has 1 card left');
                console.log('  Jabot: Has 10♣ (extends human ladder), NOT published');
                console.log('  Expected: Jabot should AVOID discarding 10♣');
                console.log('  Bug: Jabot discards 10♣ anyway (hands you the win)');
                console.log('\n%c▶️ Click to manually trigger Jabot turn or wait...', 'color:#4a90e2');

                // Auto-trigger AI turn after 2 seconds
                setTimeout(() => {
                    console.log('%c🤖 Starting Jabot turn...', 'color:#9b59b6;font-weight:bold');
                    this.aiTurn();
                }, 2000);
            }

            debugFix5Test() {
                console.log('%c🧪 FIX 5 TEST: Duplicate Card Selection', 'color:#ff6b35;font-weight:bold;font-size:16px');

                game.debugSetHand(2); // Triple + Ladder

                // Give exactly the scenario you described
                game.playerHands[0] = [
                    new Card('J', '♥'), new Card('J', '♦'), new Card('J', '♣'),  // Triple
                    new Card('10', '♦'), new Card('J', '♦'), new Card('Q', '♦'), new Card('K', '♦'),  // Ladder (with 2nd J♦)
                    new Card('4', '♥'), new Card('6', '♥'), new Card('7', '♥')
                ];

                game.gamePhase = 'discard';
                game.currentPlayer = 0;
                game.updateUI();

                console.log('%c✅ TEST SETUP:', 'color:#28a745;font-weight:bold');
                console.log('  Hand has: 2 J♦ cards (indices 1 and 4)');
                console.log('  Triple: J♥ J♦ J♣ (uses J♦ at index 1)');
                console.log('  Ladder: 10♦ J♦ Q♦ K♦ (uses J♦ at index 4)');
                console.log('\n%c▶️ Now click "Publish Sequences" and select both', 'color:#4a90e2');
                console.log('  Expected WITHOUT FIX: Publishes with J♦ missing');
                console.log('  Expected WITH FIX 5: Error message about duplicate card');
            }

            debugFix6Test() {
                console.log('%c🧪 FIX 6 TEST: Ambiguous Card Assignment', 'color:#ff6b35;font-weight:bold;font-size:16px');

                this.currentHand = 5;
                this.publishedSequences[0] = [
                    new Card('J', '♥'), new Card('J', '♦'), new Card('J', '♣'),
                    new Card('7', '♥'), new Card('8', '♥'), new Card('9', '♥'), new Card('10', '♥')
                ];
                this.playerHands[0] = [new Card('J', '♥'), new Card('Q', '♥')];
                this.gamePhase = 'discard';
                this.currentPlayer = 0;
                this.selectedCards = [0];
                this.updateUI();

                console.log('%c✅ TEST SETUP:', 'color:#28a745;font-weight:bold');
                console.log('  Published: J♥ J♦ J♣ (triple) + 7♥ 8♥ 9♥ 10♥ (ladder)');
                console.log('  Hand: J♥ (selected) + Q♥');
                console.log('  J♥ could extend BOTH triple AND ladder!');
                console.log('\n%c▶️ Click "Add Selected Card To: Your Sequences"', 'color:#4a90e2');
                console.log('  Expected: Modal asking "Add to Triple or Ladder?"');
            }

            debugInstantAI() {
                this.aiInstant = !this.aiInstant;
                console.log(`%c⚡ AI Instant Mode: ${this.aiInstant ? 'ON' : 'OFF'}`, 'color:#ffd700;font-weight:bold');
            }

            getAIPersonality(aiIdx) {
                if (this.currentHand <= 3) return this.aiPersonality[aiIdx] || 'neutral';
                const aiScore = this.playerScores[aiIdx];
                const otherScores = this.playerScores.filter((_, idx) => idx !== aiIdx);
                const minOtherScore = Math.min(...otherScores);
                const maxOtherScore = Math.max(...otherScores);
                if (aiScore >= maxOtherScore && aiScore > minOtherScore + 20) return 'rabbit';
                if (aiScore <= minOtherScore) return 'tortoise';
                return this.aiPersonality[aiIdx] || 'neutral';
            }

            initDeck() {
                const suits = ['♠', '♥', '♦', '♣'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                this.deck = [];
                for (let d = 0; d < 2; d++) {
                    for (let suit of suits) {
                        for (let rank of ranks) {
                            this.deck.push(new Card(rank, suit));
                        }
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            isTripleHeavyHand() {
                const req = this.handReqs[this.currentHand].seqs;
                const tripleCount = req.filter(s => s === 'triple').length;
                const ladderCount = req.filter(s => s === 'ladder').length;
                return tripleCount > 0 && (ladderCount === 0 || tripleCount >= ladderCount);
            }

            deal() {
                const cards = this.handReqs[this.currentHand].cards;
                for (let i = 0; i < cards; i++) {
                    for (let p = 0; p < this.players; p++) {
                        if (this.deck.length > 0) this.playerHands[p].push(this.deck.pop());
                    }
                }
                const isLadderOnlyHand = [3, 7].includes(this.currentHand);
                const isTripleHeavy = this.isTripleHeavyHand();
                if (isLadderOnlyHand) {
                    const order = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
                    this.playerHands[0].sort((a, b) => {
                        if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                        return a.getValue() - b.getValue();
                    });
                } else if (isTripleHeavy) {
                    const counts = {};
                    this.playerHands[0].forEach(card => { counts[card.rank] = (counts[card.rank] || 0) + 1 });
                    this.playerHands[0].sort((a, b) => {
                        const countDiff = counts[b.rank] - counts[a.rank];
                        if (countDiff !== 0) return countDiff;
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });
                } else {
                    this.playerHands[0].sort((a, b) => {
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });
                }
                if (this.deck.length > 0) this.discardPile.push(this.deck.pop());
            }

            reshuffleDeck() {
                if (this.discardPile.length <= 1) { console.log('%cNo cards to reshuffle', 'color: #ffc107;'); return false }
                const topCard = this.discardPile.pop();
                this.deck = [...this.discardPile];
                this.discardPile = [topCard];
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
                console.log(`%cReshuffled ${this.deck.length} cards`, 'color: #ffc107; font-weight: bold;');
                return true;
            }

            isValidTriple(cards) { if (cards.length !== 3) return false; return cards.every(c => c.rank === cards[0].rank) }

            isValidLadder(cards) {
                if (cards.length !== 4) return false;
                if (!cards.every(c => c.suit === cards[0].suit)) return false;
                const values = cards.map(c => c.getValue());
                if (values.includes(1) && values.includes(13) && values.includes(12) && values.includes(11)) return true;
                const sorted = [...values].sort((a, b) => a - b);
                for (let i = 1; i < sorted.length; i++) { if (sorted[i] !== sorted[i - 1] + 1) return false }
                return true;
            }

            isLadderHand() { return [2, 3, 5, 6, 7].includes(this.currentHand) }

            hasThreeCardLadderProgress(hand) {
                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                return Object.values(bySuit).some(cards => {
                    if (cards.length < 3) return false;
                    const uniqueByRank = [];
                    const seenRanks = new Set();
                    cards.sort((a, b) => a.getValue() - b.getValue());
                    cards.forEach(card => { if (!seenRanks.has(card.rank)) { uniqueByRank.push(card); seenRanks.add(card.rank) } });
                    for (let i = 0; i < uniqueByRank.length - 2; i++) {
                        if (uniqueByRank[i + 1].getValue() === uniqueByRank[i].getValue() + 1 &&
                            uniqueByRank[i + 2].getValue() === uniqueByRank[i + 1].getValue() + 1) return true;
                    }
                    return false;
                });
            }

            getPublishedRanks(playerIdx) { const ranks = new Set(); this.publishedSequences[playerIdx].forEach(c => ranks.add(c.rank)); return ranks }
            getPublishedSuits(playerIdx) { const suits = new Set(); this.publishedSequences[playerIdx].forEach(c => suits.add(c.suit)); return suits }

            getPublishProgress() {
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const seqs = this.findSequences(this.playerHands[0]);
                const hasTriples = seqs.triples.length;
                const hasLadders = seqs.ladders.length;
                return { needTriples, hasTriples, needLadders, hasLadders, canPublish: hasTriples >= needTriples && hasLadders >= needLadders };
            }

            findSequences(hand) {
                const seqs = { triples: [], ladders: [] };
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                Object.values(byRank).forEach(g => {
                    if (g.length >= 3) {
                        for (let i = 0; i < g.length - 2; i++) {
                            for (let j = i + 1; j < g.length - 1; j++) {
                                for (let k = j + 1; k < g.length; k++) {
                                    seqs.triples.push([g[i], g[j], g[k]]);
                                }
                            }
                        }
                    }
                });
                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                Object.values(bySuit).forEach(g => {
                    if (g.length >= 4) {
                        const hasAce = g.find(c => c.rank === 'A');
                        const hasK = g.find(c => c.rank === 'K');
                        const hasQ = g.find(c => c.rank === 'Q');
                        const hasJ = g.find(c => c.rank === 'J');
                        if (hasAce && hasK && hasQ && hasJ) seqs.ladders.push([hasAce, hasK, hasQ, hasJ]);
                        const uniqueByRank = [];
                        const seenRanks = new Set();
                        g.sort((a, b) => a.getValue() - b.getValue());
                        g.forEach(card => { if (!seenRanks.has(card.rank)) { uniqueByRank.push(card); seenRanks.add(card.rank) } });
                        for (let i = 0; i <= uniqueByRank.length - 4; i++) {
                            const ladder = uniqueByRank.slice(i, i + 4);
                            if (this.isValidLadder(ladder)) seqs.ladders.push(ladder);
                        }
                    }
                });
                return seqs;
            }

            canPublish(pIdx) {
                const hand = this.playerHands[pIdx];
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                const tripleRanks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3);
                if (tripleRanks.length < needTriples) return false;
                const tryPublish = (tripleAssignments, triplesAssigned, usedIds, startRankIdx = 0) => {
                    if (triplesAssigned === needTriples) {
                        let laddersFound = 0; const usedForLadders = new Set(usedIds);
                        for (let i = 0; i < needLadders; i++) {
                            const remaining = hand.filter(c => !usedForLadders.has(c.id));
                            const testSeqs = this.findSequences(remaining);
                            if (testSeqs.ladders.length === 0) break;
                            testSeqs.ladders[0].forEach(c => usedForLadders.add(c.id));
                            laddersFound++;
                        }
                        return laddersFound >= needLadders;
                    }
                    for (let rankIdx = startRankIdx; rankIdx < tripleRanks.length; rankIdx++) {
                        const rank = tripleRanks[rankIdx];
                        const cards = byRank[rank];
                        if (cards.length >= 4) {
                            for (let i = 0; i < cards.length - 2; i++) {
                                for (let j = i + 1; j < cards.length - 1; j++) {
                                    for (let k = j + 1; k < cards.length; k++) {
                                        const newUsed = new Set(usedIds);
                                        newUsed.add(cards[i].id); newUsed.add(cards[j].id); newUsed.add(cards[k].id);
                                        if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                                    }
                                }
                            }
                        } else {
                            const newUsed = new Set(usedIds);
                            cards.slice(0, 3).forEach(c => newUsed.add(c.id));
                            if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                        }
                    }
                    return false;
                };
                return tryPublish([], 0, new Set());
            }

            autoPublish(pIdx) {
                // 🛡️ FIX 6: CRITICAL - Block republishing!
                if (this.publishedSequences[pIdx].length > 0) {
                    console.log(`⏭️ FIX 6: Player ${pIdx} already has ${this.publishedSequences[pIdx].length} published cards - blocking republish`);
                    return false;
                }

                const req = this.handReqs[this.currentHand].seqs;
                const hand = this.playerHands[pIdx];
                const opponentRanks = new Set();

                const opponentSuits = new Set();
                for (let i = 0; i < this.players; i++) {
                    if (i !== pIdx) {
                        this.getPublishedRanks(i).forEach(r => opponentRanks.add(r));
                        this.getPublishedSuits(i).forEach(s => opponentSuits.add(s));
                    }
                }
                let published = [];
                const usedCardIds = new Set();
                let triplesPublished = 0;
                let laddersPublished = 0;
                const triplesNeeded = req.filter(s => s === 'triple').length;
                const laddersNeeded = req.filter(s => s === 'ladder').length;
                while (triplesPublished < triplesNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const byRank = {};
                    availableHand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                    const ranks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3).sort((a, b) => {
                        const aOverlap = opponentRanks.has(a) ? 1 : 0;
                        const bOverlap = opponentRanks.has(b) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return parseInt(a === 'A' ? 1 : a === 'J' ? 11 : a === 'Q' ? 12 : a === 'K' ? 13 : a) -
                            parseInt(b === 'A' ? 1 : b === 'J' ? 11 : b === 'Q' ? 12 : b === 'K' ? 13 : b);
                    });
                    if (ranks.length === 0) break;
                    const rank = ranks[0];
                    const cards = byRank[rank];
                    if (cards.length >= 4) {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    } else {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    }
                    triplesPublished++;
                }
                while (laddersPublished < laddersNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const seqs = this.findSequences(availableHand);
                    if (seqs.ladders.length === 0) break;
                    seqs.ladders.sort((a, b) => {
                        const aOverlap = opponentSuits.has(a[0].suit) ? 1 : 0;
                        const bOverlap = opponentSuits.has(b[0].suit) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return a[0].getValue() - b[0].getValue();
                    });
                    const ladder = seqs.ladders[0];
                    published = published.concat(ladder);
                    ladder.forEach(c => usedCardIds.add(c.id));
                    laddersPublished++;
                }
                if (triplesPublished < triplesNeeded || laddersPublished < laddersNeeded) return false;
                published.forEach(c => {
                    const idx = this.playerHands[pIdx].findIndex(card => card.id === c.id);
                    if (idx > -1) this.playerHands[pIdx].splice(idx, 1);
                });
                this.publishedSequences[pIdx] = published;

                // ← ADD THESE TWO LINES HERE:
                this.renderAIHands();
                this.renderPublished();

                return true;
            }

            canCardExtendLadder(cardVal, ladderValues) {
                const sorted = [...ladderValues].sort((a, b) => a - b);
                const minVal = sorted[0];
                const maxVal = sorted[sorted.length - 1];

                console.log(`  🔍 FIX 1: Checking if ${cardVal} can extend ladder [${sorted.join(',')}]`);

                // Check for wrap-around ladder (A-K-Q-J)
                const hasAce = sorted.includes(1);
                const hasKing = sorted.includes(13);
                const hasQueen = sorted.includes(12);
                const hasJack = sorted.includes(11);
                const isWrapAroundLadder = hasAce && hasJack && hasQueen && hasKing;

                if (isWrapAroundLadder) {
                    if (cardVal === 1) return false; // No duplicate Ace
                    const nonAceValues = sorted.filter(v => v !== 1);
                    const lowEnd = Math.min(...nonAceValues);
                    const canExtend = cardVal === lowEnd - 1;
                    console.log(`  ✅ FIX 1: Wrap-around ladder - Can extend LOW: ${canExtend}`);
                    return canExtend;
                }

                // ✅ FIX 7: Special case - Ace can extend after King (K-A wrap)
                if (cardVal === 1 && maxVal === 13) {
                    console.log(`  ✅ FIX 7: ACE after KING wrap: true`);
                    return true;
                }

                // ✅ FIX 1: Normal ladders - EXPLICIT support for BOTH ends
                const canExtendLow = (cardVal === minVal - 1);
                const canExtendHigh = (cardVal === maxVal + 1);

                console.log(`  ✅ FIX 1: LOW end (${minVal}-1=${minVal - 1}): ${canExtendLow}`);
                console.log(`  ✅ FIX 1: HIGH end (${maxVal}+1=${maxVal + 1}): ${canExtendHigh}`);

                return canExtendLow || canExtendHigh;
            }

            couldExtendSequence(card, playerIdx) {
                const published = this.publishedSequences[playerIdx];
                if (published.length === 0) return false;
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const publishedRankCounts = {};
                published.forEach(c => { publishedRankCounts[c.rank] = (publishedRankCounts[c.rank] || 0) + 1 });
                const hasActualTriples = Object.values(publishedRankCounts).some(count => count >= 3);
                const publishedSuits = {};
                published.forEach(c => { if (!publishedSuits[c.suit]) publishedSuits[c.suit] = []; publishedSuits[c.suit].push(c.getValue()) });
                const hasActualLadders = Object.values(publishedSuits).some(vals => vals.length >= 4);
                if (hasTriples || hasActualTriples) { if (publishedRankCounts[card.rank] >= 3) return true }
                if (hasLadders || hasActualLadders) {
                    const sameSuit = published.filter(c => c.suit === card.suit);
                    console.log(`  🔍 FIX 1B: Checking ${card.toString()} against ${sameSuit.length} published ${card.suit} cards`);
                    if (sameSuit.length >= 4) {
                        const cardVal = card.getValue();
                        const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                        const ladders = []; let remainingValues = [...values];
                        const hasAce = values.includes(1); const hasJack = values.includes(11);
                        const hasQueen = values.includes(12); const hasKing = values.includes(13);
                        if (hasAce && hasJack && hasQueen && hasKing) {
                            ladders.push([1, 11, 12, 13]);
                            remainingValues = remainingValues.filter(v => ![1, 11, 12, 13].includes(v));
                        }
                        if (remainingValues.length >= 4) {
                            let currentLadder = [remainingValues[0]];
                            for (let i = 1; i < remainingValues.length; i++) {
                                if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                    currentLadder.push(remainingValues[i]);
                                } else {
                                    if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                    currentLadder = [remainingValues[i]];
                                }
                            }
                            if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                        }
                        const canExtend = ladders.some(ladder => {
                            return this.canCardExtendLadder(cardVal, ladder);
                        });
                        if (canExtend) return true;
                    }
                }
                return false;
            }

            canAddToPublishedSequence(card, publishedSequence) {
                // Check if card can be added to this published sequence
                const seq = publishedSequence.cards || publishedSequence;

                // For triples/quads - check if same rank
                if (seq.length >= 3 && seq.every(c => c.rank === seq[0].rank)) {
                    return card.rank === seq[0].rank;
                }

                // For runs - check if can extend at either end
                if (seq.length >= 3) {
                    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                    const seqSuit = seq[0].suit;

                    if (card.suit !== seqSuit) return false;

                    const seqRanks = seq.map(c => c.rank);
                    const firstRank = seqRanks[0];
                    const lastRank = seqRanks[seqRanks.length - 1];

                    const firstIdx = ranks.indexOf(firstRank);
                    const lastIdx = ranks.lastIndexOf(lastRank);

                    // Can add before first card?
                    if (firstIdx > 0 && ranks[firstIdx - 1] === card.rank) return true;

                    // Can add after last card?
                    if (lastIdx < ranks.length - 1 && ranks[lastIdx + 1] === card.rank) return true;
                }

                return false;
            }

            evaluateCard(card, pIdx) {
                const hand = this.playerHands[pIdx];
                let val = 0;
                const sameRank = hand.filter(c => c.rank === card.rank).length;
                const sameSuit = hand.filter(c => c.suit === card.suit);
                if (sameRank >= 2) val += 20;
                else if (sameRank === 1) val += 8;
                if (sameSuit.length >= 3) {
                    const values = sameSuit.map(c => c.getValue());
                    const cardVal = card.getValue();
                    const allValues = [...values, cardVal].sort((a, b) => a - b);
                    let maxConsecutive = 1;
                    let currentConsecutive = 1;
                    for (let i = 1; i < allValues.length; i++) {
                        if (allValues[i] === allValues[i - 1] + 1) {
                            currentConsecutive++;
                            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                        } else if (allValues[i] !== allValues[i - 1]) {
                            currentConsecutive = 1;
                        }
                    }
                    if (maxConsecutive >= 4) val += 25;
                    else if (maxConsecutive === 3) val += 15;
                    else if (maxConsecutive === 2) val += 5;
                } else if (sameSuit.length >= 2) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 6;
                } else if (sameSuit.length === 1) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 3;
                }
                if (this.publishedSequences[pIdx].length > 0) {
                    if (this.couldExtendSequence(card, pIdx)) val += 100;
                }
                for (let p = 0; p < this.players; p++) {
                    if (this.publishedSequences[p].length === 0) continue;
                    if (p === pIdx) continue;
                    const opponentHandSize = this.playerHands[p].length;
                    if (opponentHandSize <= 4 && this.couldExtendSequence(card, p)) {
                        val -= 30;
                    } else if (this.couldExtendSequence(card, p)) {
                        val += 30;
                    }
                }
                return val;
            }

            findWorstCard(pIdx) {
                const hand = this.playerHands[pIdx];

                // [Keep existing ladder deadlock code here...]

                // ✅ NEW: Check if card can be added to MY OWN published sequences
                console.log(`  → FIX 4A: Checking cards that extend my published sequences`);
                const myPublished = this.publishedSequences[pIdx];
                if (myPublished && myPublished.length > 0) {
                    const cardsExtendingMyPublished = hand.filter(c => {
                        return myPublished.some(pubSeq => this.canAddToPublishedSequence(c, pubSeq));
                    });

                    if (cardsExtendingMyPublished.length > 0) {
                        console.log(`  → FIX 4A: Found ${cardsExtendingMyPublished.length} card(s) that can extend my published sequences - keeping them`);
                        // Filter these out from consideration for discard
                        const cardsNotExtendingMine = hand.filter(c =>
                            !cardsExtendingMyPublished.includes(c)
                        );
                        if (cardsNotExtendingMine.length > 0) {
                            // Continue with remaining cards only
                            hand = cardsNotExtendingMine;
                        }
                    }
                }

                // ✅ UPDATED FIX 4: Check critical danger with PUBLISHED SEQUENCES
                console.log(`  → FIX 4B: Checking critical danger with published sequences`);
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue; // Skip self
                    const opponentCards = this.playerHands[p].length;
                    const opponentPublished = this.publishedSequences[p].length > 0;

                    // If opponent has published and has ≤2 cards, they're in endgame
                    if (opponentPublished && opponentCards <= 2) {
                        const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                        console.log(`  → FIX 4B: CRITICAL - ${playerName} has ${opponentCards} card(s) and published!`);

                        // Filter out cards that help them (including via ANY published sequences)
                        const safeCards = hand.filter(c => {
                            // Check if extends opponent's hand
                            if (this.couldExtendSequence(c, p)) return false;

                            // ✅ NEW: Check if can be added to ANY published sequence (any player)
                            for (let player = 0; player < this.players; player++) {
                                const published = this.publishedSequences[player];
                                if (published && published.length > 0) {
                                    for (let pubSeq of published) {
                                        if (this.canAddToPublishedSequence(c, pubSeq)) {
                                            console.log(`  → FIX 4B: ${c.toString()} can add to published sequence - NOT SAFE`);
                                            return false; // Not safe - can extend published
                                        }
                                    }
                                }
                            }
                            return true; // Safe - doesn't help via hand or published
                        });

                        if (safeCards.length > 0) {
                            // Discard highest penalty from safe cards
                            const worst = safeCards.reduce((max, c) =>
                                c.getPenaltyValue() > max.getPenaltyValue() ? c : max
                            );
                            console.log(`  → v2.0.1 FIX 4: Safe discard: ${worst.toString()} (doesn't help ${playerName})`);
                            return worst;
                        } else {
                            console.log(`  → v2.0.1 FIX 4: WARNING - ALL cards help ${playerName}! Using least valuable...`);
                            // If all cards help, pick the least strategically valuable
                            let minValue = this.evaluateCard(hand[0], pIdx);
                            let worst = hand[0];
                            hand.forEach(c => {
                                const val = this.evaluateCard(c, pIdx);
                                if (val < minValue) {
                                    minValue = val;
                                    worst = c;
                                }
                            });
                            return worst;
                        }
                    }
                }


                const isLadderOnlyHand = this.handReqs[this.currentHand].seqs.every(seq => seq === 'ladder');
                if (isLadderOnlyHand && this.turnCounter > 80 && hand.length >= 15) {
                    const potentialLadders = {};
                    hand.forEach(card => { if (!potentialLadders[card.suit]) potentialLadders[card.suit] = []; potentialLadders[card.suit].push(card.getValue()) });
                    const keepCards = new Set();
                    Object.entries(potentialLadders).forEach(([suit, values]) => {
                        const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
                        for (let i = 0; i < uniqueValues.length; i++) {
                            let runLength = 1;
                            let currentValue = uniqueValues[i];
                            while (i + runLength < uniqueValues.length && uniqueValues[i + runLength] === currentValue + runLength) runLength++;
                            if (runLength >= 3) {
                                for (let k = 0; k < runLength; k++) {
                                    const cardValue = currentValue + k;
                                    const cardsWithValue = hand.filter(c => c.suit === suit && c.getValue() === cardValue);
                                    cardsWithValue.forEach(c => keepCards.add(c.id));
                                }
                            }
                        }
                    });
                    const dumpCandidates = hand.filter(c => !keepCards.has(c.id));
                    if (dumpCandidates.length > 0) {
                        const worst = dumpCandidates.reduce((max, c) => c.getPenaltyValue() > max.getPenaltyValue() ? c : max);
                        return worst;
                    }
                }
                const hasPublished = this.publishedSequences[pIdx].length > 0;
                if (!hasPublished) {
                    const othersPublished = this.publishedSequences.some((seq, idx) => idx !== pIdx && seq.length > 0);
                    const othersLowCards = this.playerHands.some((h, idx) => idx !== pIdx && h.length <= 2);
                    if (othersPublished && othersLowCards) {
                        if (this.turnCounter > 120) {
                            const highestPenalty = hand.reduce((max, card) => card.getPenaltyValue() > max.getPenaltyValue() ? card : max);
                            return highestPenalty;
                        }
                        const seqs = this.findSequences(hand);
                        const inSequences = new Set();
                        seqs.triples.forEach(t => t.forEach(c => inSequences.add(c.id)));
                        seqs.ladders.forEach(l => l.forEach(c => inSequences.add(c.id)));
                        const safeToDump = hand.filter(c => {
                            if (inSequences.has(c.id)) return false;
                            for (let p = 0; p < this.players; p++) {
                                if (p === pIdx) continue;
                                if (this.playerHands[p].length <= 2 && this.couldExtendSequence(c, p)) return false;
                            }
                            return true;
                        });
                        if (safeToDump.length > 0) {
                            const highPenalty = safeToDump.sort((a, b) => b.getPenaltyValue() - a.getPenaltyValue())[0];
                            return highPenalty;
                        }
                        const pairs = {};
                        hand.forEach(c => { pairs[c.rank] = (pairs[c.rank] || []); pairs[c.rank].push(c) });
                        const pairCards = [];
                        Object.entries(pairs).forEach(([rank, cards]) => { if (cards.length === 2) pairCards.push(...cards) });
                        if (pairCards.length > 0) {
                            const worst = pairCards.reduce((min, c) => c.getValue() < min.getValue() ? c : min);
                            return worst;
                        }
                        const notInSeq = hand.filter(c => !inSequences.has(c.id));
                        if (notInSeq.length > 0) {
                            const lowest = notInSeq.reduce((min, c) => c.getPenaltyValue() < min.getPenaltyValue() ? c : min);
                            return lowest;
                        }
                    }
                }
                const rankCounts = {};
                hand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { hand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[pIdx].length > 0) {
                    hand.forEach(c => { if (this.couldExtendSequence(c, pIdx)) protectedCards.add(c.id) });
                }
                const criticalDanger = new Set();
                const moderateDanger = new Set();
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue;
                    if (this.publishedSequences[p].length === 0) continue;
                    const opponentCards = this.playerHands[p].length;
                    hand.forEach(c => {
                        if (this.couldExtendSequence(c, p)) {
                            if (opponentCards <= 2) { criticalDanger.add(c.id); protectedCards.add(c.id) }
                            else if (opponentCards <= 4) { moderateDanger.add(c.id); protectedCards.add(c.id) }
                        }
                    });
                }
                const safeCards = hand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worst = safeCards[0];
                    let minVal = this.evaluateCard(worst, pIdx);
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; worst = c }
                    });
                    return worst;
                }
                const nonCriticalCards = hand.filter(c => !criticalDanger.has(c.id));
                if (nonCriticalCards.length > 0) {
                    const cardsNotExtendingOwn = [];
                    const cardsExtendingOwn = [];
                    nonCriticalCards.forEach(c => {
                        if (this.couldExtendSequence(c, pIdx)) cardsExtendingOwn.push(c);
                        else cardsNotExtendingOwn.push(c);
                    });
                    if (cardsNotExtendingOwn.length > 0) {
                        let worst = cardsNotExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsNotExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                    if (cardsExtendingOwn.length > 0) {
                        let worst = cardsExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                }
                let leastUrgent = hand[0];
                let maxOpponentCards = 0;
                hand.forEach(c => {
                    for (let p = 0; p < this.players; p++) {
                        if (p === pIdx) continue;
                        if (this.couldExtendSequence(c, p)) {
                            const opponentCards = this.playerHands[p].length;
                            if (opponentCards > maxOpponentCards) { maxOpponentCards = opponentCards; leastUrgent = c }
                        }
                    }
                });
                if (maxOpponentCards === 0) {
                    let minVal = this.evaluateCard(leastUrgent, pIdx);
                    hand.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; leastUrgent = c }
                    });
                }
                return leastUrgent;
            }

            shouldAllowBuy(ai, discardCard) {
                const buysRemaining = this.playerBuys[ai];
                if (buysRemaining === 0) return false;
                const hand = this.playerHands[ai];
                const buysUsed = (this.currentHand === 7 ? 2 : 3) - buysRemaining;
                const seqs = this.findSequences(hand);
                const hasTriple = seqs.triples.length > 0;
                const hasLadder = seqs.ladders.length > 0;
                const strategicValue = this.evaluateCard(discardCard, ai);
                const penaltyValue = discardCard.getPenaltyValue();
                const cardValue = strategicValue + penaltyValue;
                switch (this.currentHand) {
                    case 1: if (buysUsed >= 2) return false; if (!hasTriple && cardValue < 30) return false; return hasTriple || cardValue >= 30;
                    case 2: if (buysUsed >= 2) return false; const hasSequence = hasTriple || hasLadder; return hasSequence && cardValue >= 25;
                    case 3:
                        if (buysUsed < 2) return cardValue >= 35;
                        if (buysUsed === 2) { const has3CardProgress = this.hasThreeCardLadderProgress(hand); return has3CardProgress && cardValue >= 30 }
                        return false;
                    case 4: if (buysUsed >= 2) return false; return hasTriple && cardValue >= 25;
                    case 5: if (buysUsed >= 2) return false; const hasAnySequence = hasTriple || hasLadder; return hasAnySequence && cardValue >= 30;
                    case 6: if (buysUsed >= 1) return false; const hasBothTypes = hasTriple && hasLadder; return hasBothTypes && cardValue >= 35;
                    case 7: return cardValue >= 30;
                    default: return false;
                }
            }

            shouldRequestBuy(ai) {
                if (this.playerBuys[ai] === 0) return false;
                if (this.publishedSequences[ai].length > 0) return false;
                const humanPublished = this.publishedSequences[0].length > 0;
                if (humanPublished) return false;
                const othersPublishedWith3Plus = this.publishedSequences.some((seq, idx) => {
                    if (idx === ai) return false;
                    return seq.length > 0 && this.playerHands[idx].length >= 3;
                });
                if (othersPublishedWith3Plus && this.playerHands[ai].length >= 3) return true;
                return false;
            }

            setAIStatus(aiId, message) { const actionElement = document.getElementById(`${aiId}-action`); if (actionElement) actionElement.textContent = message }

            startBuyWindow(card, discardingPlayer) {
                if (!card) { console.log(`%c⚠️ Cannot open buy window - no card provided`, 'color: #ff6600; font-weight: bold;'); return }
                const buyWindowPlayer = (discardingPlayer + 2) % 3;
                if (this.buyWindow.active) this.closeBuyWindow();

                // ✅ FIX 3: Use 5 seconds if human just published, 10 seconds otherwise
                // Nash: Changed values 3 seconds and 7 seconds to make game faster
                const duration = this.justPublished ? 3000 : 7000;
                console.log(`%c⏱️ FIX 3: Buy window duration: ${duration / 1000}s (justPublished: ${this.justPublished})`, 'color: #ffc107; font-weight: bold;');
                this.buyWindow.active = true;
                this.buyWindow.card = card;
                this.buyWindow.discardingPlayer = discardingPlayer;
                this.buyWindow.buyWindowPlayer = buyWindowPlayer;
                this.buyWindow.expiresAt = Date.now() + duration;
                const playerNames = ['Human', 'Habot', 'Jabot'];
                console.log(`%c🔓 Buy window opened for ${playerNames[buyWindowPlayer]} (${card.toString()}) - ${duration / 1000}s`, 'color: #ffc107; font-weight: bold;');
                if (buyWindowPlayer === 0) document.getElementById('buyBtn').disabled = false;
                this.updateBuyTimer();
            }

            checkAndOpenBuyWindowAfterDiscard(currentAI, statusId) {
                const aiName = currentAI === 1 ? 'Habot' : 'Jabot';

                // Check if we have a valid lastDiscard to create buy window for
                if (!this.lastDiscard || this.lastDiscardByPlayer === -1) {
                    console.log(`%c  ⏭️  No buy window: no valid lastDiscard`, 'color: #95a5a6;');
                    return false; // No buy window opened
                }

                const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                console.log(`%c  💡 Buy window check after ${aiName} discard`, 'color: #9b59b6; font-weight: bold;');
                console.log(`     lastDiscard: ${this.lastDiscard.toString()}`);
                console.log(`     lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);
                console.log(`     buyWindowPlayer: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                // Validate buy window conditions
                if (buyWindowPlayer === currentAI || buyWindowPlayer === this.lastDiscardByPlayer) {
                    console.log(`     ❌ Buy window blocked: invalid player configuration`);
                    return false;
                }

                console.log(`     ✅ Opening buy window!`);

                // Save next player info for after buy window closes
                const nextPlayer = (this.currentPlayer + 1) % this.players;
                this.buyWindow.pendingNextPlayer = nextPlayer;

                // Open the buy window
                this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);

                // Handle AI buy window if needed
                if (buyWindowPlayer > 0) {
                    this.handleAIBuyWindow(buyWindowPlayer);
                }

                // Clean up status after a delay
                if (statusId) {
                    setTimeout(() => {
                        document.getElementById(`${statusId}-status`).classList.remove('active');
                    }, 2000);
                }

                return true; // Buy window was opened
            }



            closeBuyWindow(reason = 'expired') {
                if (!this.buyWindow.active) return;

                const wasActive = this.buyWindow.active;
                const pendingDraw = this.buyWindow.pendingDeckDraw;
                const pendingNextPlayer = this.buyWindow.pendingNextPlayer; // ✅ NEW

                // Clear buy window state
                this.buyWindow.active = false;
                this.buyWindow.card = null;
                this.buyWindow.discardingPlayer = -1;
                this.buyWindow.buyWindowPlayer = -1;
                this.buyWindow.pendingDeckDraw = null;
                this.buyWindow.pendingNextPlayer = null; // ✅ NEW

                if (this.buyWindow.timerInterval) {
                    clearTimeout(this.buyWindow.timerInterval);
                    this.buyWindow.timerInterval = null;
                }

                document.getElementById('buyBtn').disabled = true;
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) timerEl.style.display = 'none';

                // Log the closure reason
                if (reason === 'taken') {
                    showToast('Buy Denied - Card was taken', 'warning', 2000);
                } else if (reason === 'expired') {
                    console.log('%c⏱️ Buy window expired', 'color: #94a3b8;');
                } else if (reason === 'player-turn') {
                    console.log('%c🎮 Buy window closed - your turn', 'color: #4a90e2;');
                } else if (reason === 'player-took') {
                    console.log('%c✅ Buy window closed - you took the card', 'color: #28a745;');
                } else if (reason === 'bought') {
                    console.log('%c💰 Human bought card', 'color: #ffc107;');
                } else if (reason === 'ai-bought') {
                    console.log('%c💰 AI bought card', 'color: #ffc107;');
                }

                // Handle pendingDeckDraw (buy window opened during deck draw)
                if (pendingDraw && (reason === 'expired' || reason === 'bought')) {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%c▶️ Resuming ${aiName}'s turn after buy window`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before drawing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`✅ PATCH 1: ${aiName} auto-published sequences after buy window!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                } else if (pendingDraw && reason === 'ai-bought') {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%c▶️ Resuming ${aiName}'s turn (AI bought, skipping duplicate draw)`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before continuing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`✅ PATCH 1: ${aiName} auto-published after AI bought!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                }
                // ✅ NEW: Handle pendingNextPlayer (buy window opened after AI discarded from discard pile)
                else if (pendingNextPlayer !== null && pendingNextPlayer !== undefined) {
                    console.log(`%c▶️ Advancing to next player after buy window: Player ${pendingNextPlayer}`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        this.currentPlayer = pendingNextPlayer;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) {
                            this.aiTurn();
                        }
                    }, 500);
                }
            }

            updateBuyTimer() {
                if (!this.buyWindow.active) return;
                const remaining = Math.ceil((this.buyWindow.expiresAt - Date.now()) / 1000);
                if (remaining <= 0) { this.closeBuyWindow('expired'); return }
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) {
                    timerEl.textContent = ` (${remaining}s)`;
                    timerEl.style.display = 'inline';
                    timerEl.style.color = remaining <= 2 ? '#ff6b35' : '#ffd700';
                }
                this.buyWindow.timerInterval = setTimeout(() => this.updateBuyTimer(), 100);
            }

            handleAIBuyWindow(aiPlayer) {
                const aiName = aiPlayer === 1 ? 'Habot' : 'Jabot';
                const card = this.buyWindow.card;

                // ✅ FIX 9: If buy window is for HUMAN, don't let AI handle it!
                if (this.buyWindow.buyWindowPlayer === 0) {
                    console.log(`%c🚫 FIX 9: Buy window is for HUMAN - AI should not interfere!`, 'color: #ff6b35; font-weight: bold;');
                    return;
                }

                if (!card) {
                    console.log(`%c⚠️ ${aiName} buy window has no card - closing`, 'color: #ff6600; font-weight: bold;');
                    this.closeBuyWindow('invalid');
                    if (this.buyWindow.pendingDeckDraw) {
                        const { ai, statusId } = this.buyWindow.pendingDeckDraw;
                        setTimeout(() => { this.drawDeckCardForAI(ai, statusId); this.continueAITurnAfterDraw(ai, statusId) }, 100);
                    }
                    return;
                }

                const statusId = aiPlayer === 1 ? 'habot' : 'jabot';
                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, `Considering buy...`);
                setTimeout(() => {
                    const shouldBuy = this.shouldAllowBuy(aiPlayer, card);
                    if (shouldBuy && this.playerBuys[aiPlayer] > 0) {
                        const idx = this.discardPile.findIndex(c => c.id === card.id);
                        if (idx > -1) {
                            this.discardPile.splice(idx, 1);
                            this.playerHands[aiPlayer].push(card);
                            if (this.lastDiscard && this.lastDiscard.rank === card.rank && this.lastDiscard.suit === card.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (this.deck.length === 0) this.reshuffleDeck();
                            if (this.deck.length > 0) {
                                const penalty = this.deck.pop();
                                this.playerHands[aiPlayer].push(penalty);
                            }
                            this.playerBuys[aiPlayer]--;
                            showBuyToast(aiName, card);
                            this.updateUI();
                        }
                    }
                    document.getElementById(`${statusId}-status`).classList.remove('active');
                    this.closeBuyWindow('ai-bought');
                }, 2500);
            }

            wouldDiscardImmediately(card, ai) {
                const tempHand = [...this.playerHands[ai], card];
                const rankCounts = {};
                tempHand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { tempHand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[ai].length > 0) {
                    if (this.couldExtendSequence(card, ai)) protectedCards.add(card.id);
                }
                const safeCards = tempHand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worstValue = 9999;
                    let worstCard = null;
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, ai);
                        if (val < worstValue) { worstValue = val; worstCard = c }
                    });
                    if (worstCard && worstCard.rank === card.rank && worstCard.suit === card.suit) return true;
                }
                return false;
            }

            aiTurn() {
                const ai = this.currentPlayer;
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                const statusId = ai === 1 ? 'habot' : 'jabot';

                console.log(`%c🤖 ${aiName} starting turn`, 'color: #3498db; font-weight: bold;');

                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, 'Taking turn...');
                const delay = this.aiInstant ? 0 : 1500;
                setTimeout(() => {
                    this.turnCounter++;
                    console.log(`%c  Turn ${this.turnCounter}`, 'color: #3498db;');

                    // PATCH 2: Check hand size - block buying if 13+ cards
                    const currentHandSize = this.playerHands[ai].length;
                    if (currentHandSize >= 13) {
                        console.log(`%c⛔ PATCH 2: ${aiName} has ${currentHandSize} cards - must reduce hand`, 'color: #e74c3c; font-weight: bold;');
                        // Force draw from deck instead of evaluating discard
                        console.log(`%c  ${aiName} drawing from deck (hand too large)...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    // PATCH 3: Try to auto-publish at turn start if hand is large
                    if (currentHandSize >= 12 && this.publishedSequences[ai].length === 0) {
                        console.log(`%c🚨 PATCH 3: ${aiName} has ${currentHandSize} cards and hasn't published - forcing publish check`, 'color: #e74c3c; font-weight: bold;');
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`%c✅ PATCH 3: ${aiName} emergency published!`, 'color: #27ae60; font-weight: bold;');
                            // Update hand size after publishing
                            const newHandSize = this.playerHands[ai].length;
                            console.log(`%c   Hand size reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                        }
                    }

                    let discardCard = null;
                    let discardScore = 0;
                    if (this.discardPile.length > 0) {
                        discardCard = this.discardPile[this.discardPile.length - 1];
                        discardScore = this.evaluateCard(discardCard, ai);
                        if (this.lastAIDiscard[ai] && this.lastAIDiscard[ai].rank === discardCard.rank && this.lastAIDiscard[ai].suit === discardCard.suit) {
                            discardScore = -999;
                        }
                    }

                    //Nash: Changed threshold from 15 to  11 to make the game faster
                    let threshold = 11;
                    if (this.publishedSequences[ai].length === 0) {
                        const seqs = this.findSequences(this.playerHands[ai]);
                        const req = this.handReqs[this.currentHand].seqs;
                        const needTriples = req.filter(s => s === 'triple').length;
                        const needLadders = req.filter(s => s === 'ladder').length;
                        const hasTriples = seqs.triples.length;
                        const hasLadders = seqs.ladders.length;
                        if (hasTriples >= needTriples - 1 || hasLadders >= needLadders - 1) threshold = 10;
                    }
                    const personality = this.getAIPersonality(ai);
                    if (personality === 'rabbit') threshold -= 2;
                    else if (personality === 'tortoise') threshold += 2;
                    const forceBuy = discardCard && this.shouldAllowBuy(ai, discardCard);
                    const shouldTake = forceBuy || (discardCard && discardScore >= threshold);

                    console.log(`%c  🎯 ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                    console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                    console.log(`     discardScore: ${discardScore}`);
                    console.log(`     threshold: ${threshold}`);
                    console.log(`     forceBuy: ${forceBuy}`);
                    console.log(`     shouldTake: ${shouldTake}`);

                    if (shouldTake && this.discardPile.length > 0) {
                        if (this.wouldDiscardImmediately(this.discardPile[this.discardPile.length - 1], ai)) {
                            this.setAIStatus(statusId, `Evaluating options...`);
                            this.handleDeckDraw(ai, statusId);
                            return;
                        } else {
                            const drawnCard = this.discardPile.pop();
                            this.playerHands[ai].push(drawnCard);
                            if (this.buyWindow.active && this.buyWindow.buyWindowPlayer === 0 && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                console.log(`%c🚨 FIX 2: AI took card during human buy window`, 'color: #ff6b35; font-weight: bold;');
                                showAITookCardToast(aiName, drawnCard);
                            }
                            if (this.buyWindow.active && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                this.closeBuyWindow('taken');
                            }
                            if (this.lastDiscard && this.lastDiscard.rank === drawnCard.rank && this.lastDiscard.suit === drawnCard.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (forceBuy) this.setAIStatus(statusId, `Analyzing hand...`);
                            else this.setAIStatus(statusId, `Drawing card...`);
                        }

                    } else {

                        console.log(`%c  🎯 ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                        console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                        console.log(`     discardScore: ${discardScore}`);
                        console.log(`     threshold: ${threshold}`);
                        console.log(`     forceBuy: ${forceBuy}`);
                        console.log(`     shouldTake: ${shouldTake}`);

                        console.log(`%c  ${aiName} drawing from deck...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    this.continueAITurnAfterDraw(ai, statusId);
                }, 1500);
            }

            handleDeckDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';

                console.log(`%c🔍 handleDeckDraw called for ${aiName}`, 'color: #9b59b6; font-weight: bold;');
                console.log(`  lastDiscard: ${this.lastDiscard ? this.lastDiscard.toString() : 'null'}`);
                console.log(`  lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);

                if (this.lastDiscard && this.lastDiscardByPlayer !== -1) {
                    const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                    console.log(`  buyWindowPlayer would be: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                    if (buyWindowPlayer !== ai && buyWindowPlayer !== this.lastDiscardByPlayer) {
                        console.log(`  ✅ Buy window conditions met!`);
                        const cardStillExists = this.discardPile.some(c => c.rank === this.lastDiscard.rank && c.suit === this.lastDiscard.suit);

                        if (!cardStillExists) {
                            this.lastDiscard = null;
                            this.lastDiscardByPlayer = -1;
                            this.drawDeckCardForAI(ai, statusId);
                            this.continueAITurnAfterDraw(ai, statusId);
                            return;
                        }
                        this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);
                        this.buyWindow.pendingDeckDraw = { ai, statusId };
                        if (buyWindowPlayer > 0) this.handleAIBuyWindow(buyWindowPlayer);
                        return;
                    }
                }
                this.drawDeckCardForAI(ai, statusId);
                this.continueAITurnAfterDraw(ai, statusId);
            }

            drawDeckCardForAI(ai, statusId) {
                if (this.deck.length === 0) { this.reshuffleDeck(); this.updateUI() }
                if (this.deck.length > 0) {
                    const drawnCard = this.deck.pop();
                    this.playerHands[ai].push(drawnCard);
                    this.setAIStatus(statusId, `Analyzed hand`);
                }
            }

            continueAITurnAfterDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';

                // PATCH 4: Emergency publish if hand is too large
                const currentHandSize = this.playerHands[ai].length;
                if (currentHandSize >= 13 && this.publishedSequences[ai].length === 0 && this.canPublish(ai)) {
                    console.log(`%c🚨 PATCH 4: ${aiName} has ${currentHandSize} cards - FORCING publish!`, 'color: #e74c3c; font-weight: bold;');
                    const publishSuccess = this.autoPublish(ai);
                    if (publishSuccess) {
                        this.aiJustPublished[ai] = true;
                        this.setAIStatus(statusId, `Emergency Published!`);
                        console.log(`%c✅ PATCH 4: ${aiName} emergency publish SUCCESS!`, 'color: #27ae60; font-weight: bold;');
                        const newHandSize = this.playerHands[ai].length;
                        console.log(`%c   Hand reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                    } else {
                        console.log(`%c⚠️ PATCH 4: ${aiName} emergency publish FAILED - no valid sequences`, 'color: #f39c12; font-weight: bold;');
                    }
                }

                const canPublishNow = this.canPublish(ai) && this.publishedSequences[ai].length === 0;

                if (canPublishNow) {
                    let shouldPublish = false;
                    const opponentDanger = this.publishedSequences.some((seq, idx) => idx !== ai && seq.length > 0 && this.playerHands[idx].length <= 3);
                    if (opponentDanger) shouldPublish = true;
                    const personality = this.getAIPersonality(ai);

                    //Nash: changed it from 22 : 30 to make the game faster
                    const turnLimit = personality === 'rabbit' ? 15 : 20;
                    if (this.turnCounter >= turnLimit) shouldPublish = true;
                    else {
                        let optimalSize = this.currentHand <= 3 ? 7 : 6;
                        if (personality === 'rabbit') optimalSize += 1;
                        else if (personality === 'tortoise') optimalSize -= 1;
                        if (this.playerHands[ai].length <= optimalSize) shouldPublish = true;
                    }

                    console.log(`%c  📋 ${aiName} publish check:`, 'color: #9b59b6; font-weight: bold;');
                    console.log(`     canPublishNow: ${canPublishNow}`);
                    console.log(`     opponentDanger: ${opponentDanger}`);
                    console.log(`     turnCounter: ${this.turnCounter}`);
                    console.log(`     handSize: ${this.playerHands[ai].length}`);
                    console.log(`     shouldPublish: ${shouldPublish}`);

                    if (shouldPublish) {
                        console.log(`%c  🎉 ${aiName} attempting to publish!`, 'color: #28a745; font-weight: bold;');
                        const publishSuccess = this.autoPublish(ai);
                        console.log(`     publishSuccess: ${publishSuccess}`);

                        if (publishSuccess) {
                            this.aiJustPublished[ai] = true;
                            this.setAIStatus(statusId, `Published!`);
                            console.log(`%c  ✅ ${aiName} PUBLISHED successfully!`, 'color: #28a745; font-weight: bold;');
                            console.log(`     Published sequences:`, this.publishedSequences[ai]);
                        } else {
                            console.log(`%c  ❌ ${aiName} publish FAILED`, 'color: #dc3545; font-weight: bold;');
                        }
                        if (this.playerHands[ai].length === 0) {
                            console.log(`%c  🏆 ${aiName} has NO cards left - WINS!`, 'color: #ffc107; font-weight: bold;');
                            this.endHand(ai);
                            return;
                        }
                    }
                }

                // PATCH 5: Try to publish again if still holding 12+ cards after first publish
                if (this.playerHands[ai].length >= 12 && this.publishedSequences[ai].length > 0 && this.canPublish(ai)) {
                    console.log(`%c🚨 PATCH 5: ${aiName} still has ${this.playerHands[ai].length} cards after publishing - checking for more sequences`, 'color: #e74c3c; font-weight: bold;');
                    const additionalPublish = this.autoPublish(ai);
                    if (additionalPublish) {
                        console.log(`%c✅ PATCH 5: ${aiName} published additional sequences!`, 'color: #27ae60; font-weight: bold;');
                    }
                }

                if (!this.aiJustPublished[ai] && this.playerHands[ai].length > 0 && this.publishedSequences[ai].length > 0) {
                    const addResult = this.tryAddToPublished(ai);

                    if (addResult === 'win') {
                        this.setAIStatus(statusId, `Added and WINS!`);
                        this.updateUI();
                        setTimeout(() => { this.endHand(ai) }, 50);
                        return;
                    } else if (addResult === true) {
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ' → Added card');
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 1500);
                    return;
                }
                if (this.playerHands[ai].length > 0) {
                    const worst = this.findWorstCard(ai);
                    const idx = this.playerHands[ai].findIndex(c => c.id === worst.id);
                    if (idx > -1) {
                        this.playerHands[ai].splice(idx, 1);
                        this.discardPile.push(worst);
                        this.lastAIDiscard[ai] = worst;
                        this.lastDiscard = worst;
                        this.lastDiscardByPlayer = ai;
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ` → Discarded: ${worst.toString()}`);
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 50);
                    return;
                }
                if (this.shouldRequestBuy(ai)) {
                    const current = document.getElementById(`${statusId}-action`).textContent;
                    if (!current.includes('BUY!')) this.setAIStatus(statusId, current + ' → Says "BUY!"');
                }

                this.lastDiscard = this.discardPile[this.discardPile.length - 1];
                this.lastDiscardByPlayer = ai;
                this.aiJustPublished[ai] = false;

                // ✅ Check if buy window should open after AI discarded
                const buyWindowOpened = this.checkAndOpenBuyWindowAfterDiscard(ai, statusId);

                if (buyWindowOpened) {
                    // Buy window is open - it will handle game continuation
                    return;
                }

                // No buy window - continue normally
                setTimeout(() => { document.getElementById(`${statusId}-status`).classList.remove('active') }, 2000);
                this.currentPlayer = (this.currentPlayer + 1) % this.players;
                this.gamePhase = 'draw';
                this.updateUI();
                if (this.currentPlayer !== 0) this.aiTurn();
            }

            tryAddToPublished(aiIdx) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const playerOrder = [aiIdx];
                for (let p = 0; p < this.players; p++) {
                    if (p !== aiIdx) playerOrder.push(p);
                }
                for (let p of playerOrder) {
                    if (this.publishedSequences[p].length === 0) continue;
                    if (p !== aiIdx && this.playerHands[p].length <= 4) continue;
                    for (let i = 0; i < this.playerHands[aiIdx].length; i++) {
                        const card = this.playerHands[aiIdx][i];
                        const published = this.publishedSequences[p];
                        const inOwnSequences = this.publishedSequences[aiIdx].find(c => c.rank === card.rank && c.suit === card.suit);
                        if (inOwnSequences) continue;
                        const alreadyPublished = published.find(c => c.id === card.id);
                        if (alreadyPublished) continue;
                        const sameRankSuit = published.filter(c => c.rank === card.rank && c.suit === card.suit);
                        if (sameRankSuit.length >= 2) continue;
                        if (hasTriples) {
                            const rankCounts = {};
                            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                            if (rankCounts[card.rank] >= 3) {
                                this.playerHands[aiIdx].splice(i, 1);
                                this.publishedSequences[p].push(card);
                                const allPublished = this.publishedSequences[p];
                                const tripleCards = [];
                                const ladderCards = [];
                                const processedRanks = new Set();
                                allPublished.forEach(c => {
                                    const count = allPublished.filter(pc => pc.rank === c.rank).length;
                                    if (count >= 3 && !processedRanks.has(c.rank)) {
                                        const sameRank = allPublished.filter(card => card.rank === c.rank);
                                        tripleCards.push(...sameRank);
                                        processedRanks.add(c.rank);
                                    }
                                });
                                allPublished.forEach(c => {
                                    if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                                });
                                tripleCards.sort((a, b) => a.getValue() - b.getValue());
                                ladderCards.sort((a, b) => {
                                    const suitOrder = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
                                    if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                                    return a.getValue() - b.getValue();
                                });
                                this.publishedSequences[p] = [...tripleCards, ...ladderCards];
                                if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                return true;
                            }
                        }
                        if (hasLadders) {
                            const sameSuit = published.filter(c => c.suit === card.suit);
                            if (sameSuit.length >= 4) {
                                const cardVal = card.getValue();
                                const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                                const ladders = []; let remainingValues = [...values];
                                const hasAce = values.includes(1); const hasJack = values.includes(11);
                                const hasQueen = values.includes(12); const hasKing = values.includes(13);
                                if (hasAce && hasJack && hasQueen && hasKing) {
                                    ladders.push([1, 11, 12, 13]);
                                    remainingValues = remainingValues.filter(v => ![1, 11, 12, 13].includes(v));
                                }
                                if (remainingValues.length >= 4) {
                                    let currentLadder = [remainingValues[0]];
                                    for (let i = 1; i < remainingValues.length; i++) {
                                        if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                            currentLadder.push(remainingValues[i]);
                                        } else {
                                            if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                            currentLadder = [remainingValues[i]];
                                        }
                                    }
                                    if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                                }
                                const canExtendLadder = ladders.some(ladder => {
                                    return this.canCardExtendLadder(cardVal, ladder);
                                });
                                if (canExtendLadder) {
                                    this.playerHands[aiIdx].splice(i, 1);
                                    this.publishedSequences[p].push(card);
                                    const allPublished = this.publishedSequences[p];
                                    const rankCounts = {};
                                    allPublished.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                                    const tripleCards = [];
                                    const ladderCards = [];
                                    const processedRanks = new Set();
                                    allPublished.forEach(c => {
                                        if (rankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                                            const sameRank = allPublished.filter(card => card.rank === c.rank);
                                            tripleCards.push(...sameRank);
                                            processedRanks.add(c.rank);
                                        }
                                    });
                                    allPublished.forEach(c => {
                                        if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                                    });
                                    tripleCards.sort((a, b) => a.getValue() - b.getValue());
                                    ladderCards.sort((a, b) => {
                                        const suitOrder = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
                                        if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                                        return a.getValue() - b.getValue();
                                    });
                                    this.publishedSequences[p] = [...tripleCards, ...ladderCards];
                                    if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            endHand(winner) {
                const winnerName = winner === 0 ? 'You' : winner === 1 ? 'Habot' : 'Jabot';
                showWinToast(winnerName);
                for (let i = 0; i < this.players; i++) {
                    if (i === winner) continue;
                    let score = 0;
                    this.playerHands[i].forEach(c => score += c.getPenaltyValue());
                    this.playerScores[i] += score;
                }
                setTimeout(() => { this.showModal('Hand Complete', `${winnerName} won Hand ${this.currentHand}!`) }, 2000);
                setTimeout(() => {
                    this.currentHand++;
                    if (this.currentHand > 7) this.showFinalResults();
                    else {
                        this.playerBuys = this.currentHand === 7 ? [2, 2, 2] : [3, 3, 3];
                        this.publishedSequences = [[], [], []]; this.playerHands = [[], [], []]; this.selectedCards = [];
                        this.gamePhase = 'draw'; this.currentPlayer = 0; this.justPublished = false; this.aiJustPublished = [false, false, false];
                        this.lastDiscard = null; this.lastDiscardByPlayer = -1; this.discardPile = [];
                        this.turnCounter = 0; this.lastAIDiscard = [null, null, null]; this.lastCardWarningShown = null;
                        this.initDeck(); this.deal(); this.updateUI();
                    }
                }, 4000);
            }

            showFinalResults() {
                const results = this.playerScores.map((s, i) => ({ name: i === 0 ? 'You' : i === 1 ? 'Habot' : 'Jabot', score: s })).sort((a, b) => a.score - b.score);
                const winner = results[0];
                const loser = results[results.length - 1];
                persistentScores = [...this.playerScores];
                const msg = `Game Complete!\n\n🏆 ${winner.name} wins with ${winner.score} points!\n🎃 ${loser.name} is the Habib Punja with ${loser.score} points!`;
                this.showModal('Final Results', msg);
                setTimeout(() => { game = new GameState(true) }, 5000);
            }

            showModal(title, msg) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.innerHTML = `<div style="background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;">
                        <h2 style="color:#ffd700;margin-bottom:15px;">${title}</h2>
                        <p style="color:white;margin-bottom:20px;white-space:pre-line;">${msg}</p>
                        <button onclick="this.closest('div').parentElement.remove();" style="padding:12px 30px;background:#28a745;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">OK</button>
                    </div>`;
                document.body.appendChild(modal);
            }

            showDisambiguationModal(card, playerIdx, cardIdx) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.innerHTML = `
                <div style="background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;max-width:500px;">
                    <h2 style="color:#ffd700;margin-bottom:15px;">🎯 Choose Sequence</h2>
                    <p style="color:white;margin-bottom:20px;">
                        ${card.toString()} can extend BOTH your triple and your ladder.<br><br>
                        Which sequence do you want to add it to?
                    </p>
                    <div style="display:flex;gap:15px;justify-content:center;">
                        <button id="chooseTriple" style="padding:12px 24px;background:#e74c3c;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                            Add to Triple
                        </button>
                        <button id="chooseLadder" style="padding:12px 24px;background:#3498db;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                            Add to Ladder
                        </button>
                    </div>
                    <button id="cancelChoice" style="margin-top:15px;padding:8px 20px;background:#6b7280;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">
                        Cancel
                    </button>
                </div>
                    `;
                document.body.appendChild(modal);
                document.getElementById('chooseTriple').onclick = () => {
                    console.log(`%c✅ FIX 6: User chose TRIPLE for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'triple');
                };
                document.getElementById('chooseLadder').onclick = () => {
                    console.log(`%c✅ FIX 6: User chose LADDER for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'ladder');
                };
                document.getElementById('cancelChoice').onclick = () => {
                    console.log(`%c❌ FIX 6: User cancelled`, 'color:#94a3b8');
                    modal.remove();
                };
            }

            executeAddToPublished(card, playerIdx, cardIdx, forceType) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const published = this.publishedSequences[playerIdx];

                if (forceType === 'triple' && hasTriples) {
                    console.log(`%c  ✅ FIX 6: Adding ${card.toString()} to TRIPLE`, 'color:#28a745;font-weight:bold');
                    this.playerHands[0].splice(cardIdx, 1);
                    this.publishedSequences[playerIdx].push(card);
                    const allPublished = this.publishedSequences[playerIdx];
                    const tripleCards = [];
                    const ladderCards = [];
                    const processedRanks = new Set();
                    allPublished.forEach(c => {
                        const count = allPublished.filter(pc => pc.rank === c.rank).length;
                        if (count >= 3 && !processedRanks.has(c.rank)) {
                            const sameRank = allPublished.filter(card => card.rank === c.rank);
                            tripleCards.push(...sameRank);
                            processedRanks.add(c.rank);
                        }
                    });
                    allPublished.forEach(c => {
                        if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                    });
                    tripleCards.sort((a, b) => a.getValue() - b.getValue());
                    ladderCards.sort((a, b) => {
                        const suitOrder = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
                        if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                        return a.getValue() - b.getValue();
                    });
                    this.publishedSequences[playerIdx] = [...tripleCards, ...ladderCards];
                } else if (forceType === 'ladder' && hasLadders) {
                    console.log(`%c  ✅ FIX 6: Adding ${card.toString()} to LADDER`, 'color:#28a745;font-weight:bold');
                    this.playerHands[0].splice(cardIdx, 1);
                    this.publishedSequences[playerIdx].push(card);
                    const allPublished = this.publishedSequences[playerIdx];
                    const rankCounts = {};
                    allPublished.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                    const tripleCards = [];
                    const ladderCards = [];
                    const processedRanks = new Set();
                    allPublished.forEach(c => {
                        if (rankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                            const sameRank = allPublished.filter(card => card.rank === c.rank);
                            tripleCards.push(...sameRank);
                            processedRanks.add(c.rank);
                        }
                    });
                    allPublished.forEach(c => {
                        if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                    });
                    tripleCards.sort((a, b) => a.getValue() - b.getValue());
                    ladderCards.sort((a, b) => {
                        const suitOrder = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
                        if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                        return a.getValue() - b.getValue();
                    });
                    this.publishedSequences[playerIdx] = [...tripleCards, ...ladderCards];
                }

                this.selectedCards = [];
                if (this.playerHands[0].length === 0) { this.endHand(0); return }
                this.updateUI();
            }


            // ============================================
            // VERIFICATION COMMANDS (for cross-version testing)
            // ============================================

            jumpToHand(handNum) {
                if (handNum < 1 || handNum > 7) {
                    console.log('⚠️ Hand must be 1-7');
                    return;
                }
                console.log(`🔧 Jumping to Hand ${handNum}...`);
                this.currentHand = handNum;
                this.playerBuys = handNum === 7 ? [2, 2, 2] : [3, 3, 3];
                this.publishedSequences = [[], [], []];
                this.playerHands = [[], [], []];
                this.selectedCards = [];
                this.gamePhase = 'draw';
                this.currentPlayer = 0;
                this.justPublished = false;
                this.aiJustPublished = [false, false, false];
                this.lastDiscard = null;
                this.lastDiscardByPlayer = -1;
                this.discardPile = [];
                this.turnCounter = 0;
                this.lastAIDiscard = [null, null, null];
                this.lastCardWarningShown = null;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                this.initDeck();
                this.deal();
                this.updateUI();
                console.log(`✅ Hand ${handNum} started`);
            }

            resetScores() {
                console.log('🔧 Resetting all scores to 0...');
                persistentScores = [0, 0, 0];
                this.playerScores = [0, 0, 0];
                this.updateUI();
                console.log('✅ Scores reset');
            }

            showState() {
                console.log('📊 GAME STATE:');
                console.log(`  Hand: ${this.currentHand}/7`);
                console.log(`  Phase: ${this.gamePhase}`);
                console.log(`  Current Player: ${this.currentPlayer} (${['You', 'Habot', 'Jabot'][this.currentPlayer]})`);
                console.log(`  Scores: [${this.playerScores.join(', ')}]`);
                console.log(`  Buys: [${this.playerBuys.join(', ')}]`);
                console.log(`  Cards in hand: [${this.playerHands.map(h => h.length).join(', ')}]`);
                console.log(`  Published sequences: [${this.publishedSequences.map(p => p.length).join(', ')}]`);
                console.log(`  Deck: ${this.deck.length} cards`);
                console.log(`  Discard: ${this.discardPile.length} cards`);
            }

            verifySync() {
                const state = {
                    hand: this.currentHand,
                    phase: this.gamePhase,
                    player: this.currentPlayer,
                    scores: this.playerScores,
                    buys: this.playerBuys,
                    handSizes: this.playerHands.map(h => h.length),
                    published: this.publishedSequences.map(p => p.length),
                    deckSize: this.deck.length,
                    discardSize: this.discardPile.length
                };
                console.log('🔍 SYNC CHECK:', JSON.stringify(state, null, 2));
                return state;
            }

            updateUI() {
                const req = this.handReqs[this.currentHand];
                document.getElementById('currentHand').textContent = this.currentHand;
                document.getElementById('handRequirements').textContent = req.name;
                const progress = this.getPublishProgress();
                let progressParts = [];
                if (progress.needTriples > 0) progressParts.push(`${progress.hasTriples}/${progress.needTriples} triples`);
                if (progress.needLadders > 0) progressParts.push(`${progress.hasLadders}/${progress.needLadders} ladders`);
                const progressText = `${req.name} - You have: ${progressParts.join(', ')}`;
                document.getElementById('detailedRequirements').textContent = progressText;
                const reqEl = document.getElementById('detailedRequirements');
                reqEl.style.color = progress.canPublish ? '#28a745' : '#ffed4e';
                if (progress.canPublish) reqEl.classList.add('ready');
                else reqEl.classList.remove('ready');
                const turnText = this.currentPlayer === 0 ? 'Your Turn' : this.currentPlayer === 1 ? "Habot's Turn" : "Jabot's Turn";
                document.getElementById('turnIndicator').innerHTML = `${turnText} <span style="opacity:0.7;font-size:0.9em;">(Turn ${this.turnCounter})</span>`;
                document.getElementById('playerBuys').textContent = this.playerBuys[0];
                document.getElementById('player2Buys').textContent = this.playerBuys[1];
                document.getElementById('player3Buys').textContent = this.playerBuys[2];
                this.updateLeaderboard();
                const selInfo = document.getElementById('selectionInfo');
                const selCount = document.getElementById('selectedCount');
                if (this.selectedCards.length > 0) { selInfo.style.display = 'inline-block'; selCount.textContent = this.selectedCards.length }
                else selInfo.style.display = 'none';
                const playerHasPublished = this.publishedSequences[0].length > 0;
                const addSection = document.getElementById('addToPublishedSection');
                if (playerHasPublished && this.currentPlayer === 0 && this.gamePhase === 'discard' && this.selectedCards.length === 1 && !this.justPublished && this.playerHands[0].length > 1) addSection.style.display = 'block';
                else addSection.style.display = 'none';
                this.renderHand(); this.renderAIHands(); this.renderPublished();
                if (this.discardPile.length > 0) document.getElementById('topDiscard').textContent = this.discardPile[this.discardPile.length - 1].toString();
                document.getElementById('discardBtn').disabled = this.currentPlayer !== 0 || this.gamePhase !== 'discard' || this.selectedCards.length !== 1;
                document.getElementById('publishBtn').disabled = this.currentPlayer !== 0 || this.gamePhase !== 'discard' || !this.canPublish(0);

                document.getElementById('buyBtn').disabled = !this.buyWindow.active || this.buyWindow.buyWindowPlayer !== 0 || this.playerBuys[0] <= 0;

                [0, 1, 2].forEach(p => {
                    if (this.playerHands[p].length === 1) {
                        const playerName = p === 0 ? 'You' : p === 1 ? 'Habot' : 'Jabot';
                        if (!this.lastCardWarningShown || this.lastCardWarningShown !== p) {
                            showLastCardToast(playerName);
                            this.lastCardWarningShown = p;
                        }
                    }
                });
            }

            updateLeaderboard() {
                const container = document.getElementById('leaderboardEntries');
                if (!container) return;
                const names = ['You', 'Habot', 'Jabot'];
                const sorted = this.playerScores.map((score, idx) => ({ score, idx, name: names[idx] })).sort((a, b) => a.score - b.score);
                container.innerHTML = '';
                sorted.forEach((player, rank) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';
                    if (rank === 0) entry.classList.add('first');
                    if (rank === sorted.length - 1) entry.classList.add('last');
                    entry.innerHTML = `<div class="leaderboard-name">${rank === 0 ? '🏆 ' : ''}${player.name}${rank === sorted.length - 1 ? ' 🎃' : ''}</div><div class="leaderboard-score">${player.score} pts</div>`;
                    container.appendChild(entry);
                });
            }

            renderHand() {
                const container = document.getElementById('playerCards');
                container.innerHTML = '';
                this.playerHands[0].forEach((card, i) => {
                    const el = document.createElement('div');
                    el.className = `card ${card.getColor()}`;
                    if (card.suit === '♥') el.classList.add('heart');
                    if (card.suit === '♦') el.classList.add('diamond');
                    if (this.selectedCards.includes(i)) el.classList.add('selected');
                    el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                    el.draggable = true;
                    el.dataset.index = i;
                    el.onclick = () => {
                        const idx = this.selectedCards.indexOf(i);
                        if (idx > -1) this.selectedCards.splice(idx, 1);
                        else this.selectedCards = [i];
                        this.updateUI();
                    };
                    el.addEventListener('dragstart', (e) => { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', i); el.classList.add('dragging') });
                    el.addEventListener('dragend', (e) => { el.classList.remove('dragging'); document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-over')) });
                    el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move' });
                    el.addEventListener('dragenter', (e) => { e.preventDefault(); if (el !== document.querySelector('.dragging')) el.classList.add('drag-over') });
                    el.addEventListener('dragleave', (e) => { el.classList.remove('drag-over') });
                    el.addEventListener('drop', (e) => {
                        e.preventDefault();
                        el.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = parseInt(el.dataset.index);
                        if (fromIdx !== toIdx) this.moveCard(fromIdx, toIdx);
                    });
                    container.appendChild(el);
                });
            }

            moveCard(fromIdx, toIdx) {
                const card = this.playerHands[0].splice(fromIdx, 1)[0];
                this.playerHands[0].splice(toIdx, 0, card);
                this.selectedCards = this.selectedCards.map(idx => {
                    if (idx === fromIdx) return toIdx;
                    if (fromIdx < toIdx) { if (idx > fromIdx && idx <= toIdx) return idx - 1 }
                    else { if (idx >= toIdx && idx < fromIdx) return idx + 1 }
                    return idx;
                });
                this.updateUI();
            }

            renderAIHands() {
                [1, 2].forEach(p => {
                    const container = document.getElementById(`player${p + 1}Cards`);
                    container.innerHTML = '';
                    const handSize = this.playerHands[p].length;
                    if (handSize > 6) {
                        container.innerHTML = `<div style="font-size: 2.2rem; font-weight: 900; color: var(--gold); text-align: center; padding: 25px; text-shadow: 0 2px 8px rgba(0,0,0,0.5);">${handSize} Cards</div>`;
                        return;
                    }
                    for (let i = 0; i < handSize; i++) {
                        const el = document.createElement('div');
                        el.className = 'card';
                        el.style.background = '#2c3e50';
                        el.style.cursor = 'default';
                        el.innerHTML = `<div style="font-size: 28px; color: rgba(255,255,255,0.4);">?</div>`;
                        container.appendChild(el);
                    }
                });
            }

            renderPublished() {
                [0, 1, 2].forEach(p => {
                    const containerId = p === 0 ? 'player1Cards' : `player${p + 1}CardsPublished`;
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    const uniqueCards = [];
                    const seenIds = new Set();
                    this.publishedSequences[p].forEach(card => { if (!seenIds.has(card.id)) { uniqueCards.push(card); seenIds.add(card.id) } });
                    uniqueCards.forEach(card => {
                        const el = document.createElement('div');
                        el.className = `card ${card.getColor()}`;
                        if (card.suit === '♥') el.classList.add('heart');
                        if (card.suit === '♦') el.classList.add('diamond');
                        el.style.transform = 'scale(0.7)';
                        el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                        container.appendChild(el);
                    });
                });
            }
        }

        function showPublishSelector(seqs, req) {
            const selector = document.getElementById('publishSelector');
            const options = document.getElementById('publishOptions');
            options.innerHTML = '';

            game.publishSelection = { triples: [], ladders: [] };

            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            // ✅ FIX 5C: Map card IDs to consistent numbers ACROSS ALL SEQUENCES
            const duplicateCards = {};
            const cardIdToNumber = new Map();
            let nextNumber = 1;

            // First pass: Identify all duplicate rank+suit combinations
            game.playerHands[0].forEach(card => {
                const key = card.rank + card.suit;
                if (!duplicateCards[key]) duplicateCards[key] = [];
                duplicateCards[key].push(card);
            });

            // Assign consistent numbers to each UNIQUE CARD ID (only for duplicates)
            Object.entries(duplicateCards).forEach(([key, cards]) => {
                if (cards.length > 1) {
                    cards.forEach(card => {
                        cardIdToNumber.set(card.id, nextNumber++);
                    });
                }
            });

            console.log('%c✅ FIX 5C: Card ID mapping:', 'color:#4a90e2;font-weight:bold');
            cardIdToNumber.forEach((num, id) => {
                const card = game.playerHands[0].find(c => c.id === id);
                if (card) console.log(`  ${card.toString()} (id:${id.substr(0, 4)}) → Badge #${num}`);
            });

            if (triplesNeeded > 0) {
                const tripleDiv = document.createElement('div');
                tripleDiv.className = 'publish-option';
                tripleDiv.innerHTML = `<h4>Select ${triplesNeeded} Triple(s):</h4><div class="option-cards" id="tripleOptions"></div>`;
                options.appendChild(tripleDiv);

                const tripleContainer = document.getElementById('tripleOptions');

                seqs.triples.forEach((triple, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;position:relative;';
                    optDiv.onclick = () => toggleTripleSelection(idx, optDiv);

                    triple.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === '♥') cardEl.classList.add('heart');
                        if (card.suit === '♦') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // ✅ FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                        <div class="card-rank">${card.rank}</div>
                        <div class="card-suit">${card.suit}</div>
                        ${duplicateLabel}
                    `;
                        optDiv.appendChild(cardEl);
                    });

                    tripleContainer.appendChild(optDiv);
                });
            }

            if (laddersNeeded > 0) {
                const ladderDiv = document.createElement('div');
                ladderDiv.className = 'publish-option';
                ladderDiv.innerHTML = `<h4>Select ${laddersNeeded} Ladder(s):</h4><div class="option-cards" id="ladderOptions"></div>`;
                options.appendChild(ladderDiv);

                const ladderContainer = document.getElementById('ladderOptions');

                seqs.ladders.forEach((ladder, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;';
                    optDiv.onclick = () => toggleLadderSelection(idx, optDiv);

                    ladder.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === '♥') cardEl.classList.add('heart');
                        if (card.suit === '♦') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // ✅ FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                        <div class="card-rank">${card.rank}</div>
                        <div class="card-suit">${card.suit}</div>
                        ${duplicateLabel}
                    `;
                        optDiv.appendChild(cardEl);
                    });

                    ladderContainer.appendChild(optDiv);
                });
            }

            selector.classList.add('active');
        }

        function toggleTripleSelection(idx, element) {
            const selected = game.publishSelection.triples;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function toggleLadderSelection(idx, element) {
            const selected = game.publishSelection.ladders;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function confirmManualPublish() {
            const req = game.handReqs[game.currentHand].seqs;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            if (game.publishSelection.triples.length !== triplesNeeded ||
                game.publishSelection.ladders.length !== laddersNeeded) {
                game.showModal('Invalid Selection', `You must select exactly ${triplesNeeded} triple(s) and ${laddersNeeded} ladder(s)`);
                return;
            }

            const seqs = game.findSequences(game.playerHands[0]);
            let published = [];
            game.publishSelection.triples.forEach(idx => { published = published.concat(seqs.triples[idx]) });
            game.publishSelection.ladders.forEach(idx => { published = published.concat(seqs.ladders[idx]) });

            // ========== START FIX 5: REPLACE FROM HERE ==========

            // ✅ FIX 5: Check for duplicate card IDs (same physical card used twice)
            const usedCardIds = new Set();
            let hasDuplicateCard = false;
            let duplicateCard = null;

            for (let card of published) {
                if (usedCardIds.has(card.id)) {
                    hasDuplicateCard = true;
                    duplicateCard = card;
                    break;
                }
                usedCardIds.add(card.id);
            }

            if (hasDuplicateCard) {
                console.log('%c🚨 FIX 5: Duplicate card detected!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${duplicateCard.toString()} appears in multiple sequences`);
                game.showModal('Duplicate Card',
                    `You selected ${duplicateCard.toString()} in multiple sequences!\n\n` +
                    `Each card can only be used once.\n` +
                    `Please reselect your sequences.`);
                return;
            }

            // ✅ FIX 5: Also check rank+suit counts (belt-and-suspenders validation)
            const selectedCards = {};
            published.forEach(c => {
                const key = c.rank + c.suit;
                selectedCards[key] = (selectedCards[key] || 0) + 1;
            });

            const handCards = {};
            game.playerHands[0].forEach(c => {
                const key = c.rank + c.suit;
                handCards[key] = (handCards[key] || 0) + 1;
            });

            let hasOverlap = false;
            let overlapCard = '';
            for (let key in selectedCards) {
                if (selectedCards[key] > handCards[key]) {
                    hasOverlap = true;
                    overlapCard = key;
                    break;
                }
            }

            if (hasOverlap) {
                console.log('%c🚨 FIX 5: Card count overlap!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${overlapCard} - selected more than available`);
                game.showModal('Insufficient Cards',
                    `You selected more ${overlapCard} cards than you have!\n\n` +
                    `Please reselect your sequences.`);
                return;
            }

            console.log('%c✅ FIX 5: Validation passed - no duplicates', 'color:#28a745;font-weight:bold');

            // ========== END FIX 5: REPLACE TO HERE ==========

            // ✅ KEEP EVERYTHING BELOW (Execution section - unchanged)
            published.forEach(c => { const idx = game.playerHands[0].findIndex(card => card.id === c.id); if (idx > -1) game.playerHands[0].splice(idx, 1) });
            game.publishedSequences[0] = published;
            game.justPublished = true;
            cancelManualPublish();
            if (game.playerHands[0].length === 0) { game.endHand(0); return }
            game.updateUI();
        }

        function cancelManualPublish() { document.getElementById('publishSelector').classList.remove('active'); game.publishSelection = null }

        function addToPublished(playerIdx) {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            if (game.justPublished) { game.showModal('Cannot Add', 'Cannot add in same turn you published!'); return }
            if (game.publishedSequences[playerIdx].length === 0) {
                game.showModal('Cannot Add', `${playerIdx === 0 ? 'You have' : (playerIdx === 1 ? 'Habot has' : 'Jabot has')} not published yet!`);
                return;
            }

            const cardIdx = game.selectedCards[0];
            const card = game.playerHands[0][cardIdx];
            const req = game.handReqs[game.currentHand].seqs;
            const hasTriples = req.some(s => s === 'triple');
            const hasLadders = req.some(s => s === 'ladder');
            const published = game.publishedSequences[playerIdx];

            // ✅ FIX 6: Check if card could extend BOTH triple AND ladder (AMBIGUOUS!)
            const rankCounts = {};
            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });

            const canExtendTriple = hasTriples && rankCounts[card.rank] >= 3;

            let canExtendLadder = false;
            if (hasLadders) {
                // ✅ FIX 6A: First separate triples from ladders to avoid confusion
                const allRankCounts = {};
                published.forEach(c => { allRankCounts[c.rank] = (allRankCounts[c.rank] || 0) + 1 });

                const tripleCards = [];
                const ladderCards = [];
                const processedRanks = new Set();

                published.forEach(c => {
                    if (allRankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                        const sameRank = published.filter(card => card.rank === c.rank);
                        tripleCards.push(...sameRank);
                        processedRanks.add(c.rank);
                    }
                });

                published.forEach(c => {
                    if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                });

                console.log(`%c🔍 FIX 6A: Separated - Triples: ${tripleCards.map(c => c.toString()).join(' ')}, Ladders: ${ladderCards.map(c => c.toString()).join(' ')}`, 'color:#4a90e2');

                // Now check if card can extend ONLY the ladder cards (not triples)
                const sameSuit = ladderCards.filter(c => c.suit === card.suit);
                if (sameSuit.length >= 4) {

                    const cardVal = card.getValue();
                    const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                    const ladders = [];
                    let remainingValues = [...values];
                    const hasAce = values.includes(1);
                    const hasJack = values.includes(11);
                    const hasQueen = values.includes(12);
                    const hasKing = values.includes(13);
                    if (hasAce && hasJack && hasQueen && hasKing) {
                        ladders.push([1, 11, 12, 13]);
                        remainingValues = remainingValues.filter(v => ![1, 11, 12, 13].includes(v));
                    }
                    if (remainingValues.length >= 4) {
                        let currentLadder = [remainingValues[0]];
                        for (let i = 1; i < remainingValues.length; i++) {
                            if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                currentLadder.push(remainingValues[i]);
                            } else {
                                if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                currentLadder = [remainingValues[i]];
                            }
                        }
                        if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                    }
                    canExtendLadder = ladders.some(ladder => {
                        return game.canCardExtendLadder(cardVal, ladder);
                    });
                }
            }

            // ✅ FIX 6: AMBIGUOUS - card could go to EITHER sequence!
            if (canExtendTriple && canExtendLadder) {
                console.log(`%c🚨 FIX 6: AMBIGUOUS - ${card.toString()} could extend BOTH triple and ladder!`, 'color:#ff6b35;font-weight:bold');
                game.showDisambiguationModal(card, playerIdx, cardIdx);
                return;
            }

            // ✅ FIX 6: If NOT ambiguous, proceed with normal logic
            if (!canExtendTriple && !canExtendLadder) {
                let errorMsg = 'This card does not extend any sequence!\n\n';
                if (hasTriples && !hasLadders) errorMsg += 'This hand only allows TRIPLES.';
                else if (hasLadders && !hasTriples) errorMsg += 'This hand only allows LADDERS.';
                else errorMsg += 'For triples: Need 3+ same rank.\nFor ladders: Need 3+ consecutive same suit.';
                game.showModal('Invalid Card', errorMsg);
                return;
            }

            // Only one option available - use executeAddToPublished
            const forceType = canExtendTriple ? 'triple' : 'ladder';
            game.executeAddToPublished(card, playerIdx, cardIdx, forceType);
        }

        window.onload = () => newGame();

        // ============================================
        // 🎨 FIX 7B: Custom Confirmation Modal
        // ============================================
        function showConfirmModal(title, message, confirmText = 'Confirm', cancelText = 'Cancel') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                // Set content
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                confirmBtn.textContent = confirmText;
                cancelBtn.textContent = cancelText;

                // Show modal
                modal.classList.add('active');

                // Handle confirm
                const handleConfirm = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                // Handle cancel
                const handleCancel = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);

                // Close on overlay click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on ESC key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        async function newGame() {
            // ✅ FIX 7B: Custom confirmation modal (no "This page says"!)
            if (game && game.gamePhase !== 'end') {
                const confirmed = await showConfirmModal(
                    'Start New Game?',
                    'This will end the current game and reset all scores.\n\nAre you sure you want to continue?',
                    'Start New Game',
                    'Continue Playing'
                );

                if (!confirmed) {
                    return; // User cancelled
                }
            }
            persistentScores = [0, 0, 0];
            game = new GameState(false);
        }

        function drawFromDeck() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;
            if (game.buyWindow.active) game.closeBuyWindow('player-turn');
            if (game.deck.length === 0) { if (!game.reshuffleDeck()) { alert('Deck is empty!'); return } game.updateUI() }
            if (game.deck.length > 0) {
                const drawnCard = game.deck.pop();
                game.playerHands[0].push(drawnCard);
                game.gamePhase = 'discard';
                game.turnCounter++;
                game.updateUI();
            }
        }

        function drawFromDiscard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;
            if (game.discardPile.length === 0) return;
            const card = game.discardPile.pop();
            game.playerHands[0].push(card);
            if (game.buyWindow.active) game.closeBuyWindow('player-took');
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            game.gamePhase = 'discard';
            game.turnCounter++;
            game.updateUI();
        }

        function discardCard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            const card = game.playerHands[0].splice(game.selectedCards[0], 1)[0];
            game.discardPile.push(card);
            game.selectedCards = [];
            game.lastDiscard = card;
            game.lastDiscardByPlayer = 0;
            game.justPublished = false;
            if (game.playerHands[0].length === 0) { game.updateUI(); setTimeout(() => { game.endHand(0) }, 500); return }
            game.currentPlayer = 1;
            game.gamePhase = 'draw';
            game.updateUI();
            if (game.currentPlayer !== 0) game.aiTurn();
        }

        function publishSequences() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard') return;
            if (!game.canPublish(0)) { game.showModal('Cannot Publish', 'You do not have the required sequences!'); return }
            const seqs = game.findSequences(game.playerHands[0]);
            const req = game.handReqs[game.currentHand].seqs;
            let needsManualSelection = false;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;
            if (seqs.triples.length > triplesNeeded || seqs.ladders.length > laddersNeeded) needsManualSelection = true;
            const rankCounts = {};
            game.playerHands[0].forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
            Object.values(rankCounts).forEach(count => { if (count >= 4) needsManualSelection = true });
            if (needsManualSelection) showPublishSelector(seqs, req);
            else {
                game.autoPublish(0);
                game.justPublished = true;
                if (game.playerHands[0].length === 0) { game.endHand(0); return }
                game.updateUI();
            }
        }

        function buyCard() {
            if (!game || game.playerBuys[0] <= 0) return;
            if (!game.buyWindow.active || !game.buyWindow.card) return;
            if (game.buyWindow.buyWindowPlayer !== 0) return;
            const card = game.buyWindow.card;
            const idx = game.discardPile.findIndex(c => c.id === card.id);
            if (idx === -1) { game.closeBuyWindow('taken'); showToast('Card no longer available', 'warning', 2000); return }
            game.discardPile.splice(idx, 1);
            game.playerHands[0].push(card);
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            if (game.deck.length === 0) { game.reshuffleDeck(); game.updateUI() }
            if (game.deck.length > 0) {
                const penalty = game.deck.pop();
                game.playerHands[0].push(penalty);
            }
            game.playerBuys[0]--;
            showToast(`You bought ${card.toString()}!`, 'buy', 2500);
            game.updateUI();
            game.closeBuyWindow('bought');
        }

        function sortByRank() {
            if (!game) return;
            game.playerHands[0].sort((a, b) => {
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortBySuit() {
            if (!game) return;
            const order = { '♠': 1, '♥': 2, '♦': 3, '♣': 4 };
            game.playerHands[0].sort((a, b) => {
                if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                return a.getValue() - b.getValue();
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortByQuantity() {
            if (!game) return;
            const counts = {};
            game.playerHands[0].forEach(card => { counts[card.rank] = (counts[card.rank] || 0) + 1 });
            game.playerHands[0].sort((a, b) => {
                const countDiff = counts[b.rank] - counts[a.rank];
                if (countDiff !== 0) return countDiff;
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function showToast(message, type = 'info', duration = 2500) {
            const container = document.querySelector('.toast-container') || createToastContainer();
            const toast = document.createElement('div');
            let bgColor, textColor, icon;
            switch (type) {
                case 'buy': bgColor = 'linear-gradient(135deg, #ffc107, #ff9800)'; textColor = '#000'; icon = '💰'; break;
                case 'warning': bgColor = 'linear-gradient(135deg, #ff6b35, #f7931e)'; textColor = '#fff'; icon = '⚠️'; break;
                case 'win': bgColor = 'linear-gradient(135deg, #ffd700, #ffed4e)'; textColor = '#000'; icon = '🏆'; duration = 3000; break;
                default: bgColor = 'linear-gradient(135deg, #4ade80, #22c55e)'; textColor = '#000'; icon = 'ℹ️';
            }
            toast.style.cssText = `background: ${bgColor}; color: ${textColor}; padding: 16px 24px; border-radius: 12px; font-weight: 900; font-size: 1.1rem; box-shadow: 0 8px 24px rgba(0,0,0,0.4); animation: slideIn 0.3s ease; pointer-events: auto; ${type === 'win' ? 'animation: slideIn 0.3s ease, victoryPulse 0.5s ease 0.3s 3;' : ''}`;
            toast.innerHTML = `${icon} ${message}`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => { toast.remove(); if (container.children.length === 0) container.remove() }, 300);
            }, duration);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }

        function showBuyToast(aiName, card) { showToast(`${aiName} BOUGHT ${card.toString()}!`, 'buy') }

        function showAITookCardToast(aiName, card) {
            console.log(`%c🚨 FIX 2: Showing AI took card toast`, 'color: #ff6b35; font-weight: bold;');
            showToast(`${aiName} took ${card.toString()} - Buy cancelled`, 'warning', 3000);
        }

        function showLastCardToast(playerName) {
            const verb = playerName === 'You' ? 'have' : 'has';
            showToast(`${playerName} ${verb} only 1 card left!`, 'warning', 2000);
        }

        function showWinToast(playerName) {
            const verb = (playerName === 'You') ? 'Win' : 'Wins';
            showToast(`${playerName} ${verb}!`, 'win');
        }
    </script>
</body>
</html>