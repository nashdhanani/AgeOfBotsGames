<!DOCTYPE html>
<html lang="en">
<!--
  Habib Punja - Strategic AI Card Game
  Version: 4.5.12 - CRITICAL FIX: Duplicate Card Object Replacement
  Release Date: December 10, 2025
  Developer: AgeOfBotsGames LLC
  Website: https://ageofbotsgames.com
  Copyright Â© 2025 AgeOfBotsGames LLC. All rights reserved.

  ğŸ® VERSION 4.5.12 - CRITICAL FIX: Object Reference & Duplicate Card Validation
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› CRITICAL FIX #1: Duplicate card object reference bug (GAME-BREAKING)
  ğŸ› CRITICAL FIX #2: Published ladders not auto-sorting after extension
  
  **BUG #1: JavaScript Object Reference Causing Validation Failure**
  Problem: After de-duplication, same card OBJECT was in multiple patterns
  - User had: Aâ™¦ (id:efep) and Aâ™¦ (id:xlos) - TWO different physical cards
  - De-duplication created: Pattern 1 and Pattern 2 both using Aâ™¦_object (same memory reference)
  - Smart assignment modified: card.id = "efep", then card.id = "xlos" (overwrote same object!)
  - Result: Both positions pointed to same object with id="xlos"
  - Validation correctly detected: "Same card used twice!" âŒ
  
  **ROOT CAUSE:**
  Three interconnected issues:
  1. findSequences() only kept ONE card per rank (uniqueByRank logic)
  2. De-duplication kept FIRST occurrence â†’ same object in multiple patterns
  3. Smart assignment modified object.id â†’ overwrote same object multiple times
  
  **THE COMPLETE FIX (v4.5.12):**
  
  findSequences() created BOTH ladders using the SAME Ace instance!
  Validation correctly detected: "Same card used twice!"
  
  **THE COMPLETE FIX (Line 2457-2600):**
  
  **Part 1: Generate ALL combinations (Line 2457-2564)**
  ```javascript
  // v4.5.12: Generate ALL ladder combinations with duplicate ranks
  
  // 1. J-Q-K-A: Create ladder for EACH Ace instance
  const allAces = g.filter(c => c.rank === 'A');
  if (allAces.length > 0 && hasK && hasQ && hasJ) {
      allAces.forEach(ace => {
          seqs.ladders.push([hasJ, hasQ, hasK, ace]);
      });
  }
  
  // 2. Consecutive ladders: Generate ALL combinations
  const byRank = {};  // Group by rank (keeps all instances)
  g.forEach(card => {
      if (!byRank[card.rank]) byRank[card.rank] = [];
      byRank[card.rank].push(card);  // âœ… Keeps ALL instances!
  });
  
  // Recursive generation: If ranks [A,2,3,4] and 2 Aces exist,
  // creates [A1,2,3,4] AND [A2,2,3,4]
  const generateCombinations = (rankIndex, currentCombo) => {
      if (rankIndex === ranks.length) {
          seqs.ladders.push([...currentCombo]);
          return;
      }
      // Try each instance of current rank
      byRank[ranks[rankIndex]].forEach(cardInstance => {
          currentCombo.push(cardInstance);
          generateCombinations(rankIndex + 1, currentCombo);
          currentCombo.pop();
      });
  };
  ```
  
  **Part 2: De-duplicate for user display (Line 2567-2596)**
  ```javascript
  // v4.5.12: Remove duplicate PATTERNS (not instances!)
  // User doesn't care which physical card ID goes where
  // They just want to see each unique pattern once
  
  deduplicateLadderPatterns(ladders) {
      const uniquePatterns = new Map();
      
      ladders.forEach(ladder => {
          // Pattern key: "Aâ™¦|2â™¦|3â™¦|4â™¦" (sorted)
          const patternKey = ladder
              .map(c => c.rank + c.suit)
              .sort()
              .join('|');
          
          // Keep first occurrence only
          if (!uniquePatterns.has(patternKey)) {
              uniquePatterns.set(patternKey, ladder);
          }
      });
      
      return Array.from(uniquePatterns.values());
  }
  
  // In findSequences(), before return:
  seqs.ladders = this.deduplicateLadderPatterns(seqs.ladders);
  ```
  
  **Part 3: Replace duplicate objects at publish time (Line 6461-6510) â­ v4.5.12 KEY FIX**
  ```javascript
  // v4.5.12 CRITICAL: Track processed OBJECTS (not just IDs!)
  // De-duplication leaves same card object in multiple patterns
  // We must REPLACE objects, not just modify IDs
  
  const processedObjects = new Set();  // Track object references!
  
  published.forEach((card, index) => {
      if (processedObjects.has(card)) {
          // Same object appearing again! âš ï¸
          // REPLACE entire object with different instance
          const newCard = hand.find(c => 
              c.rank === card.rank && 
              c.suit === card.suit && 
              !usedIds.has(c.id)
          );
          
          published[index] = newCard;  // â† REPLACE, don't modify!
          usedIds.add(newCard.id);
          processedObjects.add(newCard);
      } else {
          // First time seeing this object
          processedObjects.add(card);
          usedIds.add(card.id);
      }
  });
  ```
  
  **Why object replacement was necessary:**
  ```
  After de-duplication:
    Pattern 1: [Aâ™¦_obj, 2â™¦, 3â™¦, 4â™¦]  â† Aâ™¦_obj at memory 0x1234
    Pattern 2: [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦_obj]  â† Same Aâ™¦_obj at memory 0x1234
  
  published array:
    [0] = Aâ™¦_obj (0x1234)
    [7] = Aâ™¦_obj (0x1234)  â† Same object reference!
  
  OLD (v4.5.11 - modifying ID):
    published[0].id = "efep"  â†’ Modifies object at 0x1234
    published[7].id = "xlos"  â†’ Overwrites same object!
    Result: Both have id="xlos" âŒ
  
  NEW (v4.5.12 - replacing object):
    published[0] = Aâ™¦_obj1 (id:efep)  â†’ Object A
    published[7] = Aâ™¦_obj2 (id:xlos)  â†’ Object B (different!)
    Result: Two different objects! âœ…
  ```
  
  **Why this works:**
  1. âœ… ALL combinations exist internally (any ID assignment works)
  2. âœ… User sees each pattern ONCE (no confusing duplicates)
  3. âœ… Object replacement ensures different instances in array
  4. âœ… Existing validation prevents actual ID reuse
  5. âœ… Clean, robust solution to JavaScript reference semantics
  
  **Example with TWO Aâ™¦ cards:**
  ```
  Internal generation:
    [Aâ™¦(jke0), 2â™¦, 3â™¦, 4â™¦]  â† Instance 1
    [Aâ™¦(qvef), 2â™¦, 3â™¦, 4â™¦]  â† Instance 2 (duplicate pattern!)
    [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(jke0)]  â† Instance 3
    [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(qvef)]  â† Instance 4 (duplicate pattern!)
  
  After de-duplication (shown to user):
    [Aâ™¦(jke0), 2â™¦, 3â™¦, 4â™¦]  â† Pattern shown once (kept first)
    [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(jke0)]  â† Pattern shown once (kept first)
    
    Problem: Both use Aâ™¦(jke0)! âŒ
  
  When user selects both patterns:
    Smart assignment runs:
    1. First pattern: Find unused Aâ™¦ â†’ Aâ™¦(jke0) âœ…
    2. Second pattern: Find unused Aâ™¦ â†’ Aâ™¦(qvef) âœ… (jke0 already used!)
    
    Result after smart assignment:
      [Aâ™¦(jke0), 2â™¦, 3â™¦, 4â™¦]
      [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(qvef)]  â† Different Ace assigned! âœ…
  
  Validation: 
    âœ… PASS (different physical card IDs used)
  ```
  
  Now with TWO Aâ™¦ cards, findSequences() creates:
  - [Aâ™¦(id:jke0), 2â™¦, 3â™¦, 4â™¦]  
  - [Aâ™¦(id:qvef), 2â™¦, 3â™¦, 4â™¦]  â† Different Ace!
  - [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(id:jke0)]
  - [Jâ™¦, Qâ™¦, Kâ™¦, Aâ™¦(id:qvef)]  â† Different Ace!
  
  User can select sequences using DIFFERENT Ace instances!
  
  **BUG #2: Published Ladders Not Sorted After Extension**
  Problem: When extending published ladder, cards appeared unsorted
  - Published: 4â™ -5â™ -6â™ -7â™ 
  - Extend with 3â™ : Shows as 4â™ -5â™ -6â™ -7â™ -3â™  (UNSORTED!)
  - Player can't quickly see: "Lowest is 3â™ , highest is 7â™ "
  - Must mentally re-sort to find extension opportunities
  
  **THE FIX (Line 5607-5615):**
  ```javascript
  seq.push(card);
  
  // v4.5.12: Auto-sort ladder after extension
  if (forceType === 'ladder') {
      seq.sort((a, b) => a.getValue() - b.getValue());
      console.log('ğŸ”„ v4.5.12: Re-sorted ladder:', seq.map(c => c.toString()).join('-'));
  }
  ```
  
  Now: 4â™ -5â™ -6â™ -7â™  + 3â™  = 3â™ -4â™ -5â™ -6â™ -7â™  (SORTED!)
  
  **Impact:**
  - Fix #1: CRITICAL - Blocking valid plays in 2-deck games
  - Fix #2: HIGH UX - Makes strategic decisions much faster
  
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ğŸ® VERSION 4.5.12 - UX FIX: Game Completion Auto-Restart Removed
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Game no longer auto-restarts after completion
  âœ¨ New: "Play Again" and "View Game" buttons on final results
  âœ¨ New: Player has full control over when to start next game
  
  **BUG: Game Auto-Restarts After Completion**
  Problem: After game ended, new game started automatically after 5 seconds
  - User completed full game (You: 28 pts, Habot: 600 pts - Habib Punja)
  - Modal showed "Final Results"
  - After 5 seconds: New game started automatically
  - Result: "All hell broke loose" - unexpected behavior, no player control!
  
  **ROOT CAUSE (Line 5372-5396):**
  ```javascript
  this.showModal('Final Results', msg);
  
  setTimeout(async () => {
      // Automatically start new game after 5 seconds âŒ
      game = new GameState(true);
      // ... game initialization ...
  }, 5000);
  ```
  
  Game auto-restarted without asking the player if they wanted to play again!
  
  **THE FIX:**
  Created new showFinalResultsModal() with two buttons:
  1. **ğŸ® Play Again** - Starts new game immediately (player choice)
  2. **ğŸ‘€ View Game** - Closes modal, lets player review final state
  
  ```javascript
  showFinalResultsModal(msg, winner, loser) {
      // Create modal with two buttons
      const playAgainBtn = ... // Starts new game when clicked
      const viewGameBtn = ... // Closes modal, keeps game visible
  }
  ```
  
  **New Behavior:**
  1. Game completes, final results shown
  2. Modal appears with winner/loser
  3. Player chooses:
     - Click "Play Again" â†’ New game starts
     - Click "View Game" â†’ Stay at completed game
  4. No automatic actions!
  
  **Benefits:**
  - âœ… Player has full control
  - âœ… Can review completed game
  - âœ… Can choose when/if to start new game
  - âœ… No unexpected behavior
  - âœ… Professional UX pattern
  
  ğŸ® VERSION 4.5.9 - CRITICAL FIX: Buy Window Rotation Bug
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Buy window now rotates to all players with buys remaining
  ğŸ› Fixed: Human gets buy opportunity even when AIs have zero buys
  ğŸ› Fixed: PATCH I now rotates instead of blocking window entirely
  
  **BUG: Buy Window Killed When AI Has No Buys**
  Problem: Human still had 2 buys left, but buy window never appeared
  - Scenario: Hand 3, Turn 117, Jabot published
  - Habot: 0 buys left, Jabot: 0 buys left, Human: 2 buys left
  - Expected: Human should get buy window opportunity
  - Actual: Buy window closed entirely, blocking human's chance!
  
  **ROOT CAUSE (Line 4272-4276):**
  ```javascript
  if (this.playerBuys[aiPlayer] <= 0) {
      this.closeBuyWindow('no-buys');  // âŒ Killed window!
      return;
  }
  ```
  
  When first AI in rotation had no buys, it closed the window entirely,
  preventing it from rotating to the next player (human) who DID have buys!
  
  **THE FIX:**
  Instead of closing buy window when AI has no buys, ROTATE to next player:
  ```javascript
  if (this.playerBuys[aiPlayer] <= 0) {
      const nextBuyPlayer = (aiPlayer + 2) % 3;
      if (nextBuyPlayer has buys && isn't discarding player) {
          this.buyWindow.buyWindowPlayer = nextBuyPlayer;
          // Continue buy window with next player!
      }
  }
  ```
  
  **Buy Window Rotation Order:**
  - Player 0 discards â†’ Player 2 gets first chance
  - If Player 2 can't/won't buy â†’ Player 1 gets second chance  
  - If Player 1 can't/won't buy â†’ Window closes
  
  **Example from User's Bug:**
  1. Habot (P1) discards
  2. Human (P0) gets first buy chance â†’ (P1 + 2) % 3 = 0 âœ“
  3. Human has 0 buys left â†’ Rotate to Jabot (P2)
  4. Jabot has 0 buys left â†’ Rotate would go back to Habot
  5. Habot is discarding player â†’ Close window âœ“
  
  WAIT - Let me recalculate the user's scenario:
  - Turn 117, Hand 3 (Two Ladders)
  - Habot: 0 buys, Jabot: 0 buys (published), Human: 2 buys
  
  If Jabot (P2) just discarded:
  1. Next buy window player: (2 + 2) % 3 = 1 (Habot)
  2. Habot has 0 buys â†’ OLD CODE: Close window âŒ
  3. NEW CODE: Rotate to (1 + 2) % 3 = 0 (Human) âœ“
  4. Human has 2 buys â†’ Show buy window! âœ“
  
  If Habot (P1) just discarded:
  1. Next buy window player: (1 + 2) % 3 = 0 (Human)
  2. Human has 2 buys â†’ Show buy window directly! âœ“
  
  **Additional Fix: PATCH I Rotation**
  PATCH I also had same bug - when AI published in triple-only hand,
  it closed window instead of rotating to next player who might want to buy.
  
  ğŸ® VERSION 4.5.8 - Bug Fixes from Previous Version
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Duplicate 10â™£ in ladder - canAddToPublishedSequence checks rank+suit
  ğŸ› Fixed: AIs not publishing in Hand 2 - Suit focus enabled for ALL ladder hands
  âœ… Hands 2, 3, 5, 6, 7 now use suit focus for faster ladder building
  
  **BUG #1: Extension Card Loss**
  Problem: tryAddToPublished() was losing cards during extensions
  - Console logged: "Extended sequence (1 card played)" âœ…
  - Card removed from hand: âœ…
  - Card saved to publishedSequences: âŒ MISSING!
  - Result: Cards disappeared into the void!
  
  **Example from Testing:**
  - Habot: 14 total cards â†’ 6 published + 4 in hand = 10 accounted
  - Missing: 4 cards that were "extended" but not saved
  - Jabot: Same issue - 4 cards missing
  - Total: 8 cards lost during extensions!
  
  **ROOT CAUSE:**
  Lines 4994-5020 (old code):
  1. Remove card from hand âœ…
  2. Rebuild all cards: `const allPublished = [...published, card]`
  3. Separate into triples/ladders
  4. Call `separateSequences(combinedFlat, req)` â† BUG HERE!
  5. separateSequences() might DROP cards that don't form valid sequences
  6. Result: Card removed from hand but not in publishedSequences
  
  **THE FIX:**
  Instead of re-separating everything (which can lose cards):
  - Find the SPECIFIC sequence the card extends
  - Add card DIRECTLY to that sequence: `this.publishedSequences[p][seqIdx].push(card)`
  - No re-separation, no card loss!
  
  **Code Changes:**
  - Triple extension (lines 4988-5011): Direct sequence push
  - Ladder extension (lines 5054-5085): Direct sequence push
  - Added logging: "Extended [Player]'s sequence X with [card]"
  
  **BUG #2: PATCH I Blocking Valid Extensions**
  Problem: PATCH I blocked taking discard even when it extends sequences
  - Scenario: Hand 1 (triple-only), Habot published, Qâ™¥ on discard
  - Qâ™¥ extends published Queen sequence
  - PATCH I blocked: "Triple-only hand, AI already published"
  - Habot drew from deck instead â†’ Terrible strategy!
  
  **ROOT CAUSE (Line 4512):**
  ```javascript
  if (shouldTake && this.publishedSequences[ai].length > 0) {
      // Blocked ALL taking in triple-only after publishing
  }
  ```
  PATCH I didn't check if card extends sequences!
  
  **THE FIX:**
  ```javascript
  if (shouldTake && this.publishedSequences[ai].length > 0 && !extendsAnySequence) {
      // Only block if card DOESN'T extend
  }
  ```
  Now AIs take discard when it extends, improving endgame strategy!
  
  **Testing Verification:**
  After fix, card accounting should be perfect:
  - Initial: 10 cards
  - 2 buys: +4 cards (2 Ã— +2)
  - Total pool: 14 cards
  - All 14 cards accounted in: published + hand + discarded
  - AIs take extending cards from discard in triple-only hands âœ…
  
  ğŸ® VERSION 4.5.7 - UI FIX: Sequence Separator Visualization
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Published sequences now display with visual separators
  ğŸ› Fixed: renderPublished() no longer flattens all sequences together
  âœ¨ New: Golden vertical bar separators between sequences
  
  **THE BUG:**
  Problem: All published sequences displayed as one long row
  - Habot publishes: [5â™¦ 5â™£ 5â™ ] and [Kâ™¥ Kâ™£ Kâ™¦]
  - UI showed: 5â™¦ 5â™£ 5â™  Kâ™¥ Kâ™£ Kâ™¦ (no separation!)
  - User couldn't tell where one sequence ended and another began
  - Extensions added to sequences were invisible
  
  **THE FIX:**
  - Modified renderPublished() to loop through sequences individually
  - Added 3px golden vertical separator bars between sequences
  - Now displays as: [5â™¦ 5â™£ 5â™ ] | [Kâ™¥ Kâ™£ Kâ™¦] | [Kâ™ ]
  - Extensions now clearly visible on correct sequences
  
  **VISUAL CHANGES:**
  - Separator: 3px wide, 80px tall, semi-transparent gold (#FFD700 @ 30%)
  - 10px margin on each side
  - Makes sequence boundaries crystal clear
  
  ğŸ® VERSION 4.5.6 - NEW FEATURE: Hand Selection Menu
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âœ¨ New: Click "New Game" to choose which hand to play
  âœ¨ New: Options for Full Game (all 7 hands) or individual hands 1-7
  âœ¨ New: Beautiful modal with radio button selection
  âœ¨ New: Hands 6-7 auto-initialize staged construction when selected
  
  **NEW USER FLOW:**
  1. Click "New Game" button
  2. Modal appears with game mode selection:
     - ğŸ´ Full Game (All 7 Hands)
     - Hand 1: Two Triples
     - Hand 2: Triple + Ladder
     - Hand 3: Two Ladders
     - Hand 4: Three Triples
     - Hand 5: 2 Triples + Ladder
     - Hand 6: Triple + 2 Ladders
     - Hand 7: Three Ladders
  3. Select desired mode and click "Start Game"
  4. Game starts at selected hand with proper initialization
  
  **TECHNICAL IMPLEMENTATION:**
  - New `showHandSelectionModal()` function
  - Modified `newGame()` to show selection first
  - Updated `GameState` constructor to accept `selectedHand` parameter
  - Auto-initializes staged construction for Hands 6-7:
    * Sets `aiConstructionStage` to 'building_L1'
    * Generates initial suit focus
    * Generates target cards for AIs
    * Sets stage start turn tracking
  
  **BENEFITS:**
  - Players can practice specific hands
  - Testing specific scenarios easier
  - Faster iteration for debugging
  - Better user experience for learning
  
  ğŸ® VERSION 4.5.5 - CRITICAL HOTFIX: Overlapping Sequence Lock Prevention
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: AI no longer creates overlapping locked sequences
  ğŸ› Fixed: HOLD completion check prevents double-locking same cards
  ğŸŒ³ Added: Decision tree debug logging for future troubleshooting
  
  **BUG - Overlapping Locked Sequences:**
  Problem: When HOLD system completed, AI would:
  1. Lock sequence from HOLD (e.g., 7â™ ,8â™ ,9â™ ,10â™ )
  2. ALSO detect same cards as direct ladder (e.g., 6â™ ,7â™ ,8â™ ,9â™ )
  3. Lock BOTH â†’ overlapping cards â†’ publishing failed
  
  Example from Hand 7 Turn 50:
  - HOLD: 8â™ ,9â™ ,10â™  targeting 7â™ 
  - Gets 7â™  â†’ Should lock ONLY 7â™ ,8â™ ,9â™ ,10â™ 
  - BUG: Also locked 6â™ ,7â™ ,8â™ ,9â™  (overlap!)
  - Result: 2 sequences share 7â™ ,8â™ ,9â™ 
  - Publishing logic confused â†’ only 2/3 sequences published
  
  **ROOT CAUSE:**
  Two code paths executing in same turn:
  - PATH A (Line 4283): checkHeldSequences() â†’ locks from HOLD âœ…
  - PATH B (Line 4286): Direct ladder detection â†’ locks again âŒ
  
  **FIX 1 - checkHeldSequences Returns Flag:**
  - Now returns true if ANY hold completed
  - Checks for overlaps BEFORE locking
  - Skips lock if cards already in locked sequence
  
  **FIX 2 - Decision Tree Early Exit:**
  - If hold completed â†’ skip all direct ladder checks
  - Prevents double-locking entirely
  - Only one lock path executes per turn
  
  **FIX 3 - Decision Tree Debug Logging:**
  - ğŸŒ³ Visual tree structure shows execution path
  - NODE 1: HOLD check (with completion flag)
  - NODE 2: Direct ladder check (only if NODE 1 = false)
  - Makes debugging future issues much easier
  
  **Testing Checklist:**
  âœ… game.jumpToHand(7) â†’ No overlapping sequences
  âœ… HOLD completion â†’ skips direct ladder check
  âœ… Console shows decision tree path clearly
  âœ… AI publishes all 3 sequences correctly
  
  ğŸ® VERSION 4.5.3 - PATCH M Checks Global Published Sequences!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Staged construction now initializes in jumpToHand()
  ğŸ› Fixed: User extension choice now respected (triple vs ladder)
  
  **BUG 1 - Stage Stuck at 'initial':**
  Problem: When using game.jumpToHand(6), staged construction never initialized
  - Stage stayed at 'initial' instead of 'building_L1'
  - Buying logic failed because it checks for 'building_L1' stage
  - Result: AI never bought anything (Turn 37, zero buys)
  
  Fix: Added initialization to jumpToHand() function
  - Now runs whenever jumping to Hand 6 or 7
  - Stage correctly set to 'building_L1'
  - Targets and suit focus generated immediately
  
  **BUG 2 - Extension Added to Wrong Sequence:**
  Problem: User chose LADDER but card added to TRIPLE instead
  - executeAddToPublished() ignored forceType parameter
  - Checked ALL sequences, added to first match (triple)
  - Console: "User chose LADDER" but "Added to sequence: 7â™  7â™£ 7â™¦ 7â™¦"
  
  Fix: Respect forceType when selecting sequence
  - If forceType='ladder', ONLY check ladder sequences
  - If forceType='triple', ONLY check triple sequences
  - Correctly adds 7â™¦ to diamond ladder: 7â™¦ 8â™¦ 9â™¦...
  
  **Testing Checklist:**
  âœ… game.jumpToHand(6) â†’ Stage should be 'building_L1'
  âœ… AI should generate targets immediately
  âœ… AI should buy when target cards appear
  âœ… Extension choice respected (ladder vs triple)
  
  ğŸ® VERSION 4.4.0 - REVOLUTIONARY: Staged Construction Strategy!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ—ï¸ PARADIGM SHIFT: Sequential building instead of parallel accumulation
  
  **THE BREAKTHROUGH:**
  Games 6-7 require different strategy than Games 1-5!
  - Old: Try to form all sequences simultaneously â†’ scattered progress â†’ never publish
  - New: Build L1 â†’ LOCK â†’ Build L2 â†’ LOCK â†’ Build T â†’ PUBLISH âœ…
  
  **NEW SYSTEMS IMPLEMENTED:**
  1. âœ… Stage Tracking: AI knows which sequence it's building
     - Stages: building_L1 â†’ building_L2 â†’ building_T â†’ ready_to_publish
  
  2. âœ… Sequence Locking: Completed sequences protected from discard
     - Once ladder complete â†’ marked read-only â†’ cannot be accidentally discarded
  
  3. âœ… Target Card System: AI hunts 2-3 SPECIFIC cards
     - Not "any useful card" â†’ specific targets like "5â™¥, 7â™ , 10â™¦"
  
  4. âœ… Near-Sequential Analysis: Finds promising partial sequences
     - Detects: [4,6,8â™¥] â†’ needs [5,7] â†’ high potential
     - Rejects: [2,7,Kâ™¥] â†’ too many gaps â†’ low potential
  
  5. âœ… Suit Concentration: Focus on 2 best suits for ladders
     - Select suits with highest card count and lowest gaps
  
  6. âœ… Stage-Based Buying: Different logic per construction phase
     - Building L1: Only buy target cards for first ladder
     - Building L2: Only buy target cards for second ladder  
     - Building T: Only buy cards that complete triple
  
  7. âœ… Protected Discard: Never discard locked sequence cards
     - Locked cards immune to all discard logic
  
  8. âœ… Stage Advancement: Auto-progress when sequences complete
     - Detects completion â†’ locks sequence â†’ updates targets â†’ advances stage
  
  **PLAYER-PROVEN STRATEGY:**
  This matches exactly how humans win Hand 6/7:
  - Focus on ONE ladder at a time
  - Lock progress as you go
  - Don't try to build everything simultaneously
  - Triples are easy - save for last!
  
  **EXPECTED RESULTS:**
  - AI should publish within 20-30 turns (not 172+!)
  - AI should WIN Hand 6 and Hand 7 games
  - No more infinite buy loops
  - Clean, focused gameplay
  
  ğŸ® VERSION 4.3.2 - CRITICAL FIX: Wrap-Around Ladder Extension!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Can now extend A-K-Q-J wrap-around ladders with 10
  âœ… canAddToPublishedSequence now uses canCardExtendLadder (handles wrap-around!)
  âŒ Removed: Broken simple rank array logic that didn't understand A-K-Q-J
  ğŸ“Š Result: UI extension validation matches couldExtendSequence logic!
  
  Bug: UI said "Invalid Card" even though couldExtendSequence returned true
  Fix: UI now uses same wrap-around detection as backend logic
  
  ğŸ® VERSION 4.3.1 - CRITICAL FIX: Complete 4+ Card Ladder Check!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: AI now ONLY buys cards that create/extend COMPLETE 4+ card ladders
  âŒ Prevented: Buying scattered fragments (e.g., 4-5-6â™¥ + 9-10â™¥ = 2 incomplete)
  âœ… Required: Card must form sequential run of 4+ cards AFTER adding it
  ğŸ“Š Result: AI accumulates cards that actually complete ladders!
  
  Previous v4.3.0: Checked "adjacent to any suit card" = scattered fragments âŒ
  New v4.3.1: Verifies complete 4+ sequential run after adding card âœ…

  ğŸ® VERSION 4.3.0 - CRITICAL FIX: Ladders First Strategy!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Hand 6 AI now uses SMART STRATEGY: Build 2 ladders FIRST, then triple
  âœ… Ladders are harder (4+ sequential same-suit) â†’ prioritize these
  âœ… Triples are easier (3 matching ranks) â†’ form from leftover cards
  âœ… AI ONLY buys ladder-building cards until 2 ladders complete
  âœ… After 2 ladders: AI can buy triple-completing cards from leftovers
  ğŸ“Š Prevents: Wasting buys on multiple triples while missing ladders
  ğŸ“Š Result: AI forms 1T + 2L efficiently and publishes!
  
  Previous v4.2.9: AI bought triple cards first = wrong order! âŒ
  New v4.3.0: AI builds ladders first (player-proven strategy) âœ…

  ğŸ® VERSION 4.2.9 - CRITICAL FIX: Goal-Oriented Buying for Hands 6-7!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: Hand 6 buying now checks if card HELPS FORM LADDERS (not just "has progress")
  ğŸ› Fixed: Hand 7 buying now ONLY accepts cards that build toward 3 ladders
  âœ… AI now buys cards that complete/extend sequences toward actual requirements
  âœ… Hand 6: Buys cards that complete triples OR extend ladders (2+ same suit + adjacent)
  âœ… Hand 7: ONLY buys cards that extend ladders (3+ ladders needed)
  ğŸ“Š Result: AI accumulates 12-14 cards AND forms valid sequences to publish!
  
  Previous fix (v4.2.8): AI bought 20+ times but cards didn't help âŒ
  New behavior: AI buys strategically toward completion âœ…

  ğŸ® VERSION 4.2.8 - CRITICAL FIX: AI Can Actually Win Hand 6/7 Now!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: AI threshold lowered from 11â†’5 (was rejecting pairs/ladder starts!)
  ğŸ› Fixed: Hand 6 buying - now allows 2 buys (was 1!), threshold 35â†’20
  ğŸ› Fixed: Hand 7 buying - threshold lowered 30â†’20 for 3-ladder requirement
  âœ… AI can accumulate 11-12 cards needed for Hands 6-7
  âœ… Rabbit personality: threshold 3 (very aggressive)
  âœ… Tortoise personality: threshold 7 (reasonable)
  ğŸ“Š Hand 6: AI can now buy 2x to reach 12 cards (11+ needed for 1T+2L)
  ğŸ“Š Hand 7: AI can buy 2x to reach 12 cards (12 needed for 3L)

  ğŸ® VERSION 4.1.6 - BUGFIX: Game freezing after buy window blocks
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ› Fixed: closeBuyWindow now resumes pending AI turns for all block reasons
  âœ… Added 'no-buy-after-publish', 'no-buys', 'ai-no-buyback', 'invalid' to resume list
  âœ… Game no longer freezes when AI blocks buy window
  
  Version 4.1.5 - November 15, 2025
  ğŸ› Fixed: PATCH 3 now sets aiJustPublished flag after emergency publish
  âœ… AI can no longer extend on same turn as publishing
  
  Version 4.0.5 - November 14, 2025
  
  Version 4.0.4 - November 14, 2025
  ğŸ› Fixed: Extension validation now works with 2D sequences
  âœ… Players can now extend published sequences
  
  Version 4.0.3 - November 14, 2025
  ğŸ› Fixed: Human manual publish now stores as 2D sequences
  âœ… Eliminated renderPublished crash
  
  Version 4.0.2 - November 14, 2025
  ğŸ› Fixed: Game advances when buy window skipped (no buys left)
  âœ… Eliminated infinite wait bug
  
  Version 4.0.1 - November 14, 2025
  ğŸ› Fixed: couldExtendSequence now uses getFlatPublished()
  âœ… Eliminated crash when checking card extensions
  
  Base: Version 4.0.0 - 2D Sequences Architecture
  ğŸ—ï¸ BREAKING CHANGE: Sequences stored as 2D arrays (not flat!)
  âœ… Eliminates all sequence separation bugs
  âœ… No more ambiguous card assignment
  âœ… Direct access to individual sequences
  âœ… Simpler, cleaner code
  
  Version 4.0.0 - November 14, 2025
  The "Stop Giving Away Wins" Fix
  The "Can Actually Extend" Fix

  Experience the game like you're sitting at a real card table!
  Compete against Habot (the Rabbit) and Jabot (the Tortoise) across 7 challenging hands!
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>Habib Punja v4.5.12 - Strategic AI Card Game | AgeOfBotsGames</title>
    <meta name="title" content="Habib Punja v4.5.12 - Strategic AI Card Game | AgeOfBotsGames">
    <meta name="description" content="Play Habib Punja, a strategic Liverpool Rummy variant against AI opponents Habot and Jabot. Master triples and ladders across 7 challenging hands!">
    <meta name="keywords" content="Habib Punja, card game, rummy, Liverpool Rummy, AI card game, strategy game, online card game, AgeOfBotsGames">
    <meta name="author" content="AgeOfBotsGames LLC">
    <meta name="version" content="4.5.12">
    <meta name="copyright" content="Copyright Â© 2025 AgeOfBotsGames LLC. All rights reserved.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ageofbotsgames.com/">
    <meta property="og:title" content="Habib Punja - Strategic AI Card Game">
    <meta property="og:description" content="Challenge AI opponents in this strategic Liverpool Rummy variant. Can you outsmart Habot and Jabot?">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ageofbotsgames.com/">
    <meta property="twitter:title" content="Habib Punja - Strategic AI Card Game">
    <meta property="twitter:description" content="Challenge AI opponents in this strategic Liverpool Rummy variant. Can you outsmart Habot and Jabot?">
    <style>
        /* [Previous CSS remains exactly the same - keeping it brief for space] */

        /* --- NEW: Full Portrait Scaling (Risk-Style Fit) --- */

        /* --- NEW: AI Collapse Styles --- */
        .ai-header {
            cursor: pointer;
            padding: 8px 10px;
            background-color: var(--aob-bg-soft);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            user-select: none; /* Prevent text selection on click */
        }

        .ai-indicator {
            font-weight: bold;
            color: var(--aob-gold);
        }

        .collapse-icon {
            transition: transform 0.3s ease;
        }

        /* State: Collapsed (Hides content and rotates icon) */
        .ai-content.collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            padding: 0 10px; /* Remove padding when hidden */
            transition: max-height 0.4s ease-out, opacity 0.4s ease-out;
        }

        /* State: Expanded */
        .ai-content {
            max-height: 500px; /* Large value to accommodate content */
            opacity: 1;
            transition: max-height 0.4s ease-in, opacity 0.4s ease-in;
        }

        /* Icon Rotation */
        .ai-header[data-expanded="true"] .collapse-icon {
            transform: rotate(180deg);
        }

        .ai-header[data-expanded="false"] .collapse-icon {
            transform: rotate(0deg);
        }

        :root {
            --bg-1: #0b1b13;
            --bg-2: #0f2a1c;
            --surface: #132e21;
            --gold: #ffd54a;
            --gold-2: #ffea8a;
            --accent: #4ade80;
            --accent-2: #22c55e;
            --danger: #ef4444;
            --muted: #cbd5e1;
            --ring: 0 0 0 2px rgba(255,213,74,.25),0 10px 30px rgba(0,0,0,.35);
            --radius: 14px;
            --card-w: 64px;
            --card-h: 92px;
            --elev: 0 10px 25px rgba(0,0,0,.35)
        }

        * {
            box-sizing: border-box
        }


        body {
            /* Safe Reset */
            margin: 0;
            padding: 24px; /* RESTORES YOUR DESKTOP PADDING (24px) */
            /* Existing Styles */
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,'Noto Sans',sans-serif;
            background: radial-gradient(1200px 800px at 30% -10%,#154d34 0%,transparent 60%),radial-gradient(1400px 900px at 120% 10%,#0b3d28 0%,transparent 55%),linear-gradient(180deg,var(--bg-1),var(--bg-2));
            color: #fff;
            min-height: 100vh; /* Keep for full-page background */
            /* NEW: Display Flex for better vertical centering/management on desktop */
            display: flex;
            justify-content: center;
            align-items: center;
            /* REMOVED: height: 100vh; and overflow: hidden; */
        }

        .game-container {
            max-width: 1280px;
            margin: 0 auto
        }

        .game-header {
            text-align: center;
            margin-bottom: 18px
        }

            .game-header h1 {
                font-size: clamp(1.6rem,3vw,2.4rem);
                color: var(--gold);
                letter-spacing: .5px;
                text-shadow: 0 1px 0 #000,0 0 24px rgba(255,213,74,.25)
            }

        .game-info {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg,rgba(255,215,0,.10),rgba(255,255,255,.04));
            padding: 16px 18px;
            border-radius: var(--radius);
            border: 1px solid rgba(255,215,0,.25);
            box-shadow: var(--elev)
        }

        .current-hand {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--gold)
        }

        .requirements {
            font-size: .95rem;
            color: var(--gold-2)
        }

            .requirements.ready {
                color: var(--accent)
            }

        .turn-indicator {
            padding: 8px 14px;
            background: linear-gradient(180deg,var(--accent),var(--accent-2));
            border-radius: 999px;
            font-weight: 800;
            color: #052e1a;
            text-shadow: 0 1px 0 rgba(255,255,255,.35);
            box-shadow: var(--ring)
        }

        .leaderboard {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border: 1px solid rgba(255,255,255,.15);
            border-radius: var(--radius);
            padding: 12px 14px;
            margin: 16px 0 20px;
            box-shadow: var(--elev)
        }

            .leaderboard h3 {
                color: var(--gold);
                margin-bottom: 6px;
                text-align: center;
                font-size: 1rem
            }

        .leaderboard-entries {
            display: flex;
            gap: 10px
        }

        .leaderboard-entry {
            flex: 1;
            text-align: center;
            padding: 8px 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.12)
        }

            .leaderboard-entry.first {
                background: linear-gradient(180deg,rgba(255,215,0,.20),rgba(255,215,0,.08));
                border-color: rgba(255,215,0,.65)
            }

            .leaderboard-entry.last {
                background: linear-gradient(180deg,rgba(239,68,68,.22),rgba(239,68,68,.08));
                border-color: rgba(239,68,68,.55)
            }

        .leaderboard-name {
            font-weight: 800;
            font-size: .9rem;
            margin-bottom: 2px
        }

        .leaderboard-score {
            font-size: 1.05rem;
            font-weight: 800;
            color: var(--gold)
        }

        .players-section {
            display: grid;
            grid-template-columns: 1fr minmax(420px,1.2fr) 1fr;
            gap: 16px;
            margin-bottom: 22px
        }

        @media(max-width:980px) {
            .players-section {
                grid-template-columns: 1fr
            }

            .center-area {
                order: 3
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* ğŸ¨ v4.0.7: ROUND TABLE LAYOUT STYLES                           */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .round-table-top {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 24px;
            align-items: start;
        }

        .opponent-area {
            background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
            border-radius: var(--radius);
            padding: 16px;
            border: 1px solid rgba(255,255,255,.15);
            box-shadow: var(--elev);
            transition: box-shadow .2s, border-color .2s;
        }

            .opponent-area.active-turn {
                box-shadow: 0 0 0 2px var(--gold), 0 12px 30px rgba(0,0,0,.45);
            }

        .opponent-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--player-color);
        }

            .opponent-header .player-name {
                font-weight: 900;
                color: var(--player-color);
                font-size: 1.1rem;
                letter-spacing: .3px;
                margin: 0;
                padding: 0;
                border: none;
            }

            .opponent-header .buy-info {
                font-size: .85rem;
                color: var(--muted);
            }

        .card-count-badge {
            font-size: .85rem;
            font-weight: 700;
            color: var(--gold);
            background: rgba(255, 213, 74, .15);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            width: fit-content;
        }

        .opponent-published {
            margin-bottom: 12px;
            min-height: 40px;
        }

            .opponent-published .published-header {
                font-size: .8rem;
                font-weight: 700;
                color: var(--gold-2);
                margin-bottom: 6px;
                text-transform: uppercase;
                letter-spacing: .5px;
            }

            .opponent-published .published-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                min-height: 30px;
            }

        .opponent-cards-visible {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 12px 0;
            min-height: 110px;
        }

        .ai-status-compact {
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(0,0,0,.3);
            border: 1px solid var(--player-color);
            min-height: 40px;
            font-size: .85rem;
            text-align: center;
        }

            .ai-status-compact.active {
                background: linear-gradient(180deg, rgba(255,215,0,.18), rgba(255,215,0,.08));
                border-color: var(--gold);
                box-shadow: var(--ring);
            }

            .ai-status-compact .ai-status-action {
                color: var(--muted);
                font-weight: 600;
            }

        .center-table-area {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 0;
        }

        .deck-area-compact {
            display: flex;
            gap: 12px;
        }

        .player-area-center {
            background: linear-gradient(180deg, rgba(74, 174, 226, .08), rgba(74, 174, 226, .04));
            border-radius: var(--radius);
            padding: 20px;
            border: 2px solid rgba(74, 174, 226, .3);
            box-shadow: var(--elev);
            margin-bottom: 20px;
        }

            .player-area-center.active-turn {
                box-shadow: 0 0 0 3px var(--gold), 0 15px 35px rgba(0,0,0,.5);
                border-color: var(--gold);
            }

        .your-published {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(0,0,0,.25);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.1);
            min-height: 60px;
        }

            .your-published .published-header {
                font-size: .9rem;
                font-weight: 700;
                color: var(--gold);
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: .5px;
            }

            .your-published .published-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
            }

        .player-name-center {
            font-weight: 900;
            font-size: 1.2rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--player-color);
            color: var(--gold);
            letter-spacing: .4px;
            text-align: center;
        }

        @media(max-width:980px) {
            .round-table-top {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .opponent-area {
                max-width: 100%;
            }
        }

        /* END v4.0.7 ROUND TABLE STYLES */

        .player-area {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border-radius: var(--radius);
            padding: 16px;
            min-height: 180px;
            border: 1px solid rgba(255,255,255,.15);
            box-shadow: var(--elev);
            transition: box-shadow .2s,border-color .2s
        }

            .player-area.active-turn {
                box-shadow: 0 0 0 2px var(--gold),0 12px 30px rgba(0,0,0,.45)
            }

        .player-name {
            font-weight: 900;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--player-color);
            color: var(--player-color);
            letter-spacing: .3px
        }

        .ai-status {
            margin-top: 12px;
            padding: 12px;
            border-radius: 10px;
            background: rgba(0,0,0,.35);
            border: 1px solid var(--player-color);
            min-height: 56px;
            font-size: .9rem;
            line-height: 1.5
        }

            .ai-status.active {
                background: linear-gradient(180deg,rgba(255,215,0,.18),rgba(255,215,0,.08));
                border-color: var(--gold);
                box-shadow: var(--ring)
            }

        .ai-status-title {
            font-weight: 800;
            color: var(--player-color);
            margin-bottom: 4px
        }


        /* ============================================
        ğŸ¨ FIX 7B: Custom Confirmation Modal
        ============================================ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

            .modal-overlay.active {
                display: flex;
            }

        .modal-content {
            background: linear-gradient(135deg, var(--surface) 0%, var(--bg-2) 100%);
            border: 2px solid var(--gold);
            border-radius: var(--radius);
            padding: 32px;
            max-width: 450px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), var(--ring);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* ============================================
                ğŸ¨ FIX 7D: Auto-Fade Modal Animations
                ============================================ */
        @keyframes modalFadeOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .modal-overlay.fading-out {
            animation: modalFadeOut 0.5s ease forwards;
        }

        .modal-auto-fade-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--gold));
            width: 100%;
            border-radius: 0 0 var(--radius) var(--radius);
            transform-origin: left;
            animation: fadeProgress 3s linear forwards;
        }

        @keyframes fadeProgress {
            from {
                transform: scaleX(1);
            }

            to {
                transform: scaleX(0);
            }
        }

        .modal-skip-hint {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 600;
            pointer-events: none;
        }

        .modal-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 800;
            color: var(--gold);
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .modal-message {
            font-size: 16px;
            color: var(--muted);
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 700;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

            .modal-btn.cancel {
                background: linear-gradient(180deg, var(--accent), var(--accent-2));
                border-color: var(--accent);
                color: #052e1a;
            }

                .modal-btn.cancel:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
                }

            .modal-btn.confirm {
                background: linear-gradient(180deg, var(--danger), #dc2626);
                border-color: var(--danger);
                color: white;
            }

                .modal-btn.confirm:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
                }

        /* Hand Selection Modal Styles */
        .hand-selection-modal {
            max-width: 550px;
            max-height: 85vh;
            overflow-y: auto;
        }

        .hand-selection-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .hand-option {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

            .hand-option:hover {
                background: rgba(255, 215, 0, 0.1);
                border-color: rgba(255, 215, 0, 0.6);
                transform: translateX(5px);
            }

            .hand-option input[type="radio"] {
                margin-right: 12px;
                width: 20px;
                height: 20px;
                cursor: pointer;
            }

            .hand-option input[type="radio"]:checked + .hand-label {
                color: #ffd700;
            }

        .hand-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

            .hand-label strong {
                font-size: 16px;
                color: #fff;
            }

            .hand-label small {
                font-size: 13px;
                color: rgba(255, 255, 255, 0.7);
            }

        .center-area {
            display: flex;
            flex-direction: column;
            align-items: center
        }

        .deck-area {
            display: flex;
            gap: 18px;
            margin-bottom: 16px
        }

        .deck, .discard-pile {
            width: 92px;
            height: 132px;
            border: 1px solid rgba(255,255,255,.35);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform .18s,box-shadow .18s;
            box-shadow: var(--elev);
            position: relative;
            overflow: hidden
        }

            .deck::after, .discard-pile::after {
                content: '';
                position: absolute;
                inset: 0;
                opacity: .2;
                background: radial-gradient(500px 180px at 20% -10%,#fff,transparent 60%);
                pointer-events: none
            }

        .deck {
            background: linear-gradient(160deg,#2b5fff,#17318f)
        }

        .discard-pile {
            background: linear-gradient(160deg,#ff7b2b,#8f3c17)
        }

            .deck:hover, .discard-pile:hover {
                transform: translateY(-4px) scale(1.03)
            }

        .published-sequences {
            width: 100%;
            min-height: 150px;
            border: 1px dashed rgba(255,215,0,.55);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            background: linear-gradient(180deg,rgba(255,215,0,.12),rgba(255,215,0,.04))
        }

            .published-sequences > div:first-child {
                font-size: 1.05rem;
                font-weight: 900;
                color: var(--gold);
                margin-bottom: 10px;
                letter-spacing: .4px
            }

        .player-published {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px
        }

            .player-published h5 {
                margin-bottom: 8px;
                color: var(--gold);
                font-size: .95rem;
                font-weight: 900
            }

        .published-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            max-width: 100%
        }

            .published-cards .card {
                flex: 0 0 auto;
                transform: scale(0.7)
            }

        .hand-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px
        }

        .players-section .player-area .hand-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            justify-items: center
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 900;
            cursor: move;
            user-select: none;
            position: relative;
            padding: 4px;
            background: linear-gradient(180deg,#fbfbfb,#f0f0f0);
            box-shadow: 0 6px 16px rgba(0,0,0,.25);
            transition: transform .16s ease,box-shadow .16s ease,border-color .16s ease
        }

            .card::before {
                content: '';
                position: absolute;
                inset: 0;
                border-radius: 10px;
                pointer-events: none;
                background: radial-gradient(800px 200px at 20% -10%,rgba(255,255,255,.8),transparent 60%);
                opacity: .35
            }

            .card:hover {
                transform: translateY(-8px) rotate(-.4deg);
                box-shadow: 0 12px 28px rgba(0,0,0,.35)
            }

            .card.dragging {
                opacity: .7;
                transform: rotate(3deg) scale(1.05)
            }

            .card.drag-over {
                border-left: 4px solid var(--accent)
            }

            .card.red {
                color: #db1f2f
            }

            .card.black {
                color: #0f172a
            }

            .card.red.heart {
                color: #e31c23
            }

            .card.red.diamond {
                color: #ff6b35
            }

            .card.selected {
                outline: 3px solid var(--gold);
                outline-offset: 0;
                transform: translateY(-12px) scale(1.02);
                box-shadow: 0 14px 34px rgba(255,213,74,.45)
            }

        .card-rank {
            font-size: 17px;
            line-height: 1;
            margin-bottom: 2px
        }

        .card-suit {
            font-size: 30px;
            line-height: 1
        }

        .btn {
            background: linear-gradient(180deg,#3ddc84,#1fae63);
            color: #052e1a;
            border: none;
            padding: 12px 18px;
            border-radius: 12px;
            cursor: pointer;
            margin: 0 6px 10px;
            font-size: 15px;
            font-weight: 900;
            letter-spacing: .2px;
            transition: transform .12s,box-shadow .12s;
            box-shadow: 0 6px 16px rgba(0,0,0,.25)
        }

            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 22px rgba(0,0,0,.35)
            }

            .btn:disabled {
                background: #6b7280;
                color: #1f2937;
                cursor: not-allowed;
                opacity: .7;
                box-shadow: none
            }

        .buy-info {
            background: rgba(255,193,7,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem
        }

        .selection-info {
            background: rgba(255,215,0,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem;
            font-weight: 900
        }

        .publish-selector {
            display: none;
            background: linear-gradient(135deg,rgba(255,215,0,.22),rgba(255,215,0,.08));
            border: 2px solid var(--gold);
            border-radius: 14px;
            padding: 18px;
            margin: 12px 0
        }

            .publish-selector.active {
                display: block
            }

            .publish-selector h3 {
                color: var(--gold);
                margin-bottom: 12px;
                text-align: center;
                font-size: 1.05rem
            }

        .publish-options {
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .publish-option {
            background: rgba(255,255,255,.05);
            border: 1px solid rgba(255,255,255,.20);
            border-radius: 12px;
            padding: 12px
        }

            .publish-option h4 {
                color: var(--gold-2);
                margin-bottom: 8px;
                font-size: .95rem
            }

        .option-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            justify-content: center
        }

        .publish-controls {
            text-align: center;
            margin-top: 10px
        }

        .add-to-published {
            margin-top: 8px;
            padding: 8px 12px;
            font-size: .85rem;
            background: #0ea5e9;
            color: #062232
        }

            .add-to-published:hover {
                background: #0284c7;
                color: #001824
            }

        .game-controls {
            text-align: center;
            margin-top: 14px
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0
            }

            to {
                transform: translateX(0);
                opacity: 1
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1
            }

            to {
                transform: translateX(400px);
                opacity: 0
            }
        }

        @keyframes victoryPulse {
            0%, 100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.05)
            }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none
        }

        .fix-badge {
            position: fixed;
            top: 80px;
            right: 16px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: #fff;
            font-weight: 900;
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 9998;
            font-size: 0.9rem;
            border: 2px solid rgba(255,255,255,0.3)
        }

        /* Paste the entire contents of your local aob_shared.css here */

   /* ===========================================
   Age of Bots â€“ Shared Micro-Styles
   Version 1.0 â€“ Safe, Non-intrusive
   =========================================== */
        /* Improves text clarity across dark backgrounds */
        body, button, input, textarea {
            font-family: "Inter", "Segoe UI", sans-serif;
            color: #e6e6f8;
        }

        /* Smooth fade utility */
        .aob-fade {
            opacity: 0;
            transition: opacity 0.6s ease;
        }

            .aob-fade.show {
                opacity: 1;
            }

        /* Centering helper for buttons */
        .aob-center {
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        /* Consistent button styling (optional override) */
        .aob-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #7c3aed, #4c1d95);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: 0.2s ease-in-out;
        }

            .aob-btn:hover {
                transform: scale(1.04);
                box-shadow: 0 0 12px rgba(124, 58, 237, 0.45);
            }

        /* Light container for story, fable, or advisor text */
        .aob-box {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 16px;
            padding: 24px;
            backdrop-filter: blur(6px);
        }

        /* Future-proof area for character bubbles */
        .aob-bubble {
            max-width: 320px;
            padding: 14px 18px;
            background: #fff;
            color: #222;
            border-radius: 24px;
            position: relative;
            box-shadow: 2px 8px 28px rgba(0,0,0,0.12);
            font-family: "Comic Neue", "Comic Sans MS", sans-serif;
            display: none; /* will be turned on by JS later */
        }

            /* Left-tail bubble */
            .aob-bubble.left::after {
                content: "";
                position: absolute;
                left: -16px;
                top: 18px;
                border-top: 15px solid transparent;
                border-bottom: 15px solid transparent;
                border-right: 16px solid #fff;
            }

            /* Right-tail bubble */
            .aob-bubble.right::after {
                content: "";
                position: absolute;
                right: -16px;
                top: 18px;
                border-top: 15px solid transparent;
                border-bottom: 15px solid transparent;
                border-left: 16px solid #fff;
            }

            /* Reserve advisor bubble style for Phase 3 */
            .aob-bubble.center {
                margin: 0 auto;
            }

        /* ========================================================================= */
        /* --- NEW: RESPONSIVE LAYOUT BASE (MOBILE / YOUTUBE PLAYABLES) --- */
        /* (Default Styles: Portrait < 800px) */
        /* ========================================================================= */

        /* Mobile-First: Stack all game elements vertically */
        #gameContainer {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Mobile constraint */
            margin: 0 auto;
            padding: 10px;
        }

        /* AI areas are full width, stacked near the top */
        .opponent-area {
            width: 95%;
            margin: 5px auto;
            order: 2; /* Put AI areas near the top */
            /* Ensure only score/info is visible, not card art */
        }

            /* Condense the AI hands to save vertical space on mobile */
            .opponent-area .hand-cards {
                display: none; /* Hide the actual card visuals on mobile */
            }

        /* Central Deck/Discard/Messages Area */
        .central-game-area {
            width: 95%;
            order: 1; /* Place at the top */
        }

        .deck-discard-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        /* Player area goes to the bottom */
        .player-area-center {
            width: 95%;
            order: 4; /* Force player area to the bottom */
            margin-top: 15px;
        }

            /* Player Hand: Aggressive overlap for small screens (Mobile/Playables) */
            .player-area-center .hand-cards {
                /* Use dynamic sizing for cards based on viewport width (vw) */
                --card-mobile-width: 15vw;
                --card-mobile-overlap: 5vw;
                width: 100%;
                overflow-x: scroll; /* Allow horizontal scrolling for large hands */
                white-space: nowrap;
                padding-bottom: 5px;
                /* Apply aggressive overlap using negative margins */
                .card

        {
            width: var(--card-mobile-width);
            margin-right: calc(-1 * var(--card-mobile-overlap));
        }

        }


        /* ========================================================================= */
        /* --- NEW: RESPONSIVE OVERRIDE (TABLET / TESLA LANDSCAPE) --- */
        /* (Activates for screens >= 800px wide, landscape orientation) */
        /* ========================================================================= */

        @media (min-width: 800px) and (orientation: landscape) {

            /* Revert to the original, spread-out layout using CSS Grid */
            #gameContainer {
                display: grid;
                grid-template-areas:
                    "opponent-left central-game-area opponent-right"
                    "player-area-center player-area-center player-area-center";
                grid-template-columns: 1fr 2.5fr 1fr; /* Central board is wider */
                grid-template-rows: auto 1fr; /* AI and center on top row, player on bottom */
                max-width: 1200px; /* Set a max width for large screens */
                padding: 20px;
            }

            /* Assign Grid Areas */
            .opponent-left {
                grid-area: opponent-left;
                order: initial; /* Reset order */
                width: auto;
            }

            .opponent-right {
                grid-area: opponent-right;
                order: initial; /* Reset order */
                width: auto;
            }

            .central-game-area {
                grid-area: central-game-area;
                order: initial; /* Reset order */
            }

            .player-area-center {
                grid-area: player-area-center;
                order: initial; /* Reset order */
                margin-top: 25px; /* Add some separation */
            }

            /* Show AI hands again (assuming they are small card backs) */
            .opponent-area .hand-cards {
                display: flex;
            }

            /* Reset Player Hand for larger screens */
            .player-area-center .hand-cards {
                overflow-x: hidden; /* No scrolling */
                white-space: normal;
                /* Less aggressive card overlap */
                .card

        {
            width: 80px; /* Fixed card width for desktop */
            margin-right: -15px;
        }

        }
        }

        /* --- NEW: Targeted Mobile/Portrait Overrides (iPhone Fix) --- */
        @media only screen and (max-width: 768px) and (orientation: portrait) {
            body {
                /* CRITICAL: Remove all padding for maximum space */
                padding: 0;
                /* Ensure the body itself doesn't scroll */
                overflow-y: hidden;
                overflow-x: hidden;
                /* Force content to top/start for better mobile layout */
                align-items: flex-start;
            }

            /* Target the main game wrapper using your class selector */
            .game-container {
                /* CRITICAL: Force the entire game content to shrink to fit the viewable height */
                max-height: 100vh;
                width: 100vw;
                overflow: hidden; /* Ensure content inside the wrapper doesn't cause overflow */
                /* Use flex to allow the internal components (header, board, hand) to share the space */
                display: flex;
                flex-direction: column;
                justify-content: flex-start; /* Start content from the top */
            }
        }

    </style>
</head>
<body>
    <div class="fix-badge">âœ… v4.5.12</div>
    <div class="game-container">
        <div class="game-header"><h1>Habib Punja v4.5.12</h1></div>
        <div class="game-info">
            <div class="current-hand">Hand <span id="currentHand">1</span>: <span id="handRequirements">Two Triples</span></div>
            <div class="requirements" id="detailedRequirements">Two Triples</div>
            <div class="turn-indicator" id="turnIndicator">Your Turn</div>
        </div>
        <div class="leaderboard"><div class="leaderboard-entries" id="leaderboardEntries"></div></div>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- ğŸ¨ v4.0.7: ROUND TABLE LAYOUT - Top Row (AI Opponents)     -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="round-table-top">


            <!-- Left: Habot (The Rabbit) -->

            <div id="habot-area" class="opponent-area opponent-left" style="--player-color: #e74c3c;">
                <div class="ai-header" onclick="toggleAIArea('habot-area')" data-expanded="false">
                    <div class="player-name">ğŸ‡ Habot</div>
                    <div class="card-count-badge">Cards: <span id="player2Count">10</span></div>
                    <div id="habot-indicator" class="ai-indicator">0 Points</div> <span class="collapse-icon">â–¼</span>
                </div>

                <div class="ai-content collapsed">
                    <div class="buy-info">Buys: <span id="player2Buys">3</span></div>

                    <div class="opponent-published" id="player2Published">
                        <div class="published-header">Published:</div>
                        <div class="published-cards" id="player2CardsPublished"></div>
                    </div>

                    <div class="opponent-cards-visible" id="player2Cards"></div>

                    <div class="ai-status-compact" id="habot-status">
                        <div class="ai-status-action" id="habot-action">Waiting...</div>
                    </div>
                </div>
            </div>


            
            <!-- Center Top: Deck & Discard -->
            <div class="center-table-area">
                <div class="deck-area-compact">
                    <div class="deck" id="drawDeck"><div>Draw<br>Deck</div></div>
                    <div class="discard-pile" id="discardPile"><div id="topDiscard">Discard<br>Pile</div></div>
                </div>
            </div>
            
            <!-- Right: Jabot (The Tortoise) -->

            <div id="jabot-area" class="opponent-area opponent-right" style="--player-color: #3498db;">
                <div class="ai-header" onclick="toggleAIArea('jabot-area')" data-expanded="false">
                    <div class="player-name">ğŸ¢ Jabot</div>
                    <div class="card-count-badge">Cards: <span id="player3Count">10</span></div>
                    <div id="jabot-indicator" class="ai-indicator">0 Points</div> <span class="collapse-icon">â–¼</span>
                </div>

                <div class="ai-content collapsed">
                    <div class="buy-info">Buys: <span id="player3Buys">3</span></div>

                    <div class="opponent-published" id="player3Published">
                        <div class="published-header">Published:</div>
                        <div class="published-cards" id="player3CardsPublished"></div>
                    </div>

                    <div class="opponent-cards-visible" id="player3Cards"></div>

                    <div class="ai-status-compact" id="jabot-status">
                        <div class="ai-status-action" id="jabot-action">Waiting...</div>
                    </div>
                </div>
            </div>


        </div>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- ğŸ¨ v4.0.7: ROUND TABLE LAYOUT - Bottom (Your Area)         -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <div class="player-area-center" style="--player-color: #4a90e2;">
            <!-- Your Published Sequences (above your hand) -->
            <div class="your-published" id="player1Published">
                <div class="published-header">Your Published Sequences:</div>
                <div class="published-cards" id="player1Cards"></div>
            </div>
            
            <!-- Your Hand -->
            <div class="player-name-center">
                Your Hand 
                <span class="buy-info">Buys: <span id="playerBuys">3</span></span>
                <span id="selectionInfo" class="selection-info" style="display:none;">Selected: <span id="selectedCount">0</span></span>
            </div>
            <div class="hand-cards" id="playerCards"></div>
            
            <!-- Publish Selector -->
            <div class="publish-selector" id="publishSelector">
                <h3>Choose Cards to Publish</h3>
                <div class="publish-options" id="publishOptions"></div>
                <div class="publish-controls">
                    <button class="btn" id="confirmManualPublish">Publish Selected</button>
                    <button class="btn" id="cancelManualPublish">Cancel</button>
                </div>
            </div>
            
            <!-- Add to Published Section -->
            <div id="addToPublishedSection" style="display:none; margin-top:15px;">
                <strong style="color:#ffd700;">Add Selected Card To:</strong>
                <button class="btn add-to-published" data-player="0">Your Sequences</button>
                <button class="btn add-to-published" data-player="1">Habot's Sequences</button>
                <button class="btn add-to-published" data-player="2">Jabot's Sequences</button>
            </div>
        </div>
        
        <!-- Game Controls (unchanged) -->
        <div class="game-controls">
            <button class="btn" id="publishBtn" disabled>Publish Sequences</button>
            <button class="btn" id="sortByRankBtn">Sort by Rank</button>
            <button class="btn" id="sortBySuitBtn">Sort by Suit</button>
            <button class="btn" id="discardBtn" disabled>Discard Selected</button>
            <button class="btn" id="buyBtn" disabled>Buy from Discard <span id="buyTimer" style="display:none;"></span></button>
            <button class="btn" id="sortByQuantityBtn">Sort by Quantity</button>
            <button class="btn" id="newGameBtn">New Game</button>
        </div>
    </div>

    <!-- ============================================
     ğŸ¨ FIX 7B: Custom Confirmation Modal
     ============================================ -->
    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-icon">âš ï¸</div>
            <div class="modal-title" id="modalTitle">Confirm Action</div>
            <div class="modal-message" id="modalMessage">Are you sure?</div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="modalCancel">Continue Playing</button>
                <button class="modal-btn confirm" id="modalConfirm">Start New Game</button>
            </div>
        </div>
    </div>

    <!-- Hand Selection Modal -->
    <div id="handSelectionModal" class="modal-overlay">
        <div class="modal-content hand-selection-modal">
            <div class="modal-icon">ğŸ®</div>
            <div class="modal-title">Choose Game Mode</div>
            <div class="modal-message">Select which game to play:</div>
            <div class="hand-selection-options">
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="full" checked>
                    <span class="hand-label">
                        <strong>ğŸ´ Full Game</strong>
                        <small>All 7 Hands</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="1">
                    <span class="hand-label">
                        <strong>Hand 1</strong>
                        <small>Two Triples</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="2">
                    <span class="hand-label">
                        <strong>Hand 2</strong>
                        <small>Triple + Ladder</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="3">
                    <span class="hand-label">
                        <strong>Hand 3</strong>
                        <small>Two Ladders</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="4">
                    <span class="hand-label">
                        <strong>Hand 4</strong>
                        <small>Three Triples</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="5">
                    <span class="hand-label">
                        <strong>Hand 5</strong>
                        <small>2 Triples + Ladder</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="6">
                    <span class="hand-label">
                        <strong>Hand 6</strong>
                        <small>Triple + 2 Ladders</small>
                    </span>
                </label>
                <label class="hand-option">
                    <input type="radio" name="handSelection" value="7">
                    <span class="hand-label">
                        <strong>Hand 7</strong>
                        <small>Three Ladders</small>
                    </span>
                </label>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="handSelectionCancel">Cancel</button>
                <button class="modal-btn confirm" id="handSelectionConfirm">Start Game</button>
            </div>
        </div>
    </div>


    <script>
        // ============================================================================
        // ğŸ® HABIB PUNJA v3.0 - THE CLEAN ARCHITECTURE EDITION
        // ============================================================================
        // Add this at the very top of your <script> section, before game code
        window.addEventListener('error', function (e) {
            // Ignore browser extension errors
            if (e.message && e.message.includes('runtime.lastError')) {
                e.preventDefault();
                console.log('âš ï¸ Browser extension error caught and ignored');
                return false;
            }
        });

        // ============================================================================
        // DEBUG MODE SYSTEM
        // ============================================================================
        // Enable debug mode by adding ?debug=true to the URL
        const urlParams = new URLSearchParams(window.location.search);
        const DEBUG_MODE = urlParams.get('debug') === 'true';
        
        // Enhanced console logging that respects debug mode
        const debugLog = {
            info: (...args) => { if (DEBUG_MODE) console.log(...args); },
            warn: (...args) => { if (DEBUG_MODE) console.warn(...args); },
            error: (...args) => console.error(...args), // Always show errors
            ai: (playerName, ...args) => { 
                if (DEBUG_MODE) console.log(`%cğŸ¤– ${playerName}:`, 'color: #9c27b0; font-weight: bold;', ...args); 
            },
            decision: (title, ...args) => {
                if (DEBUG_MODE) console.log(`%câš¡ ${title}`, 'color: #ff9800; font-weight: bold;', ...args);
            }
        };

        if (DEBUG_MODE) {
            console.log('%cğŸ› DEBUG MODE ENABLED', 'color: #f44336; font-size: 16px; font-weight: bold; background: #fff; padding: 4px 8px;');
            console.log('%cVerbose AI logging active. Remove ?debug=true from URL to disable.', 'color: #666; font-size: 12px;');
            console.log(' ');
        }

        // ============================================================================
        // GAME METADATA & BRANDING
        // ============================================================================
        console.log('%cğŸ® HABIB PUNJA v4.5.12 - STAGED CONSTRUCTION', 'color: #9b59b6; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.3)');
        console.log('%cğŸŒ PATCH M Checks Global Published Sequences!', 'color: #ff9800; font-size: 14px; font-weight: bold;');
        console.log('%cÂ© 2025 AgeOfBotsGames LLC', 'color: #666; font-size: 12px;');
        console.log('%cWebsite: https://ageofbotsgames.com', 'color: #2196F3; font-size: 12px;');
        console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #999;');
        console.log('%câš ï¸ Game code is protected by copyright.', 'color: #FF9800; font-weight: bold;');
        console.log('%câš ï¸ Unauthorized copying or distribution is prohibited.', 'color: #FF9800; font-weight: bold;');
        console.log('%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'color: #999;');
        console.log(' ');

        // Update version badge if debug mode is active
        if (DEBUG_MODE) {
            setTimeout(() => {
                const badge = document.querySelector('.fix-badge');
                if (badge) {
                    badge.innerHTML = 'ğŸ› v4.5.12 DEBUG';
                    badge.style.background = 'linear-gradient(135deg, #f44336, #e91e63)';
                }
            }, 100);
        }

        // Game state
        let deck = [];
        let players = [];

        class Card {
            constructor(rank, suit) { this.rank = rank; this.suit = suit; this.id = Math.random().toString(36).substr(2, 9) }
            toString() { return `${this.rank}${this.suit}` }
            getValue() { if (this.rank === 'A') return 1; if (this.rank === 'J') return 11; if (this.rank === 'Q') return 12; if (this.rank === 'K') return 13; return parseInt(this.rank) }
            getColor() { return (this.suit === 'â™¥' || this.suit === 'â™¦') ? 'red' : 'black' }
            getPenaltyValue() { if (this.rank === 'A') return 20; if (['K', 'Q', 'J'].includes(this.rank)) return 15; return this.getValue() }
        }

        let game = null;
        let persistentScores = [0, 0, 0];

        class GameState {
            constructor(carryOverScores = false, selectedHand = 'full') {
                // ğŸ® v4.5.12: Hand selection support
                this.gameMode = selectedHand; // Track if 'full' or specific hand number
                
                if (selectedHand === 'full') {
                    this.currentHand = 1; // Start from Hand 1 for full game
                } else {
                    this.currentHand = parseInt(selectedHand); // Start from selected hand
                    console.log(`%cğŸ¯ Starting at Hand ${this.currentHand} (Single Hand Mode)`, 'color: #ffd700; font-weight: bold; font-size: 16px;');
                }
                
                this.players = 3;

                this.startingPlayer = null;  // Will be set by draw
                this.currentPlayer = 0;      // Temporary, will be updated after draw

                // ğŸ¯ v2.5.0: Track last card alerts to show only once per player
                this.lastCardAlertShown = [false, false, false];  // â† ADD THIS LINE

                this.deck = []; this.discardPile = [];
                this.playerHands = [[], [], []]; 
                this.playerBuys = this.currentHand === 7 ? [2, 2, 2] : [3, 3, 3]; // ğŸ® v4.5.12: Hand 7 gets 2 buys
                this.publishedSequences = [[], [], []]; this.gamePhase = 'draw';
                this.selectedCards = [];
                this.playerScores = carryOverScores ? [...persistentScores] : [0, 0, 0];
                this.lastDiscard = null; this.justPublished = false;
                this.lastDiscardByPlayer = -1; this.aiJustPublished = [false, false, false];
                this.turnCounter = 0;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                this.lastAIDiscard = [null, null, null];
                this.aiPersonality = { 1: 'rabbit', 2: 'tortoise' };
                this.lastCardWarningShown = null;
                this.discardPileAccessible = false; // ğŸ”’ v4.1.3: Glass vault - only accessible after NEW discard
                
                // ğŸ—ï¸ v4.5.12: STAGED CONSTRUCTION SYSTEM for Games 6-7
                // AI builds sequences SEQUENTIALLY (L1 â†’ L2 â†’ T) instead of parallel accumulation
                this.aiConstructionStage = [null, 'initial', 'initial']; // [human, habot, jabot]
                // Stages: 'initial' â†’ 'building_L1' â†’ 'building_L2' â†’ 'building_T' â†’ 'ready_to_publish'
                
                this.aiLockedSequences = [[], [], []]; // Completed sequences protected from discard
                // Format: [{ type: 'ladder', cards: [...], suit: 'â™¥' }, ...]
                
                // ğŸ”¶ v4.5.12: HOLD SYSTEM - Parallel construction breakthrough!
                this.aiHeldSequences = [[], [], []]; // 3-card "almost ladders" on hold while building others
                // Format: [{ cards: [Card, Card, Card], suit: 'â™ ', targets: [5, 9], type: 'ladder', createdTurn: 15, priority: 10 }, ...]
                
                this.aiTargetCards = [null, [], []]; // Specific cards AI is hunting for
                // Format: ['5â™¥', '7â™ ', '10â™¦'] - max 3 targets per AI
                
                this.aiSuitFocus = [null, [], []]; // Concentrated suits AI is working on
                // Format: ['â™¥', 'â™ '] - 2-3 suits AI focuses on for ladder building
                
                // ğŸ’š v4.5.12: AGGRESSIVE BUY MODE - Track when stages started for scattered card detection
                this.aiStageStartTurn = [null, 0, 0]; // Turn number when current stage started
                // Used to detect when AI is stuck on same stage too long â†’ activate aggressive mode
                
                // ğŸ¯ v3.0: Cache for sequence separation to reduce logging spam
                this.sequenceSeparationCache = {
                    turnCounter: -1,
                    cache: {}
                };
                this.handReqs = {
                    1: { name: "Two Triples", seqs: ["triple", "triple"], cards: 10 },
                    2: { name: "Triple + Ladder", seqs: ["triple", "ladder"], cards: 10 },
                    3: { name: "Two Ladders", seqs: ["ladder", "ladder"], cards: 10 },
                    4: { name: "Three Triples", seqs: ["triple", "triple", "triple"], cards: 10 },
                    5: { name: "2 Triples + Ladder", seqs: ["triple", "triple", "ladder"], cards: 10 },
                    6: { name: "Triple + 2 Ladders", seqs: ["triple", "ladder", "ladder"], cards: 10 },
                    7: { name: "Three Ladders", seqs: ["ladder", "ladder", "ladder"], cards: 10 }
                };
                this.initDeck(); this.deal(); this.updateUI();
                
                // ğŸ—ï¸ v4.5.12: Initialize suit focus for ANY hand with ladders (not just 6-7)
                const handReq = this.handReqs[this.currentHand];
                const needsLadders = handReq.seqs.filter(s => s === 'ladder').length > 0;
                
                if (needsLadders) {
                    console.log(`%cğŸ—ï¸ v4.5.12: Initializing SUIT FOCUS for Hand ${this.currentHand} (${handReq.name})`, 'color: #9b59b6; font-weight: bold; font-size: 14px;');
                    
                    // For hands 6-7: Use full staged construction
                    if (this.currentHand >= 6) {
                        this.aiConstructionStage = [null, 'building_L1', 'building_L1'];
                        this.aiStageStartTurn = [null, this.turnCounter, this.turnCounter];
                        this.aiLockedSequences = [[], [], []];
                    }
                    
                    // For ALL ladder hands (2, 3, 5, 6, 7): Use suit focus
                    this.aiTargetCards = [null, [], []];
                    this.aiSuitFocus = [null, [], []];
                    
                    // Generate initial suit focus for AIs
                    for (let pIdx = 1; pIdx <= 2; pIdx++) {
                        const hand = this.playerHands[pIdx];
                        const numLadders = handReq.seqs.filter(s => s === 'ladder').length;
                        const focusSuits = this.selectSuitFocus(hand, numLadders); // 1-3 suits based on # ladders needed
                        this.aiSuitFocus[pIdx] = focusSuits;
                        
                        // Use different target generation for hands 6-7 vs 2,3,5
                        if (this.currentHand >= 6) {
                            this.aiTargetCards[pIdx] = this.generateTargetCardsWithHolds(hand, focusSuits, pIdx, 3);
                        } else {
                            this.aiTargetCards[pIdx] = this.generateTargetCards(hand, focusSuits, 5);
                        }
                        
                        console.log(`    ğŸ¯ ${['Human', 'Habot', 'Jabot'][pIdx]}: Focus suits ${focusSuits.join(', ')} - ${this.aiTargetCards[pIdx].length} targets`);
                    }
                }
                
                console.log('%c====== GAME STARTED ======', 'color:#28a745;font-size:14px;font-weight:bold');
            }

            getAIPersonality(aiIdx) {
                if (this.currentHand <= 3) return this.aiPersonality[aiIdx] || 'neutral';
                const aiScore = this.playerScores[aiIdx];
                const otherScores = this.playerScores.filter((_, idx) => idx !== aiIdx);
                const minOtherScore = Math.min(...otherScores);
                const maxOtherScore = Math.max(...otherScores);
                if (aiScore >= maxOtherScore && aiScore > minOtherScore + 20) return 'rabbit';
                if (aiScore <= minOtherScore) return 'tortoise';
                return this.aiPersonality[aiIdx] || 'neutral';
            }

            // ============================================
            // ğŸ´ v2.5.0: DRAW FOR FIRST TURN (Bridge Style)
            // ============================================
            async drawForFirstTurn() {
                console.log(`%cğŸ´ DRAW FOR FIRST TURN`, 'color: #9c27b0; font-weight: bold; font-size: 16px;');
                console.log(`%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'color: #9c27b0;');

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 1: Opening Banter
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const banter = getOpeningBanter();

                // Habot speaks first (aggressive/eager)
                await showInfoModal(
                    'ğŸ’¬ Habot',
                    banter[0].text,
                    'Continue',
                    'ğŸ‡',
                    true,   // Auto-fade
                    2000    // 2 seconds
                );

                // Jabot responds (calm/measured)
                await showInfoModal(
                    'ğŸ’¬ Jabot',
                    banter[1].text,
                    'Continue',
                    'ğŸ¢',
                    true,   // Auto-fade
                    2000    // 2 seconds
                );

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 2: The Draw
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                this.initDeck();

                const drawnCards = [
                    this.deck.pop(),  // Human (Player 0)
                    this.deck.pop(),  // Habot (Player 1)
                    this.deck.pop()   // Jabot (Player 2)
                ];

                console.log(`%c  Cards drawn:`, 'color: #9c27b0; font-weight: bold;');
                console.log(`    Human: ${drawnCards[0].toString()}`);
                console.log(`    Habot: ${drawnCards[1].toString()}`);
                console.log(`    Jabot: ${drawnCards[2].toString()}`);

                // Show draws with dramatic timing
                await showInfoModal(
                    'ğŸ´ Habot Draws',
                    `Habot draws...\n\n${drawnCards[1].toString()}`,
                    'Continue',
                    'ğŸ‡',
                    true,
                    1800
                );

                await showInfoModal(
                    'ğŸ´ Jabot Draws',
                    `Jabot draws...\n\n${drawnCards[2].toString()}`,
                    'Continue',
                    'ğŸ¢',
                    true,
                    1800
                );

                await showInfoModal(
                    'ğŸ´ Your Draw',
                    `You draw...\n\n${drawnCards[0].toString()}`,
                    'Got it!',
                    'ğŸƒ',
                    false  // Must acknowledge
                );

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 3: Determine Winner
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const suitOrder = { 'â™ ': 4, 'â™¥': 3, 'â™¦': 2, 'â™£': 1 };

                const cardValues = drawnCards.map((card, idx) => ({
                    player: idx,
                    card: card,
                    value: card.getValue(),
                    suitValue: suitOrder[card.suit]
                }));

                // Sort by rank first, then by suit
                cardValues.sort((a, b) => {
                    if (b.value !== a.value) return b.value - a.value;
                    return b.suitValue - a.suitValue;
                });

                const winner = cardValues[0].player;
                const highestValue = cardValues[0].value;
                const tiedPlayers = cardValues.filter(cv => cv.value === highestValue);

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 4: Handle Ties (Show Hierarchy)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (tiedPlayers.length > 1) {
                    console.log(`%c  ğŸ”„ TIE DETECTED! Multiple ${cardValues[0].card.rank}s drawn`, 'color: #ff9800; font-weight: bold;');

                    const tiedNames = tiedPlayers.map(cv => ['You', 'Habot', 'Jabot'][cv.player]).join(', ');
                    const tiedCards = tiedPlayers.map(cv => `${['You', 'Habot', 'Jabot'][cv.player]}: ${cv.card.toString()}`).join('\n');

                    // Show tie with suit hierarchy explanation
                    const suitInfo = getSuitExplanation();
                    await showInfoModal(
                        'ğŸ”„ Tie Detected!',
                        `${tiedNames} all drew ${cardValues[0].card.rank}!\n\n${tiedCards}\n\n${suitInfo.message}`,
                        'Continue',
                        'ğŸ´',
                        true,   // Auto-fade
                        4000    // 4 seconds - enough time to read
                    );

                    console.log(`%c  âœ… Suit hierarchy: ${drawnCards[winner].suit} wins`, 'color: #4caf50; font-weight: bold;');
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 5: Announce Winner with Reactions
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const playerNames = ['You', 'Habot', 'Jabot'];
                const winnerName = playerNames[winner];
                const winnerCard = drawnCards[winner];

                const reactions = getWinReaction(winner, winnerCard, drawnCards);

                console.log(`%c  ğŸ† WINNER: ${winnerName} (${winnerCard.toString()})`, 'color: #ffd700; font-weight: bold; font-size: 14px;');

                // Show winner announcement
                let winnerMessage = `${winnerName} drew the highest card!\n\n${winnerCard.toString()}\n\n`;

                // Add summary of all draws
                winnerMessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                winnerMessage += `Habot: ${drawnCards[1].toString()}\n`;
                winnerMessage += `Jabot: ${drawnCards[2].toString()}\n`;
                winnerMessage += `You: ${drawnCards[0].toString()}\n`;
                winnerMessage += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
                winnerMessage += `${winnerName} will start first!`;

                await showInfoModal(
                    'ğŸ† Starting Player',
                    winnerMessage,
                    'Continue',
                    'ğŸ‘‘',
                    false  // Must acknowledge
                );

                // Show winner's reaction
                await showInfoModal(
                    winner === 0 ? 'ğŸ’¬ The Table' : `ğŸ’¬ ${winnerName}`,
                    reactions.winner,
                    'Continue',
                    winner === 1 ? 'ğŸ‡' : (winner === 2 ? 'ğŸ¢' : 'ğŸ´'),
                    true,
                    2500
                );

                // Show loser reactions (if any)
                for (let loser of reactions.losers) {
                    await showInfoModal(
                        `ğŸ’¬ ${loser.speaker}`,
                        loser.text,
                        'Continue',
                        loser.speaker === 'Habot' ? 'ğŸ‡' : 'ğŸ¢',
                        true,
                        2000
                    );
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 6: Reshuffle & Ready to Play
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                drawnCards.forEach(card => this.deck.push(card));
                this.initDeck();  // Fresh shuffle

                console.log(`%c  â™»ï¸  Cards returned to deck, reshuffled`, 'color: #9c27b0;');
                console.log(`%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'color: #9c27b0;');

                return winner;
            }

            initDeck() {
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                this.deck = [];
                for (let d = 0; d < 2; d++) {
                    for (let suit of suits) {
                        for (let rank of ranks) {
                            this.deck.push(new Card(rank, suit));
                        }
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            isTripleHeavyHand() {
                const req = this.handReqs[this.currentHand].seqs;
                const tripleCount = req.filter(s => s === 'triple').length;
                const ladderCount = req.filter(s => s === 'ladder').length;
                return tripleCount > 0 && (ladderCount === 0 || tripleCount >= ladderCount);
            }

            deal() {
                // ğŸ¯ v2.5.0: Reset last card alerts for new hand
                this.lastCardAlertShown = [false, false, false];

                const cards = this.handReqs[this.currentHand].cards;
                for (let i = 0; i < cards; i++) {
                    for (let p = 0; p < this.players; p++) {
                        if (this.deck.length > 0) this.playerHands[p].push(this.deck.pop());
                    }
                }

                // ğŸ´ v2.5.0: Flip initial discard card with commentary
                if (this.deck.length > 0) {
                    const initialDiscard = this.deck.pop();
                    this.discardPile.push(initialDiscard);
                    this.discardPileAccessible = true; // ğŸ”’ v4.1.3: Unlock vault - new card on glass

                    console.log(`%cğŸ´ Initial discard card: ${initialDiscard.toString()}`, 'color: #ff9800; font-weight: bold;');

                    // Add character commentary based on card value
                    let commentary = '';
                    const rank = initialDiscard.rank;

                    if (['A', 'K', 'Q'].includes(rank)) {
                        commentary = 'Habot: "Interesting start... that\'s a valuable card."\nJabot: "Indeed. The first player has a decision to make."';
                    } else if (['J', '10', '9'].includes(rank)) {
                        commentary = 'Jabot: "A reasonable starting card."\nHabot: "Could fit into several sequences."';
                    } else {
                        commentary = 'Habot: "Low card on the pile - probably not worth the buy."\nJabot: "We shall see. Every card has its place."';
                    }

                    showInfoModal(
                        'ğŸ´ Starting Card',
                        `The discard pile begins with:\n\n${initialDiscard.toString()}\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n${commentary}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nFirst player may take it or draw from deck.`,
                        'Start Playing!',
                        'ğŸƒ',
                        true,
                        4000  // 4 seconds
                    );
                }

                // ğŸ¯ v2.5.0: Smart initial sort based on game type
                const currentReq = this.handReqs[this.currentHand].seqs;
                const hasLadders = currentReq.some(seq => seq === 'ladder');
                const hasOnlyTriples = currentReq.every(seq => seq === 'triple');

                console.log(`%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'color: #2196f3;');
                console.log(`%cğŸƒ SORTING Hand ${this.currentHand}`, 'color: #2196f3; font-weight: bold; font-size: 14px;');
                console.log(`   Requirements: ${JSON.stringify(currentReq)}`);
                console.log(`   Has ladders: ${hasLadders}`);
                console.log(`   Only triples: ${hasOnlyTriples}`);
                console.log(`   Cards before sort: ${this.playerHands[0].map(c => c.toString()).join(', ')}`);

                // Sort player hand directly (don't call global functions during initialization)
                if (hasOnlyTriples) {
                    console.log(`%c   â†’ Applying QUANTITY sort`, 'color: #4caf50; font-weight: bold;');

                    // Count frequency of each rank
                    const counts = {};
                    this.playerHands[0].forEach(card => {
                        counts[card.rank] = (counts[card.rank] || 0) + 1;
                    });

                    console.log(`   â†’ Rank counts:`, counts);

                    // Sort by quantity (descending), then by rank value
                    this.playerHands[0].sort((a, b) => {
                        const countDiff = counts[b.rank] - counts[a.rank];
                        if (countDiff !== 0) return countDiff;
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });

                } else if (hasLadders) {
                    console.log(`%c   â†’ Applying SUIT sort`, 'color: #4caf50; font-weight: bold;');

                    // Sort by suit, then by rank
                    const order = { 'â™ ': 1, 'â™¥': 2, 'â™¦': 3, 'â™£': 4 };
                    this.playerHands[0].sort((a, b) => {
                        if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                        return a.getValue() - b.getValue();
                    });

                } else {
                    console.log(`%c   â†’ Applying RANK sort`, 'color: #4caf50; font-weight: bold;');

                    // Sort by rank value, then by suit
                    this.playerHands[0].sort((a, b) => {
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });
                }

                console.log(`   Cards after sort: ${this.playerHands[0].map(c => c.toString()).join(', ')}`);
                console.log(`%câœ… Sort complete!`, 'color: #00ff00; font-weight: bold;');
                console.log(`%câ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'color: #2196f3;');

                this.selectedCards = [];
            }


            reshuffleDeck() {
                if (this.discardPile.length <= 1) { console.log('%cNo cards to reshuffle', 'color: #ffc107;'); return false }
                const topCard = this.discardPile.pop();
                this.deck = [...this.discardPile];
                this.discardPile = [topCard];
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
                console.log(`%cReshuffled ${this.deck.length} cards`, 'color: #ffc107; font-weight: bold;');
                return true;
            }

            isValidTriple(cards) { if (cards.length !== 3) return false; return cards.every(c => c.rank === cards[0].rank) }

            isValidLadder(cards) {
                if (cards.length !== 4) return false;
                if (!cards.every(c => c.suit === cards[0].suit)) return false;
                const values = cards.map(c => c.getValue());
                if (values.includes(1) && values.includes(13) && values.includes(12) && values.includes(11)) return true;
                const sorted = [...values].sort((a, b) => a - b);
                for (let i = 1; i < sorted.length; i++) { if (sorted[i] !== sorted[i - 1] + 1) return false }
                return true;
            }

            isLadderHand() { return [2, 3, 5, 6, 7].includes(this.currentHand) }

            hasThreeCardLadderProgress(hand) {
                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                return Object.values(bySuit).some(cards => {
                    if (cards.length < 3) return false;
                    const uniqueByRank = [];
                    const seenRanks = new Set();
                    cards.sort((a, b) => a.getValue() - b.getValue());
                    cards.forEach(card => { if (!seenRanks.has(card.rank)) { uniqueByRank.push(card); seenRanks.add(card.rank) } });
                    for (let i = 0; i < uniqueByRank.length - 2; i++) {
                        if (uniqueByRank[i + 1].getValue() === uniqueByRank[i].getValue() + 1 &&
                            uniqueByRank[i + 2].getValue() === uniqueByRank[i + 1].getValue() + 1) return true;
                    }
                    return false;
                });
            }

            // ğŸ¯ v4.0.7 Helper: Flatten published sequences to flat array
            getFlatPublished(playerIdx) {
                return this.publishedSequences[playerIdx].flat();
            }

            // ğŸ¯ v4.0.7 Helper: Count total published cards
            getPublishedCount(playerIdx) {
                return this.publishedSequences[playerIdx].reduce((sum, seq) => sum + seq.length, 0);
            }

            getPublishedRanks(playerIdx) { 
                const ranks = new Set(); 
                this.publishedSequences[playerIdx].forEach(seq => {
                    seq.forEach(c => ranks.add(c.rank));
                });
                return ranks;
            }
            getPublishedSuits(playerIdx) { 
                const suits = new Set(); 
                this.publishedSequences[playerIdx].forEach(seq => {
                    seq.forEach(c => suits.add(c.suit));
                });
                return suits;
            }

            getPublishProgress() {
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const seqs = this.findSequences(this.playerHands[0]);
                const hasTriples = seqs.triples.length;
                const hasLadders = seqs.ladders.length;
                return { needTriples, hasTriples, needLadders, hasLadders, canPublish: hasTriples >= needTriples && hasLadders >= needLadders };
            }

            findSequences(hand) {
                const seqs = { triples: [], ladders: [] };
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });


                Object.values(byRank).forEach(g => {
                    if (g.length >= 3) {
                        // âœ… FIX 1C: Generate ALL combinations of 3 cards (not just sliding windows)
                        for (let i = 0; i < g.length - 2; i++) {
                            for (let j = i + 1; j < g.length - 1; j++) {
                                for (let k = j + 1; k < g.length; k++) {
                                    seqs.triples.push([g[i], g[j], g[k]]);
                                }
                            }
                        }
                    }
                });


                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                Object.values(bySuit).forEach(g => {
                    if (g.length >= 4) {
                        // v4.5.12 FIX: Generate J-Q-K-A ladders for ALL Aces (not just first)
                        const allAces = g.filter(c => c.rank === 'A');
                        const hasK = g.find(c => c.rank === 'K');
                        const hasQ = g.find(c => c.rank === 'Q');
                        const hasJ = g.find(c => c.rank === 'J');
                        if (allAces.length > 0 && hasK && hasQ && hasJ) {
                            // Create one J-Q-K-A ladder for EACH Ace instance
                            allAces.forEach(ace => {
                                seqs.ladders.push([hasJ, hasQ, hasK, ace]);
                            });
                        }
                        
                        // v4.5.12 COMPLETE FIX: Handle duplicate ranks in consecutive ladders
                        // Group cards by rank (allows multiple instances of same rank)
                        const byRank = {};
                        g.forEach(card => {
                            if (!byRank[card.rank]) byRank[card.rank] = [];
                            byRank[card.rank].push(card);
                        });
                        
                        // Get unique ranks in sorted order
                        const uniqueRanks = [...new Set(g.map(c => c.rank))];
                        uniqueRanks.sort((a, b) => {
                            const aCard = g.find(c => c.rank === a);
                            const bCard = g.find(c => c.rank === b);
                            return aCard.getValue() - bCard.getValue();
                        });
                        
                        // Generate all possible 4-card consecutive sequences
                        for (let i = 0; i <= uniqueRanks.length - 4; i++) {
                            const ranks = uniqueRanks.slice(i, i + 4);
                            
                            // Check if ranks are consecutive
                            const firstCard = byRank[ranks[0]][0];
                            const values = ranks.map(r => byRank[r][0].getValue());
                            let isConsecutive = true;
                            for (let j = 1; j < values.length; j++) {
                                if (values[j] !== values[j-1] + 1) {
                                    isConsecutive = false;
                                    break;
                                }
                            }
                            
                            if (isConsecutive) {
                                // Generate ALL combinations when ranks have duplicates
                                // For example: if ranks are [A,2,3,4] and there are 2 Aces,
                                // generate both [A1,2,3,4] and [A2,2,3,4]
                                const generateCombinations = (rankIndex, currentCombo) => {
                                    if (rankIndex === ranks.length) {
                                        // Complete combination - add to ladders
                                        if (this.isValidLadder(currentCombo)) {
                                            seqs.ladders.push([...currentCombo]);
                                        }
                                        return;
                                    }
                                    
                                    // For current rank, try each instance
                                    const rank = ranks[rankIndex];
                                    const instances = byRank[rank];
                                    instances.forEach(cardInstance => {
                                        currentCombo.push(cardInstance);
                                        generateCombinations(rankIndex + 1, currentCombo);
                                        currentCombo.pop();
                                    });
                                };
                                
                                generateCombinations(0, []);
                            }
                        }
                    }
                });
                
                // v4.5.12 FINAL: De-duplicate patterns for user display
                // Keeps all combinations internally, but shows each pattern once
                seqs.ladders = this.deduplicateLadderPatterns(seqs.ladders);
                
                return seqs;
            }
            
            deduplicateLadderPatterns(ladders) {
                // v4.5.12: Remove duplicate patterns from display
                // User doesn't care which physical card ID is used where
                // They just want to see each unique pattern once
                const uniquePatterns = new Map();
                
                ladders.forEach(ladder => {
                    // Create pattern key: rank+suit for each card, sorted
                    // Example: [Aâ™¦, 2â™¦, 3â™¦, 4â™¦] â†’ "2â™¦|3â™¦|4â™¦|Aâ™¦"
                    const patternKey = ladder
                        .map(c => c.rank + c.suit)
                        .sort()
                        .join('|');
                    
                    // Keep first occurrence of each pattern
                    if (!uniquePatterns.has(patternKey)) {
                        uniquePatterns.set(patternKey, ladder);
                    }
                });
                
                console.log(`%cğŸ¯ v4.5.12: De-duplicated ${ladders.length} ladders â†’ ${uniquePatterns.size} unique patterns`, 'color:#3b82f6;font-weight:bold');
                return Array.from(uniquePatterns.values());
            }

            canPublish(pIdx) {
                const hand = this.playerHands[pIdx];
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                const tripleRanks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3);
                if (tripleRanks.length < needTriples) return false;
                const tryPublish = (tripleAssignments, triplesAssigned, usedIds, startRankIdx = 0) => {
                    if (triplesAssigned === needTriples) {
                        let laddersFound = 0; const usedForLadders = new Set(usedIds);
                        for (let i = 0; i < needLadders; i++) {
                            const remaining = hand.filter(c => !usedForLadders.has(c.id));
                            const testSeqs = this.findSequences(remaining);
                            if (testSeqs.ladders.length === 0) break;
                            testSeqs.ladders[0].forEach(c => usedForLadders.add(c.id));
                            laddersFound++;
                        }
                        return laddersFound >= needLadders;
                    }
                    for (let rankIdx = startRankIdx; rankIdx < tripleRanks.length; rankIdx++) {
                        const rank = tripleRanks[rankIdx];
                        const cards = byRank[rank];
                        if (cards.length >= 4) {
                            for (let i = 0; i < cards.length - 2; i++) {
                                for (let j = i + 1; j < cards.length - 1; j++) {
                                    for (let k = j + 1; k < cards.length; k++) {
                                        const newUsed = new Set(usedIds);
                                        newUsed.add(cards[i].id); newUsed.add(cards[j].id); newUsed.add(cards[k].id);
                                        if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                                    }
                                }
                            }
                        } else {
                            const newUsed = new Set(usedIds);
                            cards.slice(0, 3).forEach(c => newUsed.add(c.id));
                            if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                        }
                    }
                    return false;
                };
                return tryPublish([], 0, new Set());
            }

            // ğŸ¯ v4.0.7: Separate flat array of cards into 2D sequences
            separateSequences(cards, requirements) {
                const req = requirements;
                const sequences = [];
                const usedInSequence = new Set();
                
                // Extract triples first
                const byRank = {};
                cards.forEach(c => {
                    if (!byRank[c.rank]) byRank[c.rank] = [];
                    byRank[c.rank].push(c);
                });
                
                Object.values(byRank).forEach(rankCards => {
                    if (rankCards.length >= 3) {
                        // ğŸ¯ v4.0.7 FIX: Handle 4-of-a-kind properly
                        // If exactly 4 cards, keep them together
                        // If more than 4, group by 3s
                        if (rankCards.length === 4) {
                            sequences.push(rankCards);
                            rankCards.forEach(c => usedInSequence.add(c.id));
                        } else {
                            // Group by 3s for 3, 5, 6, 7+ cards
                            for (let i = 0; i + 2 < rankCards.length; i += 3) {
                                const triple = rankCards.slice(i, i + 3);
                                sequences.push(triple);
                                triple.forEach(c => usedInSequence.add(c.id));
                            }
                        }
                    }
                });
                
                // Extract ladders from remaining cards
                const remainingCards = cards.filter(c => !usedInSequence.has(c.id));
                const bySuit = {};
                remainingCards.forEach(c => {
                    if (!bySuit[c.suit]) bySuit[c.suit] = [];
                    bySuit[c.suit].push(c);
                });
                
                // ğŸ› FIX v4.0.9: Only accept CONSECUTIVE cards as ladders
                Object.values(bySuit).forEach(suitCards => {
                    if (suitCards.length >= 4) {
                        suitCards.sort((a, b) => a.getValue() - b.getValue());
                        
                        // Check for wrap-around ladder (A-K-Q-J...) FIRST
                        const values = suitCards.map(c => c.getValue());
                        const hasAce = values.includes(1);
                        const hasKing = values.includes(13);
                        
                        if (hasAce && hasKing) {
                            // Potential wrap-around - check if we have consecutive high cards leading to King
                            const nonAceCards = suitCards.filter(c => c.getValue() !== 1);
                            nonAceCards.sort((a, b) => b.getValue() - a.getValue()); // Sort high to low
                            
                            // Build wrap ladder from King downward
                            let wrapLadder = [];
                            let expectedValue = 13; // Start at King
                            
                            for (let card of nonAceCards) {
                                if (card.getValue() === expectedValue) {
                                    wrapLadder.push(card);
                                    expectedValue--;
                                } else {
                                    break; // Gap found
                                }
                            }
                            
                            // If we have 3+ consecutive high cards (K, Q, J minimum), add Ace at front
                            if (wrapLadder.length >= 3) {
                                const aceCard = suitCards.find(c => c.getValue() === 1);
                                wrapLadder.unshift(aceCard); // Add Ace at the beginning
                                sequences.push([...wrapLadder]);
                                
                                // Remove used cards from suitCards for normal ladder processing
                                const usedIds = new Set(wrapLadder.map(c => c.id));
                                suitCards = suitCards.filter(c => !usedIds.has(c.id));
                            }
                        }
                        
                        // Now find regular consecutive ladders in remaining cards
                        if (suitCards.length >= 4) {
                            suitCards.sort((a, b) => a.getValue() - b.getValue());
                            let currentLadder = [suitCards[0]];
                            
                            for (let i = 1; i < suitCards.length; i++) {
                                const prevValue = currentLadder[currentLadder.length - 1].getValue();
                                const currValue = suitCards[i].getValue();
                                
                                if (currValue === prevValue + 1) {
                                    currentLadder.push(suitCards[i]);
                                } else {
                                    // Gap found - save current ladder if valid, start new one
                                    if (currentLadder.length >= 4) {
                                        sequences.push([...currentLadder]);
                                    }
                                    currentLadder = [suitCards[i]];
                                }
                            }
                            
                            // Don't forget the last ladder!
                            if (currentLadder.length >= 4) {
                                sequences.push(currentLadder);
                            }
                        }
                    }
                });
                
                return sequences;
            }

            autoPublish(pIdx) {
                // ğŸ›¡ï¸ FIX 6: CRITICAL - Block republishing!
                if (this.publishedSequences[pIdx].length > 0) {
                    console.log(`â­ï¸ FIX 6: Player ${pIdx} already has ${this.publishedSequences[pIdx].length} published sequences - blocking republish`);
                    return false;
                }

                // ğŸ—ï¸ v4.5.12: STAGED CONSTRUCTION - Use locked sequences for Hands 6-7
                if (this.currentHand >= 6 && this.aiLockedSequences[pIdx].length > 0) {
                    console.log(`  ğŸ—ï¸ v4.5.12: Using ${this.aiLockedSequences[pIdx].length} locked sequences for publishing`);
                    
                    const req = this.handReqs[this.currentHand].seqs;
                    const triplesNeeded = req.filter(s => s === 'triple').length;
                    const laddersNeeded = req.filter(s => s === 'ladder').length;
                    
                    const lockedTriples = this.aiLockedSequences[pIdx].filter(s => s.type === 'triple');
                    const lockedLadders = this.aiLockedSequences[pIdx].filter(s => s.type === 'ladder');
                    
                    console.log(`      Need: ${triplesNeeded}T + ${laddersNeeded}L`);
                    console.log(`      Have locked: ${lockedTriples.length}T + ${lockedLadders.length}L`);
                    
                    // Check if we have all requirements locked
                    if (lockedTriples.length >= triplesNeeded && lockedLadders.length >= laddersNeeded) {
                        console.log(`      âœ… All requirements met! Publishing locked sequences`);
                        
                        // Build published array from locked sequences
                        const published = [];
                        for (let i = 0; i < triplesNeeded; i++) {
                            published.push(...lockedTriples[i].cards);
                        }
                        for (let i = 0; i < laddersNeeded; i++) {
                            published.push(...lockedLadders[i].cards);
                        }
                        
                        // Separate into 2D structure
                        const sequences = this.separateSequences(published, req);
                        
                        // Remove published cards from hand
                        published.forEach(c => {
                            const idx = this.playerHands[pIdx].findIndex(card => card.id === c.id);
                            if (idx > -1) this.playerHands[pIdx].splice(idx, 1);
                        });
                        
                        // Set published sequences
                        this.publishedSequences[pIdx] = sequences;
                        this.aiJustPublished[pIdx] = true;
                        
                        console.log(`      âœ… v4.5.12: Published ${sequences.length} sequences from locked cards`);
                        return true;
                    } else {
                        console.log(`      âŒ Not all requirements locked yet - continue building`);
                        return false;
                    }
                }

                const req = this.handReqs[this.currentHand].seqs;
                const hand = this.playerHands[pIdx];
                const opponentRanks = new Set();

                const opponentSuits = new Set();
                for (let i = 0; i < this.players; i++) {
                    if (i !== pIdx) {
                        this.getPublishedRanks(i).forEach(r => opponentRanks.add(r));
                        this.getPublishedSuits(i).forEach(s => opponentSuits.add(s));
                    }
                }
                let published = [];
                const usedCardIds = new Set();
                let triplesPublished = 0;
                let laddersPublished = 0;
                const triplesNeeded = req.filter(s => s === 'triple').length;
                const laddersNeeded = req.filter(s => s === 'ladder').length;
                while (triplesPublished < triplesNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const byRank = {};
                    availableHand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                    const ranks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3).sort((a, b) => {
                        const aOverlap = opponentRanks.has(a) ? 1 : 0;
                        const bOverlap = opponentRanks.has(b) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return parseInt(a === 'A' ? 1 : a === 'J' ? 11 : a === 'Q' ? 12 : a === 'K' ? 13 : a) -
                            parseInt(b === 'A' ? 1 : b === 'J' ? 11 : b === 'Q' ? 12 : b === 'K' ? 13 : b);
                    });
                    if (ranks.length === 0) break;
                    const rank = ranks[0];
                    const cards = byRank[rank];
                    if (cards.length >= 4) {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    } else {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    }
                    triplesPublished++;
                }
                while (laddersPublished < laddersNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const seqs = this.findSequences(availableHand);
                    if (seqs.ladders.length === 0) break;
                    seqs.ladders.sort((a, b) => {
                        const aOverlap = opponentSuits.has(a[0].suit) ? 1 : 0;
                        const bOverlap = opponentSuits.has(b[0].suit) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return a[0].getValue() - b[0].getValue();
                    });
                    const ladder = seqs.ladders[0];
                    published = published.concat(ladder);
                    ladder.forEach(c => usedCardIds.add(c.id));
                    laddersPublished++;
                }
                if (triplesPublished < triplesNeeded || laddersPublished < laddersNeeded) return false;
                
                // ğŸ¯ v4.0.7: Use separateSequences to build 2D structure
                const sequences = this.separateSequences(published, req);
                
                // Remove published cards from hand
                published.forEach(c => {
                    const idx = this.playerHands[pIdx].findIndex(card => card.id === c.id);
                    if (idx > -1) this.playerHands[pIdx].splice(idx, 1);
                });
                
                // ğŸ¯ v4.0.7: Store as 2D array!
                this.publishedSequences[pIdx] = sequences;
                
                console.log(`%cğŸ¯ v4.0.7: Published ${sequences.length} separate sequences for Player ${pIdx}`, 'color: #27ae60; font-weight: bold;');
                sequences.forEach((seq, i) => {
                    console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString()).join(' ')}`);
                });

                // â† ADD THESE TWO LINES HERE:
                this.renderAIHands();
                this.renderPublished();

                return true;
            }

            // âœ… FIX 1: Explicit LOW and HIGH end ladder extension support
            canCardExtendLadder(cardVal, ladderValues) {
                const sorted = [...ladderValues].sort((a, b) => a - b);
                const minVal = sorted[0];
                const maxVal = sorted[sorted.length - 1];

                console.log(`  ğŸ” FIX 1: Checking if ${cardVal} can extend ladder [${sorted.join(',')}]`);

                // Check for wrap-around ladder (A-K-Q-J)
                const hasAce = sorted.includes(1);
                const hasKing = sorted.includes(13);
                const hasQueen = sorted.includes(12);
                const hasJack = sorted.includes(11);
                const isWrapAroundLadder = hasAce && hasJack && hasQueen && hasKing;

                if (isWrapAroundLadder) {
                    if (cardVal === 1) return false; // No duplicate Ace
                    const nonAceValues = sorted.filter(v => v !== 1);
                    const lowEnd = Math.min(...nonAceValues);
                    const canExtend = cardVal === lowEnd - 1;
                    console.log(`  âœ… FIX 1: Wrap-around ladder - Can extend LOW: ${canExtend}`);
                    return canExtend;
                }

                // âœ… FIX 7: Special case - Ace can extend after King (K-A wrap)
                if (cardVal === 1 && maxVal === 13) {
                    console.log(`  âœ… FIX 7: ACE after KING wrap: true`);
                    return true;
                }

                // âœ… FIX 1: Normal ladders - EXPLICIT support for BOTH ends
                const canExtendLow = (cardVal === minVal - 1);
                const canExtendHigh = (cardVal === maxVal + 1);

                console.log(`  âœ… FIX 1: LOW end (${minVal}-1=${minVal - 1}): ${canExtendLow}`);
                console.log(`  âœ… FIX 1: HIGH end (${maxVal}+1=${maxVal + 1}): ${canExtendHigh}`);

                return canExtendLow || canExtendHigh;
            }

            // ğŸ—ï¸ v4.5.12 STAGED CONSTRUCTION FUNCTIONS
            // ==========================================

            analyzeNearSequential(cards, suit) {
                // Finds partial sequences in a suit and identifies gaps
                // Returns: { values: [4,6,8], gaps: [5,7], potential: 2 }
                const suitCards = cards.filter(c => c.suit === suit);
                if (suitCards.length < 2) return { values: [], gaps: [], potential: 0 };
                
                const values = suitCards.map(c => c.getValue()).sort((a, b) => a - b);
                const gaps = [];
                let gapCount = 0;
                
                for (let i = 0; i < values.length - 1; i++) {
                    const gap = values[i + 1] - values[i];
                    if (gap === 2) {
                        // One card missing: e.g., 4 and 6, missing 5
                        gaps.push(values[i] + 1);
                        gapCount++;
                    } else if (gap === 3) {
                        // Two cards missing: e.g., 4 and 7, missing 5,6
                        gaps.push(values[i] + 1, values[i] + 2);
                        gapCount += 2;
                    }
                }
                
                // Potential: high card count + low gaps = high potential
                const potential = suitCards.length - gapCount;
                
                console.log(`  ğŸ” v4.5.12: Analyzing ${suit} - ${values.join(',')} - gaps: [${gaps.join(',')}] - potential: ${potential}`);
                return { values, gaps, potential, cardCount: suitCards.length };
            }

            selectSuitFocus(hand, numSuits = 2) {
                // Selects 2-3 suits with highest ladder-building potential
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                const analysis = suits.map(suit => ({
                    suit,
                    ...this.analyzeNearSequential(hand, suit)
                }));
                
                // Sort by: 1) potential, 2) card count, 3) fewer gaps
                analysis.sort((a, b) => {
                    if (b.potential !== a.potential) return b.potential - a.potential;
                    if (b.cardCount !== a.cardCount) return b.cardCount - a.cardCount;
                    return a.gaps.length - b.gaps.length;
                });
                
                const selected = analysis.slice(0, numSuits).map(a => a.suit);
                console.log(`  ğŸ¯ v4.5.12: Selected focus suits: ${selected.join(', ')}`);
                return selected;
            }

            selectSuitFocusFromSuits(hand, availableSuits, numSuits = 2) {
                // ğŸ”§ v4.5.12: Select suits from a limited set (excluding locked ladder suits)
                const analysis = availableSuits.map(suit => ({
                    suit,
                    ...this.analyzeNearSequential(hand, suit)
                }));
                
                // Sort by: 1) potential, 2) card count, 3) fewer gaps
                analysis.sort((a, b) => {
                    if (b.potential !== a.potential) return b.potential - a.potential;
                    if (b.cardCount !== a.cardCount) return b.cardCount - a.cardCount;
                    return a.gaps.length - b.gaps.length;
                });
                
                const selected = analysis.slice(0, Math.min(numSuits, availableSuits.length)).map(a => a.suit);
                console.log(`  ğŸ¯ v4.5.12: Selected focus suits from ${availableSuits.join(',')}: ${selected.join(', ')}`);
                return selected;
            }

            getUnlockedCards(hand, playerIdx) {
                // ğŸ”§ v4.5.12: Get cards not in locked sequences
                const lockedCardIds = new Set();
                this.aiLockedSequences[playerIdx].forEach(seq => {
                    seq.cards.forEach(card => lockedCardIds.add(card.id));
                });
                return hand.filter(card => !lockedCardIds.has(card.id));
            }

            // ğŸ”¶ v4.5.12: HOLD SYSTEM - Parallel Construction Functions
            
            findPotentialHolds(hand, playerIdx) {
                // Find all 3-card combinations that are "one card away" from a 4-card ladder
                const holds = [];
                const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
                
                // Exclude suits already used in locked ladders
                const lockedSuits = this.aiLockedSequences[playerIdx]
                    .filter(s => s.type === 'ladder')
                    .map(s => s.suit);
                const availableSuits = suits.filter(s => !lockedSuits.includes(s));
                
                availableSuits.forEach(suit => {
                    // Get all cards of this suit, sorted by value
                    const suitCards = hand
                        .filter(c => c.suit === suit)
                        .sort((a, b) => a.getValue() - b.getValue());
                    
                    if (suitCards.length < 3) return;
                    
                    // Check all 3-card combinations
                    for (let i = 0; i < suitCards.length - 2; i++) {
                        for (let j = i + 1; j < suitCards.length - 1; j++) {
                            for (let k = j + 1; k < suitCards.length; k++) {
                                const three = [suitCards[i], suitCards[j], suitCards[k]];
                                const targets = this.findCompletionTargets(three);
                                
                                if (targets.length > 0) {
                                    holds.push({
                                        cards: three,
                                        suit: suit,
                                        targets: targets,
                                        type: 'ladder',
                                        createdTurn: this.turnCounter,
                                        priority: this.calculateHoldPriority(three, targets)
                                    });
                                }
                            }
                        }
                    }
                });
                
                return holds;
            }

            findCompletionTargets(threeCards) {
                // Given 3 cards, find which single card would complete a 4-card ladder
                const values = threeCards.map(c => c.getValue()).sort((a, b) => a - b);
                const [v1, v2, v3] = values;
                const targets = [];
                
                // Pattern 1: [v1, v2, v3] are consecutive â†’ can extend left or right
                // Example: 6,7,8 â†’ need 5 or 9
                if (v2 === v1 + 1 && v3 === v2 + 1) {
                    if (v1 > 1) targets.push(v1 - 1);    // Extend left
                    if (v3 < 13) targets.push(v3 + 1);   // Extend right
                }
                
                // Pattern 2: Gap between v1 and v2
                // Example: 6,8,9 â†’ need 7 to make [6,7,8,9]
                else if (v2 === v1 + 2 && v3 === v2 + 1) {
                    targets.push(v1 + 1);  // Fill gap
                }
                
                // Pattern 3: Gap between v2 and v3
                // Example: 6,7,9 â†’ need 8 to make [6,7,8,9]
                else if (v2 === v1 + 1 && v3 === v2 + 2) {
                    targets.push(v2 + 1);  // Fill gap
                }
                
                // If no patterns match, this isn't "one card away" (e.g., 6,8,10 needs TWO cards)
                return targets;
            }

            calculateHoldPriority(threeCards, targets) {
                // Higher priority = more likely to complete
                let priority = 10; // Base priority
                
                // Bonus: Sequential cards (6,7,8) have 2 targets = higher chance
                if (targets.length === 2) {
                    priority += 5;
                }
                
                // Bonus: High-value cards (better for scoring)
                const avgValue = threeCards.reduce((sum, c) => sum + c.getValue(), 0) / 3;
                if (avgValue >= 8) priority += 3;
                
                // Bonus: Middle ranks (6-9) are most available
                const middleRanks = targets.filter(t => t >= 6 && t <= 9).length;
                priority += middleRanks * 2;
                
                return priority;
            }

            putOnHold(playerIdx, hold) {
                // Add to held sequences
                this.aiHeldSequences[playerIdx].push(hold);
                
                const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                const cardStr = hold.cards.map(c => c.toString()).join(',');
                const targetStr = hold.targets.map(t => `${t}${hold.suit}`).join(' or ');
                
                console.log(`ğŸ”¶ v4.5.12: ${aiName} put on HOLD: ${cardStr} - targeting ${targetStr}`);
            }

            checkHeldSequences(playerIdx) {
                // ğŸ”§ v4.5.12: Check if any held sequences can now be completed
                // Returns: true if ANY hold was completed (prevents double-locking)
                const hand = this.playerHands[playerIdx];
                const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                let completedAnyHold = false;
                
                // ğŸ”§ v4.5.12: Check for overlapping cards BEFORE locking
                const existingLocked = this.aiLockedSequences[playerIdx];
                
                // Iterate backwards to safely remove completed holds
                for (let i = this.aiHeldSequences[playerIdx].length - 1; i >= 0; i--) {
                    const hold = this.aiHeldSequences[playerIdx][i];
                    
                    // Check if we now have any of the target cards
                    const targetCard = hand.find(card => 
                        card.suit === hold.suit && 
                        hold.targets.includes(card.getValue())
                    );
                    
                    if (targetCard) {
                        // Found target! Complete the hold!
                        const completedLadder = [...hold.cards, targetCard]
                            .sort((a, b) => a.getValue() - b.getValue());
                        
                        // ğŸ”§ v4.5.12: Check for overlap with existing locked sequences
                        let hasOverlap = false;
                        for (const locked of existingLocked) {
                            const overlap = completedLadder.some(card => 
                                locked.cards.some(lockedCard => 
                                    lockedCard.rank === card.rank && lockedCard.suit === card.suit
                                )
                            );
                            if (overlap) {
                                hasOverlap = true;
                                console.log(`âš ï¸ v4.5.12: SKIP HOLD lock - overlaps with existing locked sequence`);
                                console.log(`   Attempted: ${completedLadder.map(c => c.toString()).join(',')}`);
                                console.log(`   Conflicts with: ${locked.cards.map(c => c.toString()).join(',')}`);
                                break;
                            }
                        }
                        
                        if (!hasOverlap) {
                            this.lockSequence(playerIdx, completedLadder, 'ladder', hold.suit);
                            console.log(`âœ… v4.5.12: ${aiName} completed HOLD! Got ${targetCard.toString()} â†’ Locked ${completedLadder.map(c => c.toString()).join(',')}`);
                            completedAnyHold = true;
                            
                            // Check if ready to publish
                            this.advanceConstructionStage(playerIdx);
                        }
                        
                        // Remove from holds regardless (either locked or overlapped)
                        this.aiHeldSequences[playerIdx].splice(i, 1);
                    }
                }
                
                return completedAnyHold; // ğŸ”§ v4.5.12: Return flag for decision tree
            }

            generateTargetCardsWithHolds(hand, suitFocus, playerIdx, maxTargets = 5) {
                // Generate targets including both current stage and all held sequences
                const targets = [];
                
                // Original targets for current stage
                const stageTargets = this.generateTargetCards(hand, suitFocus, maxTargets);
                targets.push(...stageTargets);
                
                // Add targets from ALL held sequences
                this.aiHeldSequences[playerIdx].forEach(hold => {
                    hold.targets.forEach(rank => {
                        const targetCard = `${rank}${hold.suit}`;
                        if (!targets.includes(targetCard)) {
                            targets.push(targetCard);
                            console.log(`  ğŸ¯ v4.5.12: HOLD target: ${targetCard} (completes ${hold.cards.map(c => c.toString()).join(',')})`);
                        }
                    });
                });
                
                return targets.slice(0, maxTargets + 3); // Allow a few extra for holds
            }

            // ğŸ’š v4.5.12: AGGRESSIVE BUY MODE - Detect when AI needs to be more lenient
            isAggressiveBuyMode(playerIdx) {
                // Detects "scattered card emergency" - when AI is stuck and needs to lower standards
                const stage = this.aiConstructionStage[playerIdx];
                const turnsOnStage = this.turnCounter - this.aiStageStartTurn[playerIdx];
                const buysRemaining = this.playerBuys[playerIdx];
                const hand = this.playerHands[playerIdx];
                const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                const seqs = this.findSequences(unlockedHand);
                const holds = this.findPotentialHolds(unlockedHand, playerIdx);
                const targets = this.aiTargetCards[playerIdx];
                
                // Activate aggressive mode when:
                // 1. Stuck on building_L1 or building_L2 for 20+ turns
                // 2. No complete ladders found
                // 3. No holds possible (cards too scattered)
                // 4. Still have 2+ buys remaining
                // 5. Very few targets (1-2)
                
                const isStuck = (stage === 'building_L1' || stage === 'building_L2') && turnsOnStage >= 20;
                const noProgress = seqs.ladders.length === 0 && holds.length === 0;
                const hasBuys = buysRemaining >= 2;
                const fewTargets = targets.length <= 2;
                
                const aggressive = isStuck && noProgress && hasBuys && fewTargets;
                
                if (aggressive) {
                    const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                    console.log(`%cğŸ’š v4.5.12: ${aiName} AGGRESSIVE BUY MODE activated!`, 'color: #27ae60; font-weight: bold;');
                    console.log(`   Reason: Stuck on ${stage} for ${turnsOnStage} turns, ${buysRemaining} buys left, only ${targets.length} targets`);
                }
                
                return aggressive;
            }


            generateTargetCards(hand, suitFocus, maxTargets = 3) {
                // Identifies specific cards needed to complete sequences
                const targets = [];
                
                for (let suit of suitFocus) {
                    const analysis = this.analyzeNearSequential(hand, suit);
                    
                    // Prioritize gaps that would create 4+ sequential runs
                    for (let gap of analysis.gaps) {
                        const rank = this.valueToRank(gap);
                        const targetCard = `${rank}${suit}`;
                        
                        // Check if adding this card would create 4+ run
                        const testValues = [...analysis.values, gap].sort((a, b) => a - b);
                        let maxRun = 1, currentRun = 1;
                        for (let i = 1; i < testValues.length; i++) {
                            if (testValues[i] === testValues[i-1] + 1) {
                                currentRun++;
                                maxRun = Math.max(maxRun, currentRun);
                            } else {
                                currentRun = 1;
                            }
                        }
                        
                        if (maxRun >= 4 && !targets.includes(targetCard)) {
                            targets.push(targetCard);
                            console.log(`  ğŸ¯ v4.5.12: Target card: ${targetCard} (would create ${maxRun}-card run)`);
                            if (targets.length >= maxTargets) break;
                        }
                    }
                    if (targets.length >= maxTargets) break;
                }
                
                return targets;
            }

            valueToRank(value) {
                // Converts card value (1-13) to rank string
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                return ranks[value - 1] || 'A';
            }

            lockSequence(playerIdx, cards, type, suit = null) {
                // Marks a completed sequence as protected from discard
                const locked = { type, cards: [...cards], suit };
                this.aiLockedSequences[playerIdx].push(locked);
                console.log(`  ğŸ”’ v4.5.12: LOCKED ${type} sequence (${cards.length} cards) for Player ${playerIdx}`);
                return locked;
            }

            isSequenceLocked(playerIdx, card) {
                // Checks if a card is part of any locked sequence
                for (let locked of this.aiLockedSequences[playerIdx]) {
                    if (locked.cards.some(c => c.id === card.id)) {
                        return true;
                    }
                }
                return false;
            }

            advanceConstructionStage(playerIdx) {
                // Moves AI to next construction stage based on completed sequences
                const currentStage = this.aiConstructionStage[playerIdx];
                const hand = this.playerHands[playerIdx];
                const seqs = this.findSequences(hand);
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                
                console.log(`  ğŸ—ï¸ v4.5.12: Stage check for Player ${playerIdx} - Current: ${currentStage}`);
                console.log(`      Has: ${seqs.triples.length} triples, ${seqs.ladders.length} ladders`);
                console.log(`      Need: ${needTriples} triples, ${needLadders} ladders`);
                console.log(`      Locked: ${this.aiLockedSequences[playerIdx].length} sequences`);
                
                // Count locked ladders
                const lockedLadders = this.aiLockedSequences[playerIdx].filter(s => s.type === 'ladder').length;
                
                if (currentStage === 'building_L1' && lockedLadders >= 1) {
                    // First ladder complete â†’ move to building second ladder
                    if (needLadders >= 2) {
                        this.aiConstructionStage[playerIdx] = 'building_L2';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // ğŸ’š v4.5.12: Track stage change
                        console.log(`  ğŸ¯ v4.5.12: ADVANCED to building_L2 (first ladder locked)`);
                        // ğŸ”§ v4.5.12: Exclude suits already used in locked ladders
                        const lockedSuits = this.aiLockedSequences[playerIdx]
                            .filter(s => s.type === 'ladder')
                            .map(s => s.suit);
                        console.log(`      ğŸš« v4.5.12: Excluding locked ladder suits: ${lockedSuits.join(', ')}`);
                        const availableSuits = ['â™ ', 'â™¥', 'â™¦', 'â™£'].filter(s => !lockedSuits.includes(s));
                        // Select from UNLOCKED hand only, in different suits
                        const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                        const focusSuits = this.selectSuitFocusFromSuits(unlockedHand, availableSuits, 2);
                        this.aiSuitFocus[playerIdx] = focusSuits;
                        this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(unlockedHand, focusSuits, playerIdx);
                    } else {
                        // Only need 1 ladder total â†’ move to triple
                        this.aiConstructionStage[playerIdx] = 'building_T';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // ğŸ’š v4.5.12: Track stage change
                        console.log(`  ğŸ¯ v4.5.12: ADVANCED to building_T (only 1 ladder needed)`);
                    }
                } else if (currentStage === 'building_L2' && lockedLadders >= 2) {
                    // ğŸ”§ v4.5.12: Check if we need a third ladder or a triple
                    if (needLadders >= 3) {
                        // Hand 7: Need 3 ladders â†’ build third ladder
                        this.aiConstructionStage[playerIdx] = 'building_L3';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // ğŸ’š v4.5.12: Track stage change
                        console.log(`  ğŸ¯ v4.5.12: ADVANCED to building_L3 (need third ladder)`);
                        // ğŸ”§ v4.5.12: Exclude suits from L1 and L2
                        const lockedSuits = this.aiLockedSequences[playerIdx]
                            .filter(s => s.type === 'ladder')
                            .map(s => s.suit);
                        console.log(`      ğŸš« v4.5.12: Excluding locked ladder suits: ${lockedSuits.join(', ')}`);
                        const availableSuits = ['â™ ', 'â™¥', 'â™¦', 'â™£'].filter(s => !lockedSuits.includes(s));
                        const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                        const focusSuits = this.selectSuitFocusFromSuits(unlockedHand, availableSuits, 2);
                        this.aiSuitFocus[playerIdx] = focusSuits;
                        this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(unlockedHand, focusSuits, playerIdx);
                    } else if (needTriples >= 1) {
                        // Hand 6: Need triple â†’ build triple
                        this.aiConstructionStage[playerIdx] = 'building_T';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // ğŸ’š v4.5.12: Track stage change
                        console.log(`  ğŸ¯ v4.5.12: ADVANCED to building_T (need triple)`);
                    } else {
                        // Edge case: already have everything
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  âœ… v4.5.12: READY TO PUBLISH! All requirements met!`);
                    }
                } else if (currentStage === 'building_L3' && lockedLadders >= 3) {
                    // ğŸ”§ v4.5.12: Third ladder complete (Hand 7)
                    const lockedTriples = this.aiLockedSequences[playerIdx].filter(s => s.type === 'triple').length;
                    if (lockedTriples >= needTriples && lockedLadders >= needLadders) {
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  âœ… v4.5.12: READY TO PUBLISH! All 3 ladders locked!`);
                    }
                } else if (currentStage === 'building_T') {
                    // Check if we have all requirements
                    const lockedTriples = this.aiLockedSequences[playerIdx].filter(s => s.type === 'triple').length;
                    if (lockedTriples >= needTriples && lockedLadders >= needLadders) {
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  âœ… v4.5.12: READY TO PUBLISH! All sequences complete!`);
                    }
                }
            }

            updateStagedConstructionTargets(playerIdx) {
                // Updates target cards and suit focus based on current stage and hand
                if (this.currentHand < 6) return; // Only for Hands 6-7
                
                const hand = this.playerHands[playerIdx];
                const stage = this.aiConstructionStage[playerIdx];
                
                if (stage === 'building_L1' || stage === 'building_L2') {
                    // Select best suits for ladder building
                    const focusSuits = this.selectSuitFocus(hand, 2);
                    this.aiSuitFocus[playerIdx] = focusSuits;
                    this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(hand, focusSuits, playerIdx, 3);
                }
            }

            couldExtendSequence(card, playerIdx) {
                // ğŸ¯ v4.0.7: Get flat view since we need to check individual cards
                const published = this.getFlatPublished(playerIdx);
                if (published.length === 0) return false;
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const publishedRankCounts = {};
                published.forEach(c => { publishedRankCounts[c.rank] = (publishedRankCounts[c.rank] || 0) + 1 });
                const hasActualTriples = Object.values(publishedRankCounts).some(count => count >= 3);
                const publishedSuits = {};
                published.forEach(c => { if (!publishedSuits[c.suit]) publishedSuits[c.suit] = []; publishedSuits[c.suit].push(c.getValue()) });
                const hasActualLadders = Object.values(publishedSuits).some(vals => vals.length >= 4);
                if (hasTriples || hasActualTriples) { if (publishedRankCounts[card.rank] >= 3) return true }

                if (hasLadders || hasActualLadders) {
                    // âœ… FIX 1B: Don't filter out "triple cards" - just get ALL cards of matching suit
                    // This handles cases where a rank appears in both triple and ladder (e.g., 8â™¦ 8â™£ 8â™¦ + 7â™¥ 8â™¥ 9â™¥ 10â™¥)
                    const sameSuit = published.filter(c => c.suit === card.suit);

                    console.log(`  ğŸ” FIX 1B: Checking ${card.toString()} against ${sameSuit.length} published ${card.suit} cards`);

                    if (sameSuit.length >= 4) {
                        const cardVal = card.getValue();
                        const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                        const ladders = []; let remainingValues = [...values];
                        const hasAce = values.includes(1); const hasJack = values.includes(11);
                        const hasQueen = values.includes(12); const hasKing = values.includes(13);

                        if (hasAce && hasJack && hasQueen && hasKing) {
                            // ğŸ”§ FIX 8 (v4.0.7): Extract ALL consecutive cards from King downward
                            // Bug: Previous code only checked v >= 11, missing cards like 9-10
                            const wrapLadder = [1];  // Start with Ace (value 1)
                            
                            // Get ALL non-ace cards sorted from high to low
                            const sortedCards = values.filter(v => v >= 2).sort((a, b) => b - a);
                            
                            // Start from King (13) and work downward, taking consecutive cards
                            let expectedValue = 13;
                            for (let val of sortedCards) {
                                if (val === expectedValue) {
                                    wrapLadder.push(val);
                                    expectedValue--;
                                } else if (val < expectedValue) {
                                    // Gap found - stop here (e.g., have K-Q but missing J)
                                    break;
                                }
                                // If val > expectedValue, skip it (shouldn't happen in sorted order)
                            }
                            
                            console.log(`  ğŸ”§ FIX 8: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                            ladders.push(wrapLadder);
                            remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                        }

                        if (remainingValues.length >= 4) {
                            let currentLadder = [remainingValues[0]];
                            for (let i = 1; i < remainingValues.length; i++) {
                                if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                    currentLadder.push(remainingValues[i]);
                                } else {
                                    if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                    currentLadder = [remainingValues[i]];
                                }
                            }
                            if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                        }
                        const canExtend = ladders.some(ladder => {
                            return this.canCardExtendLadder(cardVal, ladder);
                        });
                        if (canExtend) return true;
                    }
                }

                return false;
            }

            canAddToPublishedSequence(card, publishedSequence) {
                // ğŸ”§ PATCH S: Handle both structured sequence objects and legacy flat arrays
                const seq = publishedSequence.cards || publishedSequence;

                // For triples/quads - check if same rank
                if (seq.length >= 3 && seq.every(c => c.rank === seq[0].rank)) {
                    return card.rank === seq[0].rank;
                }

                // For ladders - use canCardExtendLadder (handles wrap-around!)
                if (seq.length >= 3) {
                    // ğŸ”§ PATCH S: Check suit consistency in sequence first
                    const suits = [...new Set(seq.map(c => c.suit))];
                    if (suits.length !== 1) {
                        // Mixed suits = not a valid ladder, probably a triple
                        return false;
                    }

                    const seqSuit = seq[0].suit;
                    if (card.suit !== seqSuit) return false;

                    // ğŸ› v4.5.12 FIX: Check for duplicate rank+suit in ladder
                    // Ladders need CONSECUTIVE ranks - can't have same rank twice!
                    const hasDuplicateRank = seq.some(c => c.rank === card.rank && c.suit === card.suit);
                    if (hasDuplicateRank) {
                        console.log(`%c  ğŸš« v4.5.12: Cannot add ${card.toString()} - rank already exists in ladder`, 'color:#ef4444;font-weight:bold');
                        return false;
                    }

                    // âœ… v4.3.2 FIX: Use canCardExtendLadder which handles wrap-around A-K-Q-J
                    const cardVal = card.getValue();
                    const ladderValues = seq.map(c => c.getValue());
                    return this.canCardExtendLadder(cardVal, ladderValues);
                }

                return false;
            }

            // ğŸ”§ PATCH S: Helper to separate flat published array into individual sequences
            // ğŸ¯ v3.0: Added smart caching to reduce logging spam from 50+ to 3 logs per turn
            separatePublishedSequences(flatArray, playerIdx) {
                if (!flatArray || flatArray.length === 0) return [];

                // ğŸ¯ v3.0: Check cache first
                const cacheKey = `p${playerIdx}_turn${this.turnCounter}`;
                
                // Reset cache if we're on a new turn
                if (this.sequenceSeparationCache.turnCounter !== this.turnCounter) {
                    this.sequenceSeparationCache.turnCounter = this.turnCounter;
                    this.sequenceSeparationCache.cache = {};
                }
                
                // Return cached result if available (prevents log spam)
                if (this.sequenceSeparationCache.cache[cacheKey]) {
                    return this.sequenceSeparationCache.cache[cacheKey];
                }

                // First time this turn for this player - do the work and log
                const handReq = this.handReqs[this.currentHand];
                const sequences = [];
                let currentIndex = 0;

                debugLog.info(`  ğŸ”§ PATCH S: Separating ${flatArray.length} cards for Hand ${this.currentHand}`);
                debugLog.info(`  ğŸ”§ PATCH S: Requirements: ${handReq.seqs.join(', ')}`);

                for (let req of handReq.seqs) {
                    if (currentIndex >= flatArray.length) break;

                    if (req === 'triple') {
                        // Take consecutive cards of same rank
                        const rank = flatArray[currentIndex].rank;
                        const triple = [];
                        while (currentIndex < flatArray.length &&
                            flatArray[currentIndex].rank === rank) {
                            triple.push(flatArray[currentIndex]);
                            currentIndex++;
                        }
                        if (triple.length >= 3) {
                            sequences.push({ type: 'triple', cards: triple });
                            debugLog.info(`  ğŸ”§ PATCH S: Found triple of ${rank} (${triple.length} cards)`);
                        }
                    } else if (req === 'ladder') {
                        // Take consecutive cards of same suit in sequence
                        const suit = flatArray[currentIndex].suit;
                        const ladder = [flatArray[currentIndex]];
                        currentIndex++;

                        // ğŸ¯ CRITICAL FIX: When building ladder, look ahead for ALL cards of same suit
                        // This handles cases where a card (e.g., 7â™ ) might be in a triple but ladder needs it
                        
                        // First pass: collect all remaining cards of same suit
                        const sameSuitCards = [];
                        for (let i = currentIndex; i < flatArray.length; i++) {
                            if (flatArray[i].suit === suit) {
                                sameSuitCards.push({ card: flatArray[i], originalIndex: i });
                            }
                        }
                        
                        // Sort by value to find consecutive runs
                        sameSuitCards.sort((a, b) => a.card.getValue() - b.card.getValue());
                        
                        // Build ladder by taking consecutive cards
                        let lastValue = ladder[0].getValue();
                        const usedIndices = new Set();
                        
                        for (let { card, originalIndex } of sameSuitCards) {
                            const cardValue = card.getValue();
                            
                            // Check if consecutive (or wrap K->A)
                            if (cardValue === lastValue + 1 || (lastValue === 13 && cardValue === 1)) {
                                ladder.push(card);
                                usedIndices.add(originalIndex);
                                lastValue = cardValue;
                            } else if (cardValue > lastValue + 1) {
                                // Gap found - stop building this ladder
                                break;
                            }
                        }
                        
                        // Update currentIndex to skip cards we used
                        // Advance past all cards we added to ladder
                        const maxUsedIndex = Math.max(...Array.from(usedIndices), currentIndex - 1);
                        currentIndex = maxUsedIndex + 1;

                        if (ladder.length >= 4) {
                            sequences.push({ type: 'ladder', cards: ladder });
                            debugLog.info(`  ğŸ”§ PATCH S: Found ladder of ${suit} (${ladder.length} cards): ${ladder.map(c => c.rank).join('-')}`);
                        }
                    }
                }

                debugLog.info(`  ğŸ”§ PATCH S: Separated into ${sequences.length} sequences`);
                
                // ğŸ¯ v3.0: Cache the result for this turn
                this.sequenceSeparationCache.cache[cacheKey] = sequences;
                
                return sequences;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ¤– AI DECISION ENGINE - v3.0 Clean Architecture
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // This section contains the core AI logic for card evaluation,
            // discard selection, and strategic decision-making.
            //
            // Key Methods:
            // - evaluateCard(): Scores a card's value for pickup decisions
            // - findWorstCard(): Selects the optimal card to discard
            // - couldExtendSequence(): Checks if card helps opponent
            // - canAddToPublishedSequence(): Validates extension legality
            //
            // All bug fixes from v2.5.0 are preserved:
            // âœ… FIX 1: Ladder extension (both high/low ends)
            // âœ… PATCH G: AI win detection (extend own sequences)
            // âœ… PATCH K: Enhanced endgame protection
            // âœ… PATCH L: Smart pair valuation
            // âœ… PATCH R/S: Universal discard safety (never help opponents)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            evaluateCard(card, pIdx) {
                const hand = this.playerHands[pIdx];
                let val = 0;

                const sameRank = hand.filter(c => c.rank === card.rank).length;
                const sameSuit = hand.filter(c => c.suit === card.suit);

                // ğŸ¯ PATCH L: Smart pair valuation based on game type
                const req = this.handReqs[this.currentHand].seqs;
                const hasOnlyTriples = req.every(s => s === 'triple');

                // Count existing pairs in hand
                const rankCounts = {};
                hand.forEach(c => rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1);
                const numPairs = Object.values(rankCounts).filter(count => count === 2).length;

                if (sameRank >= 2) {
                    // Already have 2+ of this rank - GREAT for triples!
                    val += 20;
                } else if (sameRank === 1) {
                    // Would CREATE a new pair
                    if (hasOnlyTriples && numPairs >= 4) {
                        // Triple game with 4+ pairs already - PENALIZE new pairs
                        console.log(`  â†’ PATCH L: Penalizing ${card.toString()} - already have ${numPairs} pairs in triple game`);
                        val -= 10;  // Negative value = don't want this card
                    } else if (numPairs >= 2 && !hasOnlyTriples) {
                        // Mixed game with 2+ pairs - slight penalty
                        val += 3;  // Reduced from 8
                    } else {
                        // Normal pair value
                        val += 8;
                    }
                }

                if (sameSuit.length >= 3) {
                    const values = sameSuit.map(c => c.getValue());
                    const cardVal = card.getValue();
                    const allValues = [...values, cardVal].sort((a, b) => a - b);
                    let maxConsecutive = 1;
                    let currentConsecutive = 1;
                    for (let i = 1; i < allValues.length; i++) {
                        if (allValues[i] === allValues[i - 1] + 1) {
                            currentConsecutive++;
                            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                        } else if (allValues[i] !== allValues[i - 1]) {
                            currentConsecutive = 1;
                        }
                    }
                    if (maxConsecutive >= 4) val += 25;
                    else if (maxConsecutive === 3) val += 15;
                    else if (maxConsecutive === 2) val += 5;
                } else if (sameSuit.length >= 2) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 6;
                } else if (sameSuit.length === 1) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 3;
                }
                if (this.publishedSequences[pIdx].length > 0) {
                    if (this.couldExtendSequence(card, pIdx)) val += 100;
                }
                // ğŸ¯ v4.2.7 FIX: Cards that extend ANY published sequence are valuable!
                // Published sequences are global resources - extending them reduces YOUR hand!
                for (let p = 0; p < this.players; p++) {
                    if (this.publishedSequences[p].length === 0) continue;
                    if (p === pIdx) continue;
                    if (this.couldExtendSequence(card, p)) {
                        val += 30;  // ALWAYS good - you'll play it to extend and reduce your hand!
                    }
                }
                return val;
            }

            findWorstCard(pIdx) {
                let hand = this.playerHands[pIdx];  // ğŸ› v4.0.7: Changed to 'let' to allow reassignment

                // ğŸ”’ v4.5.12: PROTECT LOCKED SEQUENCES from discard!
                if (this.currentHand >= 6 && this.aiLockedSequences[pIdx].length > 0) {
                    console.log(`  ğŸ”’ v4.5.12: Protecting ${this.aiLockedSequences[pIdx].length} locked sequences from discard`);
                    
                    // Filter out ALL cards that are in locked sequences
                    const unlockedCards = hand.filter(card => !this.isSequenceLocked(pIdx, card));
                    
                    console.log(`      Total cards: ${hand.length}, Unlocked: ${unlockedCards.length}`);
                    
                    if (unlockedCards.length > 0) {
                        // Only consider unlocked cards for discard
                        hand = unlockedCards;
                        console.log(`      âœ… Will only discard from unlocked cards`);
                    } else {
                        console.log(`      âš ï¸ All cards are locked! Using full hand (emergency)`);
                    }
                }

                // ğŸ¯ PATCH LADDER-DISCARD: In ladder games, prioritize keeping sequential cards of same suit!
                const req = this.handReqs[this.currentHand].seqs;
                const needsLadders = req.some(s => s === 'ladder');
                
                // ğŸ¯ v4.2.7 FIX: Calculate minimum cards needed to publish
                const minCardsNeeded = req.reduce((sum, s) => sum + (s === 'triple' ? 3 : 4), 0);
                
                if (needsLadders && !this.publishedSequences[pIdx].length) {
                    // ğŸ¯ v4.2.7 CRITICAL FIX: Check if AI can ACTUALLY publish, not just card count!
                    // If hand size < minimum OR can't form valid sequences, skip PATCH LADDER-DISCARD
                    let canPublish = false;
                    if (hand.length >= minCardsNeeded) {
                        // Check if we have enough valid sequences
                        const seqs = this.findSequences(hand);
                        const needTriples = req.filter(s => s === 'triple').length;
                        const needLadders = req.filter(s => s === 'ladder').length;
                        const hasTriples = seqs.triples.length;
                        const hasLadders = seqs.ladders.length;
                        canPublish = (hasTriples >= needTriples && hasLadders >= needLadders);
                    }
                    
                    if (!canPublish) {
                        console.log(`%cğŸš¨ v4.2.7: Can't publish yet (need ${minCardsNeeded} cards, have ${hand.length}) - must keep buying! Skipping PATCH LADDER-DISCARD`, 'color: #ef4444; font-weight: bold;');
                        // Fall through to normal evaluation logic below
                    } else {
                        // Before publishing, focus on building ladders
                        console.log(`%cğŸ¯ PATCH LADDER-DISCARD: Evaluating cards for ladder building`, 'color: #3498db;');
                        
                        // Group cards by suit and find sequential runs
                        const cardsBySuit = {};
                        hand.forEach(card => {
                            if (!cardsBySuit[card.suit]) cardsBySuit[card.suit] = [];
                            cardsBySuit[card.suit].push(card);
                        });
                        
                        // Score each card based on ladder potential
                        const cardScores = hand.map(card => {
                            const sameSuitCards = cardsBySuit[card.suit];
                            if (sameSuitCards.length < 2) {
                                // Isolated card - low score (good to discard)
                                return { card, score: 0, reason: 'isolated' };
                            }
                            
                            // Check if part of sequential run
                            const values = sameSuitCards.map(c => c.value).sort((a, b) => a - b);
                            let inRun = false;
                            let runLength = 0;
                            
                            for (let i = 0; i < values.length; i++) {
                                if (values[i] === card.value) {
                                    // Check neighbors
                                    let run = 1;
                                    // Check left
                                    for (let j = i - 1; j >= 0 && values[j] === values[j + 1] - 1; j--) run++;
                                    // Check right
                                    for (let j = i + 1; j < values.length && values[j] === values[j - 1] + 1; j++) run++;
                                    
                                    if (run >= 3) {
                                        inRun = true;
                                        runLength = run;
                                        break;
                                    }
                                }
                            }
                            
                            if (inRun) {
                                return { card, score: runLength * 10, reason: `in ${runLength}-run` };
                            } else if (sameSuitCards.length >= 3) {
                                return { card, score: sameSuitCards.length * 2, reason: `${sameSuitCards.length} same suit` };
                            } else {
                                return { card, score: 1, reason: 'pair only' };
                            }
                        });
                        
                        // Sort by score (lowest = worst = discard first)
                        cardScores.sort((a, b) => a.score - b.score);
                        
                        // ğŸ¯ v4.2.7 FIX: Add discard safety check - don't help opponents!
                        // Filter out cards that would extend opponent sequences when they're close to winning
                        const safeCardScores = cardScores.filter(scoreObj => {
                            for (let p = 0; p < this.players; p++) {
                                if (p === pIdx) continue; // Skip self
                                if (this.publishedSequences[p].length === 0) continue; // Skip unpublished opponents
                                
                                const opponentHandSize = this.playerHands[p].length;
                                if (opponentHandSize <= 4 && this.couldExtendSequence(scoreObj.card, p)) {
                                    console.log(`  ğŸš« v4.2.7: Can't discard ${scoreObj.card.toString()} - would help Player ${p} (${opponentHandSize} cards)`);
                                    return false; // Not safe - opponent is close to winning
                                }
                            }
                            return true; // Safe to discard
                        });
                        
                        // If we filtered out all cards, fall back to original list (edge case)
                        const finalScores = safeCardScores.length > 0 ? safeCardScores : cardScores;
                        
                        // Discard lowest scoring SAFE card (least useful for ladders, won't help opponents)
                        const worst = finalScores[0];
                        console.log(`%cğŸ¯ PATCH LADDER-DISCARD: Discarding ${worst.card.toString()} (${worst.reason}, score: ${worst.score})`, 'color: #e67e22;');
                        return worst.card;
                    }
                }

                // ğŸ† v4.0.7 FIX: ALWAYS protect cards that extend MY OWN sequences
                debugLog.decision(`ğŸ¯ v4.0.7: Checking if any cards extend MY sequences (ALWAYS)`);

                const myPublished = this.publishedSequences[pIdx];
                if (myPublished && myPublished.length > 0) {
                    // Find ALL cards that can extend my own sequences
                    const cardsExtendingOwn = hand.filter(card => 
                        myPublished.some(pubSeq => this.canAddToPublishedSequence(card, pubSeq))
                    );

                    if (cardsExtendingOwn.length > 0) {
                        debugLog.decision(`ğŸ† v4.0.7 CRITICAL: Found ${cardsExtendingOwn.length} card(s) that extend MY sequences:`);
                        cardsExtendingOwn.forEach(c => debugLog.decision(`   - ${c.toString()} extends my sequence`));

                        // NEVER discard cards that extend my own sequences!
                        const nonExtendingCards = hand.filter(c => !cardsExtendingOwn.includes(c));

                        if (nonExtendingCards.length > 0) {
                            debugLog.decision(`ğŸ† v4.0.7: Discarding from ${nonExtendingCards.length} non-extending cards`);
                            // Pick worst from cards that DON'T extend my sequences
                            hand = nonExtendingCards; // Override working hand for rest of logic
                        } else {
                            // ALL cards extend my sequences (rare case)
                            // This means tryAddToPublished should have played them already
                            // But if we're here, pick the least valuable extension
                            debugLog.decision(`âš ï¸ v4.0.7: ALL cards extend my sequences - picking least valuable`);
                        }
                    }

                    // ğŸ† PATCH G: Check if AI can WIN by extending sequences (when close to winning)
                    if (hand.length <= 3) {
                        debugLog.decision(`PATCH G: Checking if AI can win this turn (${hand.length} cards)`);
                        
                        // Check if ANY card can extend my sequences and leave me with â‰¤1 cards
                        for (let card of hand) {
                            const canExtend = myPublished.some(pubSeq => this.canAddToPublishedSequence(card, pubSeq));

                            if (canExtend && hand.length === 2) {
                                // Playing this card wins the game!
                                debugLog.decision(`ğŸ† CRITICAL: ${card.toString()} extends my sequence - WINNING MOVE! Keeping it!`);
                                // Return a DIFFERENT card (not the winning one)
                                const otherCards = hand.filter(c => c !== card);
                                if (otherCards.length > 0) {
                                    debugLog.decision(`ğŸ† Discarding ${otherCards[0].toString()} instead to keep winning card`);
                                    return otherCards[0];
                                }
                            }
                        }
                    }
                }

                // ğŸ¯ PATCH K: Enhanced danger detection - protect before publishing too
                debugLog.info(`  â†’ PATCH K: Checking danger with published sequences (expanded)`);

                // ğŸ”§ PATCH S: UNIVERSAL CHECK - Always filter out cards that extend ANY opponent's published sequences
                // ğŸ¯ v4.0.7 FIX: This should apply ESPECIALLY when all players published (racing!)
                const allPlayersPublished = this.publishedSequences.every(seq => seq.length > 0);
                const isRacing = allPlayersPublished && this.publishedSequences[pIdx].length > 0;
                
                if (isRacing) {
                    debugLog.info(`  ğŸ v4.0.7: RACING MODE - All players published! Defensive discard engaged.`);
                }
                
                debugLog.info(`  ğŸ”§ v4.0.7: Universal discard safety - checking all opponents`);
                const universallySafeCards = hand.filter(c => {
                    for (let p = 0; p < this.players; p++) {
                        if (p === pIdx) continue; // Skip self

                        const opponentSequences = this.publishedSequences[p];
                        if (opponentSequences && opponentSequences.length > 0) {
                            // ğŸ¯ v4.0.7: DIRECT ACCESS - already stored as 2D array!
                            for (let seq of opponentSequences) {
                                if (this.canAddToPublishedSequence(c, seq)) {
                                    const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                    const opponentCards = this.playerHands[p].length;
                                    
                                    // ğŸ¯ CRITICAL: ALWAYS block if opponent has â‰¤3 cards (winning move!)
                                    if (opponentCards <= 3) {
                                        debugLog.info(`  ğŸš« CRITICAL: ${c.toString()} extends ${playerName}'s sequence (${opponentCards} cards) - WOULD LET THEM WIN!`);
                                        return false;
                                    }
                                    
                                    // ğŸ¯ v4.0.7: Be defensive in racing mode or if opponent close to winning
                                    if (isRacing || opponentCards <= 5) {
                                        debugLog.info(`  ğŸš« v4.0.7: ${c.toString()} extends ${playerName}'s sequence (${opponentCards} cards) - BLOCKING!`);
                                        return false; // Not safe - helps opponent
                                    }
                                }
                            }
                        }
                    }
                    return true; // Safe - doesn't extend any opponent's sequences
                });

                // Use filtered cards if we found any unsafe ones
                let workingHand = hand;
                if (universallySafeCards.length > 0 && universallySafeCards.length < hand.length) {
                    const blockedCount = hand.length - universallySafeCards.length;
                    debugLog.info(`  ğŸ›¡ï¸ v4.0.7: Defensive filter removed ${blockedCount} dangerous cards`);
                    workingHand = universallySafeCards;
                } else if (universallySafeCards.length === 0) {
                    // ğŸ¯ v4.2.7 FIX: ALL cards are dangerous - pick LEAST dangerous!
                    debugLog.warn(`  âš ï¸ v4.2.7: ALL ${hand.length} cards extend opponents - picking least dangerous`);
                    
                    // Build danger map: which opponents does each card help?
                    const dangerMap = hand.map(card => {
                        const helpsOpponents = [];
                        for (let p = 0; p < this.players; p++) {
                            if (p === pIdx) continue;
                            const opponentSequences = this.publishedSequences[p];
                            if (opponentSequences && opponentSequences.length > 0) {
                                for (let seq of opponentSequences) {
                                    if (this.canAddToPublishedSequence(card, seq)) {
                                        helpsOpponents.push({
                                            player: p,
                                            handSize: this.playerHands[p].length,
                                            name: p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot')
                                        });
                                        break; // Only count once per opponent
                                    }
                                }
                            }
                        }
                        return { card, helpsOpponents };
                    });
                    
                    // Sort by danger level (prefer helping opponents with MORE cards = farther from winning)
                    dangerMap.sort((a, b) => {
                        // If one card doesn't help anyone (shouldn't happen here, but safety check)
                        if (a.helpsOpponents.length === 0) return -1;
                        if (b.helpsOpponents.length === 0) return 1;
                        
                        // Get minimum opponent hand size that each card helps
                        const minOpponentA = Math.min(...a.helpsOpponents.map(o => o.handSize));
                        const minOpponentB = Math.min(...b.helpsOpponents.map(o => o.handSize));
                        
                        // Prefer card that helps opponent with MORE cards (farther from winning)
                        return minOpponentB - minOpponentA;
                    });
                    
                    // Pick least dangerous card
                    const leastDangerous = dangerMap[0];
                    debugLog.warn(`  ğŸ¯ v4.2.7: Least dangerous = ${leastDangerous.card.toString()}`);
                    leastDangerous.helpsOpponents.forEach(opp => {
                        debugLog.warn(`     Helps ${opp.name} (${opp.handSize} cards)`);
                    });
                    
                    // Return immediately - don't continue with other logic
                    return leastDangerous.card;
                }

                // THEN do critical/midgame specific checks
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue; // Skip self
                    const opponentCards = this.playerHands[p].length;
                    const opponentPublished = this.publishedSequences[p].length > 0;
                    const iHavePublished = this.publishedSequences[pIdx].length > 0;

                    // SCENARIO 1: Critical endgame (original logic)
                    const criticalEndgame = opponentPublished && opponentCards <= 2;

                    // SCENARIO 2: I haven't published yet, opponent is mid-game threat
                    const midGameThreat = !iHavePublished && opponentPublished && opponentCards <= 4;

                    if (criticalEndgame || midGameThreat) {

                        const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                        const scenario = criticalEndgame ? 'CRITICAL' : 'MID-GAME THREAT';
                        debugLog.decision(`PATCH K: ${scenario} - ${playerName} has ${opponentCards} card(s)${opponentPublished ? ' and published' : ''}!`);

                        // ğŸ¯ PATCH O: Enhanced safety check with turn order priority

                        const safeCards = workingHand.filter(c => {

                            // ğŸ”§ PATCH R (v4.0.7): Check if card extends opponent's published sequences
                            const opponentPublished = this.publishedSequences[p];
                            if (opponentPublished && opponentPublished.length > 0) {
                                // ğŸ¯ v4.0.7: opponentPublished is already 2D [[seq1], [seq2], ...]
                                for (let seq of opponentPublished) {
                                    // seq is already an array of cards
                                    if (this.canAddToPublishedSequence(c, seq)) {
                                        const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                        debugLog.info(`  â†’ PATCH R: ${c.toString()} can extend ${playerName}'s published sequence - NOT SAFE`);
                                        return false; // Not safe - helps opponent extend published sequences
                                    }
                                }
                            }
                            
                            // Check if extends opponent's hand
                            if (this.couldExtendSequence(c, p)) return false;

                            // Check published sequences with turn order awareness
                            // After pIdx discards, who gets buy window? Next player!
                            const nextPlayer = (pIdx + 1) % this.players;

                            // CRITICAL: Check if helps players who come BEFORE current player in buy window order
                            // Buy window order after pIdx discards: nextPlayer, then nextPlayer+1, etc.
                            for (let offset = 0; offset < this.players - 1; offset++) {
                                const buyWindowPlayer = (pIdx + 1 + offset) % this.players;
                                const published = this.publishedSequences[buyWindowPlayer];

                                if (published && published.length > 0) {
                                    for (let pubSeq of published) {
                                        if (this.canAddToPublishedSequence(c, pubSeq)) {
                                            const playerName = buyWindowPlayer === 0 ? 'Human' : (buyWindowPlayer === 1 ? 'Habot' : 'Jabot');
                                            const priority = offset === 0 ? 'FIRST' : 'SECOND';
                                            debugLog.info(`  â†’ PATCH O: ${c.toString()} helps ${playerName} (${priority} in buy window) - NOT SAFE`);
                                            return false; // Not safe - helps player with buy window priority
                                        }
                                    }
                                }
                            }
                            return true; // Safe - doesn't help anyone in buy window order
                        });

                        if (safeCards.length > 0) {
                            // Discard highest penalty from safe cards
                            const worst = safeCards.reduce((max, c) =>
                                c.getPenaltyValue() > max.getPenaltyValue() ? c : max
                            );
                            debugLog.decision(`PATCH K: Safe discard: ${worst.toString()} (doesn't help ${playerName})`);
                            return worst;
                        } else {
                            debugLog.warn(`  â†’ PATCH K: WARNING - ALL cards help ${playerName}! Using least valuable...`);
                            // If all cards help, pick the least strategically valuable
                            let minValue = this.evaluateCard(hand[0], pIdx);
                            let worst = hand[0];
                            hand.forEach(c => {
                                const val = this.evaluateCard(c, pIdx);
                                if (val < minValue) {
                                    minValue = val;
                                    worst = c;
                                }
                            });
                            return worst;
                        }
                    }
                }

                const isLadderOnlyHand = this.handReqs[this.currentHand].seqs.every(seq => seq === 'ladder');
                if (isLadderOnlyHand && this.turnCounter > 80 && hand.length >= 15) {
                    const potentialLadders = {};
                    hand.forEach(card => { if (!potentialLadders[card.suit]) potentialLadders[card.suit] = []; potentialLadders[card.suit].push(card.getValue()) });
                    const keepCards = new Set();
                    Object.entries(potentialLadders).forEach(([suit, values]) => {
                        const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
                        for (let i = 0; i < uniqueValues.length; i++) {
                            let runLength = 1;
                            let currentValue = uniqueValues[i];
                            while (i + runLength < uniqueValues.length && uniqueValues[i + runLength] === currentValue + runLength) runLength++;
                            if (runLength >= 3) {
                                for (let k = 0; k < runLength; k++) {
                                    const cardValue = currentValue + k;
                                    const cardsWithValue = hand.filter(c => c.suit === suit && c.getValue() === cardValue);
                                    cardsWithValue.forEach(c => keepCards.add(c.id));
                                }
                            }
                        }
                    });
                    const dumpCandidates = hand.filter(c => !keepCards.has(c.id));
                    if (dumpCandidates.length > 0) {
                        const worst = dumpCandidates.reduce((max, c) => c.getPenaltyValue() > max.getPenaltyValue() ? c : max);
                        return worst;
                    }
                }
                const hasPublished = this.publishedSequences[pIdx].length > 0;
                if (!hasPublished) {
                    const othersPublished = this.publishedSequences.some((seq, idx) => idx !== pIdx && seq.length > 0);
                    const othersLowCards = this.playerHands.some((h, idx) => idx !== pIdx && h.length <= 2);
                    if (othersPublished && othersLowCards) {
                        if (this.turnCounter > 120) {
                            const highestPenalty = hand.reduce((max, card) => card.getPenaltyValue() > max.getPenaltyValue() ? card : max);
                            return highestPenalty;
                        }
                        const seqs = this.findSequences(hand);
                        const inSequences = new Set();
                        seqs.triples.forEach(t => t.forEach(c => inSequences.add(c.id)));
                        seqs.ladders.forEach(l => l.forEach(c => inSequences.add(c.id)));
                        const safeToDump = hand.filter(c => {
                            if (inSequences.has(c.id)) return false;
                            for (let p = 0; p < this.players; p++) {
                                if (p === pIdx) continue;
                                if (this.playerHands[p].length <= 2 && this.couldExtendSequence(c, p)) return false;
                            }
                            return true;
                        });
                        if (safeToDump.length > 0) {
                            const highPenalty = safeToDump.sort((a, b) => b.getPenaltyValue() - a.getPenaltyValue())[0];
                            return highPenalty;
                        }
                        const pairs = {};
                        hand.forEach(c => { pairs[c.rank] = (pairs[c.rank] || []); pairs[c.rank].push(c) });
                        const pairCards = [];
                        Object.entries(pairs).forEach(([rank, cards]) => { if (cards.length === 2) pairCards.push(...cards) });
                        if (pairCards.length > 0) {
                            const worst = pairCards.reduce((min, c) => c.getValue() < min.getValue() ? c : min);
                            return worst;
                        }
                        const notInSeq = hand.filter(c => !inSequences.has(c.id));
                        if (notInSeq.length > 0) {
                            const lowest = notInSeq.reduce((min, c) => c.getPenaltyValue() < min.getPenaltyValue() ? c : min);
                            return lowest;
                        }
                    }
                }
                const rankCounts = {};
                hand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { hand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[pIdx].length > 0) {
                    hand.forEach(c => { if (this.couldExtendSequence(c, pIdx)) protectedCards.add(c.id) });
                }
                const criticalDanger = new Set();
                const moderateDanger = new Set();
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue;
                    if (this.publishedSequences[p].length === 0) continue;
                    const opponentCards = this.playerHands[p].length;
                    hand.forEach(c => {
                        if (this.couldExtendSequence(c, p)) {
                            if (opponentCards <= 2) { criticalDanger.add(c.id); protectedCards.add(c.id) }
                            else if (opponentCards <= 4) { moderateDanger.add(c.id); protectedCards.add(c.id) }
                        }
                    });
                }
                const safeCards = hand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worst = safeCards[0];
                    let minVal = this.evaluateCard(worst, pIdx);
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; worst = c }
                    });
                    return worst;
                }
                const nonCriticalCards = hand.filter(c => !criticalDanger.has(c.id));
                if (nonCriticalCards.length > 0) {
                    const cardsNotExtendingOwn = [];
                    const cardsExtendingOwn = [];
                    nonCriticalCards.forEach(c => {
                        if (this.couldExtendSequence(c, pIdx)) cardsExtendingOwn.push(c);
                        else cardsNotExtendingOwn.push(c);
                    });
                    if (cardsNotExtendingOwn.length > 0) {
                        let worst = cardsNotExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsNotExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                    if (cardsExtendingOwn.length > 0) {
                        let worst = cardsExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                }
                let leastUrgent = hand[0];
                let maxOpponentCards = 0;
                hand.forEach(c => {
                    for (let p = 0; p < this.players; p++) {
                        if (p === pIdx) continue;
                        if (this.couldExtendSequence(c, p)) {
                            const opponentCards = this.playerHands[p].length;
                            if (opponentCards > maxOpponentCards) { maxOpponentCards = opponentCards; leastUrgent = c }
                        }
                    }
                });
                if (maxOpponentCards === 0) {
                    let minVal = this.evaluateCard(leastUrgent, pIdx);
                    hand.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; leastUrgent = c }
                    });
                }
                return leastUrgent;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // END OF AI DECISION ENGINE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            shouldAllowBuy(ai, discardCard) {
                const buysRemaining = this.playerBuys[ai];
                if (buysRemaining === 0) return false;
                const hand = this.playerHands[ai];
                const buysUsed = (this.currentHand === 7 ? 2 : 3) - buysRemaining;
                const seqs = this.findSequences(hand);
                const hasTriple = seqs.triples.length > 0;
                const hasLadder = seqs.ladders.length > 0;
                const strategicValue = this.evaluateCard(discardCard, ai);
                const penaltyValue = discardCard.getPenaltyValue();
                const cardValue = strategicValue + penaltyValue;
                switch (this.currentHand) {
                    case 1: if (buysUsed >= 2) return false; if (!hasTriple && cardValue < 30) return false; return hasTriple || cardValue >= 30;
                    case 2: if (buysUsed >= 2) return false; const hasSequence = hasTriple || hasLadder; return hasSequence && cardValue >= 25;
                    case 3:
                        if (buysUsed < 2) return cardValue >= 35;
                        if (buysUsed === 2) { const has3CardProgress = this.hasThreeCardLadderProgress(hand); return has3CardProgress && cardValue >= 30 }
                        return false;
                    case 4: if (buysUsed >= 2) return false; return hasTriple && cardValue >= 25;
                    case 5: if (buysUsed >= 2) return false; const hasAnySequence = hasTriple || hasLadder; return hasAnySequence && cardValue >= 30;
                    case 6:
                    case 7:
                        // ğŸ—ï¸ v4.5.12: STAGED CONSTRUCTION STRATEGY
                        // Build sequences SEQUENTIALLY: L1 â†’ L2 â†’ T (not parallel!)
                        
                        const stage = this.aiConstructionStage[ai];
                        const aiName = ai === 1 ? 'Habot' : 'Jabot';
                        
                        console.log(`  ğŸ—ï¸ v4.5.12 ${aiName} BUY CHECK - Stage: ${stage}, Buys used: ${buysUsed}/2-3`);
                        
                        // Stage 1 & 2: Building Ladders - TARGET-BASED BUYING
                        if (stage === 'building_L1' || stage === 'building_L2') {
                            // Update targets if needed
                            if (this.aiTargetCards[ai].length === 0 || this.aiSuitFocus[ai].length === 0) {
                                this.updateStagedConstructionTargets(ai);
                            }
                            
                            const targets = this.aiTargetCards[ai];
                            const cardString = `${discardCard.rank}${discardCard.suit}`;
                            
                            // Is this one of our target cards?
                            const isTarget = targets.includes(cardString);
                            
                            console.log(`      Targets: ${targets.join(', ')}`);
                            console.log(`      Card: ${cardString} - Is target? ${isTarget}`);
                            
                            if (isTarget) {
                                console.log(`      âœ… BUY! This is a target card for ${stage}`);
                                return true; // BUY immediately if it's a target!
                            }
                            
                            // ğŸ’š v4.5.12: AGGRESSIVE BUY MODE - Lower standards when stuck with scattered cards
                            const aggressiveMode = this.isAggressiveBuyMode(ai);
                            
                            if (aggressiveMode) {
                                // In aggressive mode: Accept ANY card in focus suits!
                                const focusSuits = this.aiSuitFocus[ai];
                                const inFocusSuit = focusSuits.includes(discardCard.suit);
                                
                                if (inFocusSuit && cardValue >= 15) {
                                    console.log(`      ğŸ’š AGGRESSIVE BUY! In focus suit ${discardCard.suit}, accumulating cards`);
                                    return true;
                                }
                                
                                // Also more lenient on high-value cards
                                if (cardValue >= 25) {
                                    console.log(`      ğŸ’š AGGRESSIVE BUY! High-value card, trying anything`);
                                    return true;
                                }
                            }
                            
                            // Not a target - check if it's still valuable for ladder building
                            if (buysUsed === 0 && cardValue >= 20) {
                                // First buy - be more flexible to get more cards
                                const sameSuit = hand.filter(c => c.suit === discardCard.suit);
                                if (sameSuit.length >= 2) {
                                    console.log(`      âœ… First buy - accept valuable card in promising suit`);
                                    return true;
                                }
                            }
                            
                            console.log(`      âŒ REJECT - not a target, not valuable enough`);
                            return false;
                        }
                        
                        // Stage 3: Building Triple - EASIER, just need matching ranks
                        if (stage === 'building_T') {
                            const completesTriple = hand.filter(c => c.rank === discardCard.rank).length >= 2;
                            
                            console.log(`      Checking triple: have ${hand.filter(c => c.rank === discardCard.rank).length} ${discardCard.rank}s`);
                            console.log(`      Would complete triple? ${completesTriple}`);
                            
                            if (completesTriple && cardValue >= 10) {
                                console.log(`      âœ… BUY! Completes triple for publishing`);
                                return true;
                            }
                            
                            // Also accept cards that start triples if we have buys left
                            const pairCount = hand.filter(c => c.rank === discardCard.rank).length;
                            if (pairCount === 1 && buysUsed < 1 && cardValue >= 15) {
                                console.log(`      âœ… BUY! Forms pair toward triple`);
                                return true;
                            }
                            
                            console.log(`      âŒ REJECT - doesn't help triple`);
                            return false;
                        }
                        
                        // Ready to publish or unknown stage - don't buy
                        console.log(`      âŒ Stage ${stage} - no buying`);
                        return false;
                    default: return false;
                }
            }

            shouldRequestBuy(ai) {
                if (this.playerBuys[ai] === 0) return false;
                if (this.publishedSequences[ai].length > 0) return false;
                const humanPublished = this.publishedSequences[0].length > 0;
                if (humanPublished) return false;
                const othersPublishedWith3Plus = this.publishedSequences.some((seq, idx) => {
                    if (idx === ai) return false;
                    return seq.length > 0 && this.playerHands[idx].length >= 3;
                });
                if (othersPublishedWith3Plus && this.playerHands[ai].length >= 3) return true;
                return false;
            }

            setAIStatus(aiId, message) { const actionElement = document.getElementById(`${aiId}-action`); if (actionElement) actionElement.textContent = message }

            // âœ… FIX 3: Reduced buy window after publishing (5s instead of 10s)
            startBuyWindow(card, discardingPlayer) {
                if (!card) { console.log(`%câš ï¸ Cannot open buy window - no card provided`, 'color: #ff6600; font-weight: bold;'); return }
                const buyWindowPlayer = (discardingPlayer + 2) % 3;
                
                // ğŸ¯ CRITICAL: Don't open buy window if player has no buys left!
                if (this.playerBuys[buyWindowPlayer] <= 0) {
                    const playerNames = ['Human', 'Habot', 'Jabot'];
                    console.log(`%câ­ï¸ SKIP: ${playerNames[buyWindowPlayer]} has no buys left (${this.playerBuys[buyWindowPlayer]}) - no buy window`, 'color: #9e9e9e; font-weight: bold;');
                    
                    // ğŸ› v4.0.7 FIX: Advance to next player when skipping buy window!
                    const nextPlayer = (this.currentPlayer + 1) % this.players;
                    console.log(`%câ–¶ï¸ Advancing to next player: Player ${nextPlayer}`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        this.currentPlayer = nextPlayer;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) {
                            this.aiTurn();
                        }
                    }, 500);
                    return;
                }
                
                if (this.buyWindow.active) this.closeBuyWindow();

                // ğŸ¯ v4.0.7: Longer buy window for humans (8s), shorter for AI (3s)
                const duration = buyWindowPlayer === 0 ? 8000 : 3000;
                console.log(`%câ±ï¸ v4.0.7: Buy window duration: ${duration / 1000}s (${buyWindowPlayer === 0 ? 'Human' : 'AI'})`, 'color: #ffc107; font-weight: bold;');

                this.buyWindow.active = true;
                this.buyWindow.card = card;
                this.buyWindow.discardingPlayer = discardingPlayer;
                this.buyWindow.buyWindowPlayer = buyWindowPlayer;
                this.buyWindow.expiresAt = Date.now() + duration; // âœ… FIX 3: Variable duration

                const playerNames = ['Human', 'Habot', 'Jabot'];
                console.log(`%cğŸ”” Buy window opened for ${playerNames[buyWindowPlayer]} (${card.toString()}) - ${duration / 1000}s`, 'color: #ffc107; font-weight: bold;');
                if (buyWindowPlayer === 0) document.getElementById('buyBtn').disabled = false;
                this.updateBuyTimer();
            }


            checkAndOpenBuyWindowAfterDiscard(currentAI, statusId) {
                const aiName = currentAI === 1 ? 'Habot' : 'Jabot';

                // Check if we have a valid lastDiscard to create buy window for
                if (!this.lastDiscard || this.lastDiscardByPlayer === -1) {
                    console.log(`%c  â­ï¸  No buy window: no valid lastDiscard`, 'color: #95a5a6;');
                    return false; // No buy window opened
                }

                const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                console.log(`%c  ğŸ’¡ Buy window check after ${aiName} discard`, 'color: #9b59b6; font-weight: bold;');
                console.log(`     lastDiscard: ${this.lastDiscard.toString()}`);
                console.log(`     lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);
                console.log(`     buyWindowPlayer: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                // Validate buy window conditions
                if (buyWindowPlayer === currentAI || buyWindowPlayer === this.lastDiscardByPlayer) {
                    console.log(`     âŒ Buy window blocked: invalid player configuration`);
                    return false;
                }

                console.log(`     âœ… Opening buy window!`);

                // Save next player info for after buy window closes
                const nextPlayer = (this.currentPlayer + 1) % this.players;
                this.buyWindow.pendingNextPlayer = nextPlayer;

                // Open the buy window
                this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);

                // Handle AI buy window if needed
                if (buyWindowPlayer > 0) {
                    this.handleAIBuyWindow(buyWindowPlayer);
                }

                // Clean up status after a delay
                if (statusId) {
                    setTimeout(() => { document.getElementById(`${statusId}-status`).classList.remove('active') }, 800);  // ğŸ¯ v2.5.0: Faster (was 2000ms)
                }

                return true; // Buy window was opened
            }

            closeBuyWindow(reason = 'expired') {
                if (!this.buyWindow.active) return;

                const wasActive = this.buyWindow.active;
                const pendingDraw = this.buyWindow.pendingDeckDraw;
                const pendingNextPlayer = this.buyWindow.pendingNextPlayer; // âœ… NEW

                // Clear buy window state
                this.buyWindow.active = false;
                this.buyWindow.card = null;
                this.buyWindow.discardingPlayer = -1;
                this.buyWindow.buyWindowPlayer = -1;
                this.buyWindow.pendingDeckDraw = null;
                this.buyWindow.pendingNextPlayer = null; // âœ… NEW

                if (this.buyWindow.timerInterval) {
                    clearTimeout(this.buyWindow.timerInterval);
                    this.buyWindow.timerInterval = null;
                }

                document.getElementById('buyBtn').disabled = true;
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) timerEl.style.display = 'none';

                // Log the closure reason
                if (reason === 'taken') {
                    showToast('Buy Denied - Card was taken', 'warning', 2000);
                } else if (reason === 'expired') {
                    console.log('%câ±ï¸ Buy window expired', 'color: #94a3b8;');
                } else if (reason === 'player-turn') {
                    console.log('%cğŸ® Buy window closed - your turn', 'color: #4a90e2;');
                } else if (reason === 'player-took') {
                    console.log('%câœ… Buy window closed - you took the card', 'color: #28a745;');
                } else if (reason === 'bought') {
                    console.log('%cğŸ’° Human bought card', 'color: #ffc107;');
                } else if (reason === 'ai-bought') {
                    console.log('%cğŸ’° AI bought card', 'color: #ffc107;');
                } else if (reason === 'no-buy-after-publish') {
                    console.log('%cğŸš« Buy window closed - AI already published in triple-only hand', 'color: #ff9800;');
                } else if (reason === 'no-buys') {
                    console.log('%cğŸš« Buy window closed - AI has no buys left', 'color: #9e9e9e;');
                } else if (reason === 'ai-no-buyback') {
                    console.log('%cğŸš« Buy window closed - AI cannot buy back own discard', 'color: #ff6b35;');
                }

                // Handle pendingDeckDraw (buy window opened during deck draw)
                // Resume if buy window closed without anyone buying
                const noBuyReasons = ['expired', 'no-buy-after-publish', 'no-buys', 'ai-no-buyback', 'invalid'];
                if (pendingDraw && noBuyReasons.includes(reason)) {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%câ–¶ï¸ Resuming ${aiName}'s turn after buy window (${reason})`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before drawing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`âœ… PATCH 1: ${aiName} auto-published sequences after buy window!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                } else if (pendingDraw && reason === 'bought') {
                    // Human bought - resume AI turn
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%câ–¶ï¸ Resuming ${aiName}'s turn after buy window`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before drawing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`âœ… PATCH 1: ${aiName} auto-published sequences after buy window!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                } else if (pendingDraw && reason === 'ai-bought') {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%câ–¶ï¸ Resuming ${aiName}'s turn (AI bought, skipping duplicate draw)`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before continuing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`âœ… PATCH 1: ${aiName} auto-published after AI bought!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                }
                // âœ… NEW: Handle pendingNextPlayer (buy window opened after AI discarded from discard pile)
                else if (pendingNextPlayer !== null && pendingNextPlayer !== undefined) {
                    console.log(`%câ–¶ï¸ Advancing to next player after buy window: Player ${pendingNextPlayer}`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        this.currentPlayer = pendingNextPlayer;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) {
                            this.aiTurn();
                        }
                    }, 500);

                }
            }

            updateBuyTimer() {
                if (!this.buyWindow.active) return;
                const remaining = Math.ceil((this.buyWindow.expiresAt - Date.now()) / 1000);
                if (remaining <= 0) { this.closeBuyWindow('expired'); return }
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) {
                    timerEl.textContent = ` (${remaining}s)`;
                    timerEl.style.display = 'inline';
                    timerEl.style.color = remaining <= 2 ? '#ff6b35' : '#ffd700';
                }
                this.buyWindow.timerInterval = setTimeout(() => this.updateBuyTimer(), 100);
            }

            handleAIBuyWindow(aiPlayer) {
                const aiName = aiPlayer === 1 ? 'Habot' : 'Jabot';
                const card = this.buyWindow.card;

                // âœ… FIX 9: If buy window is for HUMAN, don't let AI handle it!
                if (this.buyWindow.buyWindowPlayer === 0) {
                    console.log(`%cğŸš« FIX 9: Buy window is for HUMAN - AI should not interfere!`, 'color: #ff6b35; font-weight: bold;');
                    return;
                }

                // ğŸ¯ CRITICAL FIX: Don't let AI buy back the card they just discarded!
                if (this.buyWindow.discardingPlayer === aiPlayer) {
                    console.log(`%cğŸš« CRITICAL: ${aiName} just discarded this card - blocking stupid buyback!`, 'color: #ff6b35; font-weight: bold;');
                    this.closeBuyWindow('ai-no-buyback');
                    return;
                }

                // ğŸ› v4.5.12 FIX: If AI has no buys left, pass window to next player instead of closing
                if (this.playerBuys[aiPlayer] <= 0) {
                    console.log(`%câ­ï¸ v4.5.12: ${aiName} has no buys left - rotating to next player`, 'color: #9e9e9e; font-weight: bold;');
                    
                    // Find next player who hasn't had a chance yet
                    const nextBuyPlayer = (aiPlayer + 2) % 3; // Skip to next in rotation
                    const playerNames = ['Human', 'Habot', 'Jabot'];
                    
                    // Make sure next player isn't the discarding player
                    if (nextBuyPlayer === this.buyWindow.discardingPlayer) {
                        console.log(`%câ­ï¸ No more eligible buy window players - closing`, 'color: #9e9e9e;');
                        this.closeBuyWindow('no-buys');
                        return;
                    }
                    
                    // Check if next player has buys
                    if (this.playerBuys[nextBuyPlayer] <= 0) {
                        console.log(`%câ­ï¸ ${playerNames[nextBuyPlayer]} also has no buys - closing window`, 'color: #9e9e9e;');
                        this.closeBuyWindow('no-buys');
                        return;
                    }
                    
                    // Rotate to next player
                    console.log(`%cğŸ”„ v4.5.12: Rotating buy window to ${playerNames[nextBuyPlayer]}`, 'color: #ffc107; font-weight: bold;');
                    this.buyWindow.buyWindowPlayer = nextBuyPlayer;
                    
                    // If next player is human, enable buy button
                    if (nextBuyPlayer === 0) {
                        document.getElementById('buyBtn').disabled = false;
                        this.updateBuyTimer();
                    } else {
                        // Next player is AI, handle their buy window
                        this.handleAIBuyWindow(nextBuyPlayer);
                    }
                    return;
                }

                // ğŸ¯ PATCH I v4.1.4: Block buying after publishing in triple-only games (buy window version)
                // ğŸ› v4.5.12 FIX: Rotate to next player instead of closing window
                if (this.publishedSequences[aiPlayer].length > 0) {
                    const req = this.handReqs[this.currentHand].seqs;
                    const needLadders = req.filter(s => s === 'ladder').length;

                    if (needLadders === 0) {
                        // Triple-only game and AI has published - AI shouldn't buy, but pass to next player
                        console.log(`%c  ğŸ›‘ PATCH I v4.1.4: ${aiName} won't buy - Triple-only hand, already published`, 'color: #ff9800; font-weight: bold;');
                        
                        // Find next player who hasn't had a chance yet
                        const nextBuyPlayer = (aiPlayer + 2) % 3;
                        const playerNames = ['Human', 'Habot', 'Jabot'];
                        
                        // Check if next player is valid and has buys
                        if (nextBuyPlayer === this.buyWindow.discardingPlayer || this.playerBuys[nextBuyPlayer] <= 0) {
                            console.log(`%câ­ï¸ No more eligible buy window players - closing`, 'color: #9e9e9e;');
                            this.closeBuyWindow('no-buy-after-publish');
                            return;
                        }
                        
                        // Rotate to next player
                        console.log(`%cğŸ”„ v4.5.12: Rotating buy window to ${playerNames[nextBuyPlayer]}`, 'color: #ffc107; font-weight: bold;');
                        this.buyWindow.buyWindowPlayer = nextBuyPlayer;
                        
                        if (nextBuyPlayer === 0) {
                            document.getElementById('buyBtn').disabled = false;
                            this.updateBuyTimer();
                        } else {
                            this.handleAIBuyWindow(nextBuyPlayer);
                        }
                        return;
                    }
                }

                if (!card) {
                    console.log(`%câš ï¸ ${aiName} buy window has no card - closing`, 'color: #ff6600; font-weight: bold;');
                    this.closeBuyWindow('invalid');
                    if (this.buyWindow.pendingDeckDraw) {
                        const { ai, statusId } = this.buyWindow.pendingDeckDraw;
                        setTimeout(() => { this.drawDeckCardForAI(ai, statusId); this.continueAITurnAfterDraw(ai, statusId) }, 100);
                    }
                    return;
                }

                const statusId = aiPlayer === 1 ? 'habot' : 'jabot';
                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, `Considering buy...`);
                setTimeout(() => {
                    const shouldBuy = this.shouldAllowBuy(aiPlayer, card);
                    if (shouldBuy && this.playerBuys[aiPlayer] > 0) {
                        const idx = this.discardPile.findIndex(c => c.id === card.id);
                        if (idx > -1) {
                            this.discardPile.splice(idx, 1);
                            this.playerHands[aiPlayer].push(card);
                            this.discardPileAccessible = false; // ğŸ”’ v4.1.3: Lock vault after buy
                            if (this.lastDiscard && this.lastDiscard.rank === card.rank && this.lastDiscard.suit === card.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (this.deck.length === 0) this.reshuffleDeck();
                            if (this.deck.length > 0) {
                                const penalty = this.deck.pop();
                                this.playerHands[aiPlayer].push(penalty);
                            }
                            this.playerBuys[aiPlayer]--;
                            showBuyToast(aiName, card);
                            this.updateUI();
                        }
                    }
                    document.getElementById(`${statusId}-status`).classList.remove('active');
                    this.closeBuyWindow('ai-bought');
                }, 2500);
            }

            wouldDiscardImmediately(card, ai) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                const tempHand = [...this.playerHands[ai], card];
                const rankCounts = {};
                tempHand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { tempHand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[ai].length > 0) {
                    if (this.couldExtendSequence(card, ai)) protectedCards.add(card.id);
                }
                const safeCards = tempHand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worstValue = 9999;
                    let worstCard = null;
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, ai);
                        if (val < worstValue) { worstValue = val; worstCard = c }
                    });
                    const cardValue = this.evaluateCard(card, ai);
                    const wouldDiscard = worstCard && worstCard.rank === card.rank && worstCard.suit === card.suit;
                    console.log(`%c  ğŸ” v4.2.7: wouldDiscardImmediately(${card.toString()}) for ${aiName}`, 'color: #8b5cf6;');
                    console.log(`     Card value: ${cardValue}, Worst card: ${worstCard ? worstCard.toString() : 'none'} (value: ${worstValue})`);
                    console.log(`     Result: ${wouldDiscard ? 'YES - would discard' : 'NO - would keep'}`);
                    if (wouldDiscard && worstCard.rank === card.rank && worstCard.suit === card.suit) return true;
                }
                return false;
            }

            aiTurn() {
                const ai = this.currentPlayer;
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                const statusId = ai === 1 ? 'habot' : 'jabot';

                console.log(`%cğŸ¤– ${aiName} starting turn`, 'color: #3498db; font-weight: bold;');

                // ğŸ¯ v4.0.7 FIX: Reset publish flag at START of turn (not end of previous turn!)
                // This ensures AI cannot extend on the SAME turn as publishing
                // Flag is set when AI publishes, and cleared on NEXT turn start
                this.aiJustPublished[ai] = false;

                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, 'Taking turn...');

                // ğŸ¯ v2.5.0: Dynamic AI speed based on decision complexity
                const handSize = this.playerHands[ai].length;
                const hasPublished = this.publishedSequences[ai].length > 0;

                let delay = 0;
                if (!this.aiInstant) {
                    // Critical decisions = slower for realism
                    if (handSize <= 3 || (!hasPublished && this.canPublish(ai))) {
                        delay = 1000;  // Important moment - 1 second
                    }
                    // Routine play = faster
                    else {
                        delay = 500;  // Quick routine turn - 0.5 seconds
                    }
                }
                console.log(`%c  â±ï¸  AI delay: ${delay}ms (${handSize} cards, ${hasPublished ? 'published' : 'not published'})`, 'color: #9e9e9e;');

                setTimeout(() => {
                    this.turnCounter++;
                    console.log(`%c  Turn ${this.turnCounter}`, 'color: #3498db;');

                    // PATCH 2: Check hand size - block buying if 13+ cards
                    const currentHandSize = this.playerHands[ai].length;
                    if (currentHandSize >= 13) {
                        console.log(`%câ›” PATCH 2: ${aiName} has ${currentHandSize} cards - must reduce hand`, 'color: #e74c3c; font-weight: bold;');
                        // Force draw from deck instead of evaluating discard
                        console.log(`%c  ${aiName} drawing from deck (hand too large)...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    // PATCH 3: Try to auto-publish at turn start if hand is large
                    if (currentHandSize >= 12 && this.publishedSequences[ai].length === 0) {
                        console.log(`%cğŸš¨ PATCH 3: ${aiName} has ${currentHandSize} cards and hasn't published - forcing publish check`, 'color: #e74c3c; font-weight: bold;');
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`%câœ… PATCH 3: ${aiName} emergency published!`, 'color: #27ae60; font-weight: bold;');
                            this.aiJustPublished[ai] = true; // ğŸ› v4.1.5: Set flag to block extensions this turn
                            // Update hand size after publishing
                            const newHandSize = this.playerHands[ai].length;
                            console.log(`%c   Hand size reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                        }
                    }

                    let discardCard = null;
                    let discardScore = 0;
                    if (this.discardPile.length > 0) {
                        discardCard = this.discardPile[this.discardPile.length - 1];
                        discardScore = this.evaluateCard(discardCard, ai);
                        if (this.lastAIDiscard[ai] && this.lastAIDiscard[ai].rank === discardCard.rank && this.lastAIDiscard[ai].suit === discardCard.suit) {
                            discardScore = -999;
                        }
                    }

                    //Nash: Changed threshold from 15 to 11 to 5 - AI MUST take cards to form sequences!
                    let threshold = 5;
                    if (this.publishedSequences[ai].length === 0) {
                        const seqs = this.findSequences(this.playerHands[ai]);
                        const req = this.handReqs[this.currentHand].seqs;
                        const needTriples = req.filter(s => s === 'triple').length;
                        const needLadders = req.filter(s => s === 'ladder').length;
                        const hasTriples = seqs.triples.length;
                        const hasLadders = seqs.ladders.length;
                        if (hasTriples >= needTriples - 1 || hasLadders >= needLadders - 1) threshold = 4;
                    }
                    const personality = this.getAIPersonality(ai);
                    if (personality === 'rabbit') threshold -= 2;
                    else if (personality === 'tortoise') threshold += 2;
                    const forceBuy = discardCard && this.shouldAllowBuy(ai, discardCard);
                    let shouldTake = forceBuy || (discardCard && discardScore >= threshold);

                    // ğŸ¯ PATCH M: In triple games, only buy if completes/extends a triple
                    // ğŸ¯ v4.0.7 FIX: Check BOTH hand AND published sequences!
                    // ğŸ¯ v4.0.7 FIX: Check ALL published sequences (global resources), not just AI's own!
                    if (shouldTake && this.discardPile.length > 0) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const hasOnlyTriples = req.every(s => s === 'triple');

                        if (hasOnlyTriples && !forceBuy) {
                            const topCard = this.discardPile[this.discardPile.length - 1];
                            const matchingInHand = this.playerHands[ai].filter(c => c.rank === topCard.rank).length;
                            
                            // ğŸ¯ v4.0.7: Check ALL published sequences (anyone's!)
                            let matchingInAnyPublished = 0;
                            for (let p = 0; p < this.players; p++) {
                                const matching = this.getFlatPublished(p).filter(c => c.rank === topCard.rank).length;
                                if (matching > 0) {
                                    matchingInAnyPublished = matching;
                                    break; // Found one - that's enough! No need to check more
                                }
                            }
                            
                            const totalMatching = matchingInHand + matchingInAnyPublished;

                            if (totalMatching < 2) {
                                // Need at least 2 existing (hand OR any published) + 1 buy = 3 minimum
                                console.log(`  â†’ PATCH M: Blocking buy - ${topCard.toString()} won't complete triple (${matchingInHand} in hand, ${matchingInAnyPublished} in any published = ${totalMatching} total)`);
                                shouldTake = false;
                            } else {
                                console.log(`  â†’ PATCH M: Allowing buy - ${topCard.toString()} extends/completes triple! (${matchingInHand} in hand + ${matchingInAnyPublished} in published + 1 buy = extends global sequence)`);
                            }
                        }
                    }

                    // ğŸ¯ PATCH LADDER: In ladder games, force take cards that extend ANY published ladder!
                    if (!shouldTake && this.discardPile.length > 0) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const hasLadders = req.some(s => s === 'ladder');
                        
                        if (hasLadders) {
                            const topCard = this.discardPile[this.discardPile.length - 1];
                            
                            // Check if this card extends ANY published ladder (from any player)
                            for (let p = 0; p < this.players; p++) {
                                const flatPublished = this.getFlatPublished(p);
                                if (flatPublished.length === 0) continue;
                                
                                // Group published cards by suit to find ladders
                                const cardsBySuit = {};
                                flatPublished.forEach(card => {
                                    if (!cardsBySuit[card.suit]) cardsBySuit[card.suit] = [];
                                    cardsBySuit[card.suit].push(card.value);
                                });
                                
                                // Check each suit's ladder
                                for (const [suit, values] of Object.entries(cardsBySuit)) {
                                    if (values.length >= 4 && suit === topCard.suit) {
                                        // This is a ladder in the same suit!
                                        values.sort((a, b) => a - b);
                                        const lowValue = values[0];
                                        const highValue = values[values.length - 1];
                                        
                                        // Check if topCard extends this ladder
                                        if (topCard.value === lowValue - 1 || topCard.value === highValue + 1) {
                                            console.log(`%c  ğŸ¯ PATCH LADDER: ${topCard.toString()} extends published ladder! FORCE TAKE!`, 'color: #27ae60; font-weight: bold;');
                                            shouldTake = true;
                                            break;
                                        }
                                    }
                                }
                                if (shouldTake) break;
                            }
                        }
                    }

                    // ğŸ¯ PATCH H: Block buying in endgame
                    const aiHandSize = this.playerHands[ai].length;  // â† Changed name
                    const anyPlayerNearWin = this.playerHands.some((h, idx) => h.length <= 3 && this.publishedSequences[idx].length > 0);

                    // ğŸ¯ v4.2.7 FIX: Don't block if card extends ANY published sequence!
                    // Published sequences are GLOBAL resources - extending ANY sequence helps AI win!
                    let extendsAnySequence = false;
                    if (shouldTake && discardCard) {
                        for (let p = 0; p < this.players; p++) {
                            if (this.publishedSequences[p].length > 0 && this.couldExtendSequence(discardCard, p)) {
                                extendsAnySequence = true;
                                const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                console.log(`  ğŸŒ v4.2.7: ${discardCard.toString()} extends ${playerName}'s published sequence (global resource)`);
                                break;
                            }
                        }
                    }

                    if (shouldTake && aiHandSize <= 3 && this.publishedSequences[ai].length > 0 && !extendsAnySequence) {
                        console.log(`%c  ğŸ›‘ PATCH H: Blocking buy - AI has ${aiHandSize} cards in endgame`, 'color: #e74c3c; font-weight: bold;');
                        shouldTake = false;
                    }

                    if (shouldTake && anyPlayerNearWin && !extendsAnySequence) {
                        console.log(`%c  ğŸ›‘ PATCH H: Blocking buy - Someone near win (â‰¤3 cards + published)`, 'color: #e74c3c; font-weight: bold;');
                        shouldTake = false;
                    }
                    
                    if (extendsAnySequence && aiHandSize <= 3) {
                        console.log(`%c  âœ… v4.2.7: ALLOWING buy - ${discardCard.toString()} extends published sequences (global resource, helps AI win)!`, 'color: #27ae60; font-weight: bold;');
                    }

                    console.log(`%c  ğŸ¯ ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                    console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                    console.log(`     discardScore: ${discardScore}`);
                    console.log(`     threshold: ${threshold}`);
                    console.log(`     forceBuy: ${forceBuy}`);
                    console.log(`     shouldTake: ${shouldTake} ${!shouldTake && (aiHandSize <= 3 || anyPlayerNearWin) ? '(BLOCKED - endgame)' : ''}`);

                    // ğŸ¯ PATCH I v4.1.1: Block buying after publishing in triple-only games
                    // ğŸ› v4.5.12 FIX: EXCEPT when card extends a sequence!
                    if (shouldTake && this.publishedSequences[ai].length > 0 && !extendsAnySequence) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const needLadders = req.filter(s => s === 'ladder').length;

                        if (needLadders === 0) {
                            // Triple-only game and AI has published - NO MORE BUYING (unless it extends)
                            console.log(`%c  ğŸ›‘ PATCH I v4.1.1: Blocking buy - Triple-only hand, AI already published (card doesn't extend)`, 'color: #ff9800; font-weight: bold;');
                            shouldTake = false;
                        }
                    }

                    if (shouldTake && this.discardPile.length > 0) {

                        if (this.wouldDiscardImmediately(this.discardPile[this.discardPile.length - 1], ai)) {
                            this.setAIStatus(statusId, `Evaluating options...`);
                            this.handleDeckDraw(ai, statusId);
                            return;
                        } else {
                            const drawnCard = this.discardPile.pop();
                            this.playerHands[ai].push(drawnCard);
                            this.discardPileAccessible = false; // ğŸ”’ v4.1.3: Lock vault after taking card

                            // âœ… FIX 2: Show specific toast when AI takes card during buy window
                            if (this.buyWindow.active && this.buyWindow.buyWindowPlayer === 0 && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                console.log(`%cğŸš¨ FIX 2: AI took card during human buy window`, 'color: #ff6b35; font-weight: bold;');
                                showAITookCardToast(aiName, drawnCard);
                            }

                            if (this.buyWindow.active && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                this.closeBuyWindow('taken');
                            }
                            if (this.lastDiscard && this.lastDiscard.rank === drawnCard.rank && this.lastDiscard.suit === drawnCard.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (forceBuy) this.setAIStatus(statusId, `Analyzing hand...`);
                            else this.setAIStatus(statusId, `Drawing card...`);
                        }

                    } else {

                        console.log(`%c  ğŸ¯ ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                        console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                        console.log(`     discardScore: ${discardScore}`);
                        console.log(`     threshold: ${threshold}`);
                        console.log(`     forceBuy: ${forceBuy}`);
                        console.log(`     shouldTake: ${shouldTake}`);

                        console.log(`%c  ${aiName} drawing from deck...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    this.continueAITurnAfterDraw(ai, statusId);
                }, 1500);
            }

            handleDeckDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';

                console.log(`%cğŸ” handleDeckDraw called for ${aiName}`, 'color: #9b59b6; font-weight: bold;');
                console.log(`  lastDiscard: ${this.lastDiscard ? this.lastDiscard.toString() : 'null'}`);
                console.log(`  lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);

                if (this.lastDiscard && this.lastDiscardByPlayer !== -1) {
                    const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                    console.log(`  buyWindowPlayer would be: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                    if (buyWindowPlayer !== ai && buyWindowPlayer !== this.lastDiscardByPlayer) {
                        console.log(`  âœ… Buy window conditions met!`);
                        const cardStillExists = this.discardPile.some(c => c.rank === this.lastDiscard.rank && c.suit === this.lastDiscard.suit);

                        if (!cardStillExists) {
                            this.lastDiscard = null;
                            this.lastDiscardByPlayer = -1;
                            this.drawDeckCardForAI(ai, statusId);
                            this.continueAITurnAfterDraw(ai, statusId);
                            return;
                        }
                        this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);
                        this.buyWindow.pendingDeckDraw = { ai, statusId };
                        if (buyWindowPlayer > 0) this.handleAIBuyWindow(buyWindowPlayer);
                        return;
                    }
                }
                this.drawDeckCardForAI(ai, statusId);
                this.continueAITurnAfterDraw(ai, statusId);
            }

            drawDeckCardForAI(ai, statusId) {
                if (this.deck.length === 0) { this.reshuffleDeck(); this.updateUI() }
                if (this.deck.length > 0) {
                    const drawnCard = this.deck.pop();
                    this.playerHands[ai].push(drawnCard);
                    this.setAIStatus(statusId, `Analyzed hand`);
                }
            }

            continueAITurnAfterDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                
                // ğŸ—ï¸ v4.5.12: STAGED CONSTRUCTION WITH HOLD SYSTEM + DECISION TREE DEBUG
                if (this.currentHand >= 6 && this.aiConstructionStage[ai] !== 'ready_to_publish') {
                    const hand = this.playerHands[ai];
                    const unlockedHand = this.getUnlockedCards(hand, ai); // ğŸ”§ v4.5.12: Only check unlocked cards!
                    const seqs = this.findSequences(unlockedHand);
                    const stage = this.aiConstructionStage[ai];
                    
                    console.log(`%cğŸŒ³ DECISION TREE START - ${aiName} - Stage: ${stage}`, 'color: #9c27b0; font-weight: bold; font-size: 14px;');
                    console.log(`  ğŸ—ï¸ v4.5.12: ${aiName} turn - Stage: ${stage}`);
                    console.log(`      Hand: ${hand.length} total (${unlockedHand.length} unlocked) - ${seqs.triples.length}T, ${seqs.ladders.length}L`);
                    
                    // ğŸ”§ v4.5.12: NODE 1 - Check held sequences FIRST (returns completion flag!)
                    console.log(`%câ”œâ”€ NODE 1: checkHeldSequences() - Checking for HOLD completions`, 'color: #2196f3; font-weight: bold;');
                    const completedHoldThisTurn = this.checkHeldSequences(ai);
                    
                    if (completedHoldThisTurn) {
                        console.log(`%câ”‚  â””â”€ âœ… HOLD COMPLETED - Skipping direct ladder checks to prevent overlap`, 'color: #4caf50; font-weight: bold;');
                        console.log(`%câ””â”€ DECISION TREE END (early exit: hold completed)`, 'color: #9c27b0; font-weight: bold;');
                        // Skip all direct ladder checking - we just locked from hold!
                        // Continue to discard logic below
                    } else {
                        console.log(`%câ”‚  â””â”€ â„¹ï¸  No holds completed - Proceeding to direct ladder checks`, 'color: #ff9800;');
                        
                        // ğŸ”§ v4.5.12: NODE 2 - Check for direct ladders (ONLY if no hold completed!)
                        console.log(`%câ”œâ”€ NODE 2: Direct ladder detection`, 'color: #2196f3; font-weight: bold;');
                        
                        // Check if we completed a sequence in current stage
                        if (stage === 'building_L1' && seqs.ladders.length > 0) {
                            console.log(`%câ”‚  â”œâ”€ Found ${seqs.ladders.length} complete ladder(s) in unlocked hand`, 'color: #607d8b;');
                            // Lock first ladder
                            const firstLadder = seqs.ladders[0];
                            const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                            
                            if (locked.length === 0) {
                                // First ladder not yet locked - lock it now!
                                this.lockSequence(ai, firstLadder, 'ladder', firstLadder[0].suit);
                                console.log(`%câ”‚  â””â”€ ğŸ”’ Locked first ladder: ${firstLadder.map(c => c.toString()).join(', ')}`, 'color: #4caf50; font-weight: bold;');
                                
                                // Advance to next stage
                                this.advanceConstructionStage(ai);
                            } else {
                                console.log(`%câ”‚  â””â”€ â­ï¸  First ladder already locked, skipping`, 'color: #ff9800;');
                            }
                        } else if (stage === 'building_L1' && seqs.ladders.length === 0) {
                            console.log(`%câ”‚  â”œâ”€ No complete ladders found - Checking for HOLD opportunities`, 'color: #607d8b;');
                            // ğŸ”¶ v4.5.12: No complete ladder â†’ Check for HOLDS
                            const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                            
                            if (potentialHolds.length > 0 && this.aiHeldSequences[ai].length === 0) {
                                // Found 3-card "almost ladder" and no holds yet â†’ PUT ON HOLD
                                const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                                this.putOnHold(ai, bestHold);
                                
                                // IMMEDIATELY advance to L2 (don't wait!)
                                console.log(`%câ”‚  â””â”€ â­ï¸ v4.5.12: Advancing to L2 while L1 on hold`, 'color: #ff9800; font-weight: bold;');
                                this.advanceConstructionStage(ai);
                            } else {
                                console.log(`%câ”‚  â””â”€ â¸ï¸  No HOLD opportunities - Continuing to accumulate cards`, 'color: #9e9e9e;');
                            }
                            // else: Keep accumulating cards on building_L1
                        } else if (stage === 'building_L2' && seqs.ladders.length >= 2) {
                            console.log(`%câ”‚  â”œâ”€ Found ${seqs.ladders.length} ladders - Checking for second ladder to lock`, 'color: #607d8b;');
                            // Lock second ladder
                            const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                            
                            if (locked.length === 1) {
                                // Find the unlocked ladder
                                const unlockedLadder = seqs.ladders.find(ladder => {
                                    const firstCard = ladder[0];
                                    return !locked.some(l => l.cards.some(c => c.id === firstCard.id));
                                });
                                
                                if (unlockedLadder) {
                                    this.lockSequence(ai, unlockedLadder, 'ladder', unlockedLadder[0].suit);
                                    console.log(`%câ”‚  â””â”€ ğŸ”’ Locked second ladder: ${unlockedLadder.map(c => c.toString()).join(', ')}`, 'color: #4caf50; font-weight: bold;');
                                    
                                    // Advance to next stage (L3 or T depending on requirements)
                                    this.advanceConstructionStage(ai);
                                } else {
                                    console.log(`%câ”‚  â””â”€ âš ï¸  Could not find unlocked ladder (both already locked?)`, 'color: #f44336;');
                                }
                            } else {
                                console.log(`%câ”‚  â””â”€ â­ï¸  Second ladder already locked, skipping`, 'color: #ff9800;');
                            }
                        } else if (stage === 'building_L2' && seqs.ladders.length < 2) {
                            console.log(`%câ”‚  â”œâ”€ Less than 2 ladders - Checking for L2 HOLD opportunities`, 'color: #607d8b;');
                            // ğŸ”¶ v4.5.12: No second ladder yet â†’ Check for HOLDS
                            const unlockedHand = this.getUnlockedCards(hand, ai);
                            const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                            
                            // Only add one hold for L2 (may already have L1 on hold)
                            const l2Holds = this.aiHeldSequences[ai].filter(h => h.createdTurn >= this.turnCounter - 5);
                            if (potentialHolds.length > 0 && l2Holds.length < 1) {
                                const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                                this.putOnHold(ai, bestHold);
                                
                                // Advance to next stage while L2 on hold
                                console.log(`%câ”‚  â””â”€ â­ï¸ v4.5.12: Advancing while L2 on hold`, 'color: #ff9800; font-weight: bold;');
                                this.advanceConstructionStage(ai);
                            } else {
                                console.log(`%câ”‚  â””â”€ â¸ï¸  No L2 HOLD opportunities or already have hold`, 'color: #9e9e9e;');
                            }
                        } else if (stage === 'building_L3' && seqs.ladders.length >= 3) {
                            console.log(`%câ”‚  â”œâ”€ Found ${seqs.ladders.length} ladders - Checking for third ladder to lock`, 'color: #607d8b;');
                            // ğŸ”§ v4.5.12: Lock third ladder (Hand 7)
                            const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                            
                            if (locked.length === 2) {
                                // Find the unlocked ladder
                                const unlockedLadder = seqs.ladders.find(ladder => {
                                    const firstCard = ladder[0];
                                    return !locked.some(l => l.cards.some(c => c.id === firstCard.id));
                                });
                                
                                if (unlockedLadder) {
                                    this.lockSequence(ai, unlockedLadder, 'ladder', unlockedLadder[0].suit);
                                    console.log(`%câ”‚  â””â”€ ğŸ”’ v4.5.12: Locked THIRD ladder: ${unlockedLadder.map(c => c.toString()).join(', ')}`, 'color: #4caf50; font-weight: bold;');
                                    
                                    // Check if ready to publish
                                    this.advanceConstructionStage(ai);
                                } else {
                                    console.log(`%câ”‚  â””â”€ âš ï¸  Could not find unlocked ladder for L3`, 'color: #f44336;');
                                }
                            } else {
                                console.log(`%câ”‚  â””â”€ â­ï¸  Third ladder already locked, skipping`, 'color: #ff9800;');
                            }
                        } else if (stage === 'building_L3' && seqs.ladders.length < 3) {
                            console.log(`%câ”‚  â”œâ”€ Less than 3 ladders - Checking for L3 HOLD opportunities`, 'color: #607d8b;');
                            // ğŸ”¶ v4.5.12: No third ladder yet â†’ Can put on hold if needed
                            const unlockedHand = this.getUnlockedCards(hand, ai);
                            const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                            
                            if (potentialHolds.length > 0 && this.aiHeldSequences[ai].length < 2) {
                                const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                                this.putOnHold(ai, bestHold);
                                console.log(`%câ”‚  â””â”€ ğŸ”¶ Put new sequence on HOLD for L3`, 'color: #ff9800;');
                            } else {
                                console.log(`%câ”‚  â””â”€ â¸ï¸  No L3 HOLD opportunities or already have 2 holds`, 'color: #9e9e9e;');
                            }
                            // Note: Don't advance past L3, stay on L3 until third ladder found
                        } else if (stage === 'building_T' && seqs.triples.length > 0) {
                            console.log(`%câ”‚  â”œâ”€ Found ${seqs.triples.length} triple(s) - Attempting to lock`, 'color: #607d8b;');
                            // Lock triple
                            const firstTriple = seqs.triples[0];
                            const lockedTriples = this.aiLockedSequences[ai].filter(s => s.type === 'triple');
                            
                            if (lockedTriples.length === 0) {
                                this.lockSequence(ai, firstTriple, 'triple');
                                console.log(`%câ”‚  â””â”€ ğŸ”’ Locked triple: ${firstTriple.map(c => c.toString()).join(', ')}`, 'color: #4caf50; font-weight: bold;');
                                
                                // Check if ready to publish
                                this.advanceConstructionStage(ai);
                            } else {
                                console.log(`%câ”‚  â””â”€ â­ï¸  Triple already locked, skipping`, 'color: #ff9800;');
                            }
                        } else {
                            console.log(`%câ”‚  â””â”€ â„¹ï¸  No special conditions met for ${stage}`, 'color: #9e9e9e;');
                        }
                        
                        console.log(`%câ””â”€ DECISION TREE END`, 'color: #9c27b0; font-weight: bold;');
                    }
                }
                
                // PATCH 4: Emergency publish if hand is too large
                const currentHandSize = this.playerHands[ai].length;
                if (currentHandSize >= 13 && this.publishedSequences[ai].length === 0 && this.canPublish(ai)) {
                    console.log(`%cğŸš¨ PATCH 4: ${aiName} has ${currentHandSize} cards - FORCING publish!`, 'color: #e74c3c; font-weight: bold;');
                    const publishSuccess = this.autoPublish(ai);
                    if (publishSuccess) {
                        this.aiJustPublished[ai] = true;
                        this.setAIStatus(statusId, `Emergency Published!`);
                        console.log(`%câœ… PATCH 4: ${aiName} emergency publish SUCCESS!`, 'color: #27ae60; font-weight: bold;');
                        const newHandSize = this.playerHands[ai].length;
                        console.log(`%c   Hand reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                    } else {
                        console.log(`%câš ï¸ PATCH 4: ${aiName} emergency publish FAILED - no valid sequences`, 'color: #f39c12; font-weight: bold;');
                    }
                }

                // ğŸ¯ PATCH L2: Auto-drop excess pairs in triple games
                const req = this.handReqs[this.currentHand].seqs;
                const hasOnlyTriples = req.every(s => s === 'triple');

                if (hasOnlyTriples) {
                    // Count pairs
                    const rankCounts = {};
                    this.playerHands[ai].forEach(c => {
                        rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1;
                    });

                    const pairs = Object.entries(rankCounts).filter(([rank, count]) => count === 2);

                    if (pairs.length > 4) {
                        console.log(`%c  â†’ PATCH L2: ${aiName} has ${pairs.length} pairs - dropping worst one`, 'color: #e67e22; font-weight: bold;');

                        // Find highest-value pair to drop
                        let worstPairRank = null;
                        let highestValue = -1;

                        pairs.forEach(([rank, count]) => {
                            const cardValue = this.playerHands[ai].find(c => c.rank === rank).getValue();
                            if (cardValue > highestValue) {
                                highestValue = cardValue;
                                worstPairRank = rank;
                            }
                        });

                        // Drop one card from worst pair
                        const cardToDrop = this.playerHands[ai].find(c => c.rank === worstPairRank);
                        const dropIndex = this.playerHands[ai].indexOf(cardToDrop);
                        this.playerHands[ai].splice(dropIndex, 1);
                        this.discardPile.push(cardToDrop);
                        this.discardPileAccessible = true; // ğŸ”’ v4.1.3: Unlock vault

                        console.log(`%c  â†’ PATCH L2: Auto-dropped ${cardToDrop.toString()} (highest-value pair)`, 'color: #e67e22; font-weight: bold;');
                        this.updateUI();

                        // End turn - we already discarded
                        this.setAIStatus(statusId, '');
                        document.getElementById(`${statusId}-status`).classList.remove('active');

                        this.currentPlayer = (this.currentPlayer + 1) % this.players;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) this.aiTurn();

                        return;
                    }
                }

                const canPublishNow = this.canPublish(ai) && this.publishedSequences[ai].length === 0;

                if (canPublishNow) {
                    let shouldPublish = false;
                    const opponentDanger = this.publishedSequences.some((seq, idx) => idx !== ai && seq.length > 0 && this.playerHands[idx].length <= 3);
                    if (opponentDanger) shouldPublish = true;
                    const personality = this.getAIPersonality(ai);

                    //Nash: changed it from 22 : 30 to make the game faster
                    const turnLimit = personality === 'rabbit' ? 15 : 20;
                    if (this.turnCounter >= turnLimit) shouldPublish = true;
                    else {
                        let optimalSize = this.currentHand <= 3 ? 7 : 6;
                        if (personality === 'rabbit') optimalSize += 1;
                        else if (personality === 'tortoise') optimalSize -= 1;
                        if (this.playerHands[ai].length <= optimalSize) shouldPublish = true;
                    }

                    console.log(`%c  ğŸ“‹ ${aiName} publish check:`, 'color: #9b59b6; font-weight: bold;');
                    console.log(`     canPublishNow: ${canPublishNow}`);
                    console.log(`     opponentDanger: ${opponentDanger}`);
                    console.log(`     turnCounter: ${this.turnCounter}`);
                    console.log(`     handSize: ${this.playerHands[ai].length}`);
                    console.log(`     shouldPublish: ${shouldPublish}`);

                    if (shouldPublish) {
                        console.log(`%c  ğŸ‰ ${aiName} attempting to publish!`, 'color: #28a745; font-weight: bold;');
                        const publishSuccess = this.autoPublish(ai);
                        console.log(`     publishSuccess: ${publishSuccess}`);

                        if (publishSuccess) {
                            this.aiJustPublished[ai] = true;

                            // -----------------------------------------------------------------
                            // --- NEW INSERTION: Auto-Expand AI Area after NEW sequence publish ---
                            // -----------------------------------------------------------------
                            if (ai === 1 || ai === 2) {
                                const aiId = ai === 1 ? 'habot-area' : 'jabot-area';
                                const area = document.getElementById(aiId);

                                if (area) {
                                    const content = area.querySelector('.ai-content');
                                    // Only expand if it is currently collapsed
                                    if (content.classList.contains('collapsed')) {
                                        // NOTE: We assume toggleAIArea is globally available
                                        toggleAIArea(aiId);
                                    }
                                }
                            }

                            this.setAIStatus(statusId, `Published!`);
                            console.log(`%c  âœ… ${aiName} PUBLISHED successfully!`, 'color: #28a745; font-weight: bold;');
                            console.log(`     Published sequences:`, this.publishedSequences[ai]);
                        } else {
                            console.log(`%c  âŒ ${aiName} publish FAILED`, 'color: #dc3545; font-weight: bold;');
                        }
                        if (this.playerHands[ai].length === 0) {
                            console.log(`%c  ğŸ† ${aiName} has NO cards left - WINS!`, 'color: #ffc107; font-weight: bold;');
                            this.endHand(ai);
                            return;
                        }
                    }
                }

                // PATCH 5: Try to publish again if still holding 12+ cards after first publish
                if (this.playerHands[ai].length >= 12 && this.publishedSequences[ai].length > 0 && this.canPublish(ai)) {
                    console.log(`%cğŸš¨ PATCH 5: ${aiName} still has ${this.playerHands[ai].length} cards after publishing - checking for more sequences`, 'color: #e74c3c; font-weight: bold;');
                    const additionalPublish = this.autoPublish(ai);
                    if (additionalPublish) {
                        console.log(`%câœ… PATCH 5: ${aiName} published additional sequences!`, 'color: #27ae60; font-weight: bold;');
                    }
                }

                if (!this.aiJustPublished[ai] && this.playerHands[ai].length > 0 && this.publishedSequences[ai].length > 0) {
                    // ğŸ¯ v4.0.7: Try to add MULTIPLE cards if possible (loop until no more extensions)
                    let addedAny = false;
                    let addCount = 0;
                    const maxExtensions = 10; // Safety limit
                    
                    console.log(`%cğŸ¯ v4.0.7: Checking for extension opportunities...`, 'color: #9c27b0; font-weight: bold;');
                    
                    while (addCount < maxExtensions) {
                        const addResult = this.tryAddToPublished(ai);
                        
                        if (addResult === 'win') {
                            this.setAIStatus(statusId, `Added and WINS!`);
                            this.updateUI();
                            setTimeout(() => { this.endHand(ai) }, 50);
                            return;
                        } else if (addResult === true) {
                            addedAny = true;
                            addCount++;
                            console.log(`%c  âœ… v4.0.7: Extended sequence (${addCount} card(s) played)`, 'color: #9c27b0;');
                            // Continue loop to check if we can add more
                        } else {
                            // No more extensions possible
                            break;
                        }
                    }
                    
                    if (addedAny) {
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ` â†’ Added ${addCount} card(s)`);
                        console.log(`%cğŸ¯ v4.0.7: Total extensions played: ${addCount}`, 'color: #9c27b0; font-weight: bold;');
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 1500);
                    return;
                }
                if (this.playerHands[ai].length > 0) {
                    const worst = this.findWorstCard(ai);
                    const idx = this.playerHands[ai].findIndex(c => c.id === worst.id);
                    if (idx > -1) {
                        this.playerHands[ai].splice(idx, 1);
                        this.discardPile.push(worst);
                        this.discardPileAccessible = true; // ğŸ”’ v4.1.3: Unlock vault
                        this.lastAIDiscard[ai] = worst;
                        this.lastDiscard = worst;
                        this.lastDiscardByPlayer = ai;
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ` â†’ Discarded: ${worst.toString()}`);
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 50);
                    return;
                }
                if (this.shouldRequestBuy(ai)) {
                    const current = document.getElementById(`${statusId}-action`).textContent;
                    if (!current.includes('BUY!')) this.setAIStatus(statusId, current + ' â†’ Says "BUY!"');
                }

                this.lastDiscard = this.discardPile[this.discardPile.length - 1];
                this.lastDiscardByPlayer = ai;
                // ğŸ¯ v4.0.7: REMOVED aiJustPublished[ai] = false from here
                // Flag now resets at START of NEXT turn, not end of THIS turn
                // This prevents extending on same turn as publishing

                // âœ… Check if buy window should open after AI discarded
                const buyWindowOpened = this.checkAndOpenBuyWindowAfterDiscard(ai, statusId);

                if (buyWindowOpened) {
                    // Buy window is open - it will handle game continuation
                    return;
                }

                // No buy window - continue normally
                setTimeout(() => { document.getElementById(`${statusId}-status`).classList.remove('active') }, 2000);
                this.currentPlayer = (this.currentPlayer + 1) % this.players;
                this.gamePhase = 'draw';
                this.updateUI();
                if (this.currentPlayer !== 0) this.aiTurn();
            }

            tryAddToPublished(aiIdx) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const playerOrder = [aiIdx];
                for (let p = 0; p < this.players; p++) {
                    if (p !== aiIdx) playerOrder.push(p);
                }
                for (let p of playerOrder) {
                    if (this.publishedSequences[p].length === 0) continue;

                    // ğŸ¯ v4.0.7 FIX: REMOVED PATCH Q entirely!
                    // OLD LOGIC (WRONG):
                    // "Don't extend opponent AI when all published" - prevented Jabot from extending Habot
                    // 
                    // NEW UNDERSTANDING:
                    // Extending ANY sequence (even opponent's) is GOOD for the extending player!
                    // - Reduces your hand size âœ“
                    // - Gets you closer to winning âœ“  
                    // - Opponent doesn't get cards back âœ“
                    // - It's ALWAYS beneficial to extend!
                    //
                    // Example: Jabot extends Habot's 7â™ 7â™¥7â™¦ with 7â™£
                    // - Jabot's hand: 3 â†’ 2 cards (progress!) âœ“
                    // - Habot's published: 3 â†’ 4 cards (but Habot's hand unchanged)
                    // - Net result: Jabot closer to winning! âœ“

                    // ğŸ¯ v4.2.7 FIX: REMOVED opponent hand size check entirely!
                    // After publishing, ALWAYS extend ALL sequences (global resources)!
                    // Playing cards to extend reduces YOUR hand - it's always good!
                    // OLD BUG: if (p !== aiIdx && this.playerHands[p].length <= 4 && this.playerHands[aiIdx].length > 1) continue;
                    // This prevented AI from aggressively extending after publishing
                    
                    for (let i = 0; i < this.playerHands[aiIdx].length; i++) {
                        const card = this.playerHands[aiIdx][i];
                        
                        // ğŸ¯ v4.0.7: Get flat view of published cards for extension logic
                        const published = this.getFlatPublished(p);
                        
                        // ğŸ¯ v4.0.7 FIX: REMOVED incorrect check
                        // OLD BUG: const inOwnSequences = this.publishedSequences[aiIdx].find(c => c.rank === card.rank && c.suit === card.suit);
                        // OLD BUG: if (inOwnSequences) continue;
                        // This was blocking cards like "second 8â™¦" from extending "first 8â™¦" in triples!
                        // Cards are unique by ID, not by rank+suit. Multiple cards can have same rank+suit.
                        
                        const alreadyPublished = published.find(c => c.id === card.id);
                        if (alreadyPublished) continue;  // Skip if this exact card already published
                        const sameRankSuit = published.filter(c => c.rank === card.rank && c.suit === card.suit);
                        if (sameRankSuit.length >= 2) continue;  // Skip if 2+ of same rank/suit already there
                        if (hasTriples) {
                            const rankCounts = {};
                            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                            if (rankCounts[card.rank] >= 3) {
                                // ğŸ› v4.5.12 FIX: Find the specific sequence to extend and add directly
                                let extendedSequence = false;
                                
                                for (let seqIdx = 0; seqIdx < this.publishedSequences[p].length; seqIdx++) {
                                    const seq = this.publishedSequences[p][seqIdx];
                                    const seqRanks = seq.map(c => c.rank);
                                    
                                    // Check if this sequence contains matching rank
                                    if (seqRanks.includes(card.rank)) {
                                        // Found the matching sequence - add card directly
                                        this.publishedSequences[p][seqIdx].push(card);
                                        this.playerHands[aiIdx].splice(i, 1);
                                        extendedSequence = true;
                                        console.log(`  âœ… v4.5.12: Extended ${['You', 'Habot', 'Jabot'][p]}'s sequence ${seqIdx + 1} with ${card.toString()}`);
                                        break;
                                    }
                                }
                                
                                if (extendedSequence) {
                                    if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                    return true;
                                }
                            }
                        }
                        if (hasLadders) {
                            const sameSuit = published.filter(c => c.suit === card.suit);
                            console.log(`  ğŸ” tryAddToPublished: Checking ${card.toString()} - found ${sameSuit.length} published ${card.suit} cards`);
                            if (sameSuit.length >= 4) {
                                const cardVal = card.getValue();
                                const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                                const ladders = []; let remainingValues = [...values];
                                const hasAce = values.includes(1); const hasJack = values.includes(11);
                                const hasQueen = values.includes(12); const hasKing = values.includes(13);

                                if (hasAce && hasJack && hasQueen && hasKing) {
                                    // ğŸ”§ PATCH O: Extract ALL consecutive high cards from King downward
                                    const wrapLadder = [1];  // Start with Ace (value 1)
                                    const highCards = values.filter(v => v >= 11).sort((a, b) => b - a);
                                    for (let i = 0; i < highCards.length; i++) {
                                        if (i === 0 || highCards[i] === highCards[i - 1] - 1) {
                                            wrapLadder.push(highCards[i]);
                                        } else {
                                            break;
                                        }
                                    }
                                    console.log(`  ğŸ”§ PATCH O: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                                    ladders.push(wrapLadder);
                                    remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                                }

                                if (remainingValues.length >= 4) {
                                    let currentLadder = [remainingValues[0]];
                                    for (let i = 1; i < remainingValues.length; i++) {
                                        if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                            currentLadder.push(remainingValues[i]);
                                        } else {
                                            if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                            currentLadder = [remainingValues[i]];
                                        }
                                    }
                                    if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                                }
                                const canExtendLadder = ladders.some(ladder => {
                                    return this.canCardExtendLadder(cardVal, ladder);
                                });
                                if (canExtendLadder) {
                                    // ğŸ› v4.5.12 FIX: Find the specific sequence to extend and add directly
                                    let extendedSequence = false;
                                    
                                    for (let seqIdx = 0; seqIdx < this.publishedSequences[p].length; seqIdx++) {
                                        const seq = this.publishedSequences[p][seqIdx];
                                        
                                        // Check if this sequence is same suit and can be extended
                                        const seqSameSuit = seq.filter(c => c.suit === card.suit);
                                        if (seqSameSuit.length >= 4) {
                                            const seqValues = seqSameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                                            const minVal = Math.min(...seqValues);
                                            const maxVal = Math.max(...seqValues);
                                            
                                            // Check if card extends low or high end
                                            if (cardVal === minVal - 1 || cardVal === maxVal + 1 || 
                                                (cardVal === 1 && maxVal === 13) || (cardVal === 13 && seqValues.includes(1))) {
                                                // Found the matching sequence - add card directly
                                                this.publishedSequences[p][seqIdx].push(card);
                                                this.playerHands[aiIdx].splice(i, 1);
                                                extendedSequence = true;
                                                console.log(`  âœ… v4.5.12: Extended ${['You', 'Habot', 'Jabot'][p]}'s ladder sequence ${seqIdx + 1} with ${card.toString()}`);
                                                break;
                                            }
                                        }
                                    }
                                    
                                    if (extendedSequence) {
                                        if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }

            endHand(winner) {
                const winnerName = winner === 0 ? 'You' : winner === 1 ? 'Habot' : 'Jabot';
                showWinToast(winnerName);
                for (let i = 0; i < this.players; i++) {
                    if (i === winner) continue;
                    let score = 0;
                    this.playerHands[i].forEach(c => score += c.getPenaltyValue());
                    this.playerScores[i] += score;
                }
                setTimeout(() => { this.showModal('Hand Complete', `${winnerName} won Hand ${this.currentHand}!`) }, 2000);
                setTimeout(async () => {
                    // ğŸ® v4.5.12: Check if single hand mode or full game
                    if (this.gameMode !== 'full') {
                        // Single hand mode - show hand selection menu again
                        console.log('%cğŸ¯ Single hand complete! Showing hand selection menu...', 'color: #ffd700; font-weight: bold;');
                        const selectedHand = await showHandSelectionModal();
                        
                        if (selectedHand === null) {
                            // User cancelled - stay in current game state (show final results)
                            this.showFinalResults();
                            return;
                        }
                        
                        // Start new game with selected hand
                        persistentScores = [0, 0, 0];
                        game = new GameState(false, selectedHand);
                        return;
                    }
                    
                    // Full game mode - advance to next hand
                    this.currentHand++;
                    if (this.currentHand > 7) this.showFinalResults();
                    else {
                        this.playerBuys = this.currentHand === 7 ? [2, 2, 2] : [3, 3, 3];
                        this.publishedSequences = [[], [], []]; this.playerHands = [[], [], []]; this.selectedCards = [];
                        this.gamePhase = 'draw'; this.currentPlayer = 0; this.justPublished = false; this.aiJustPublished = [false, false, false];
                        this.lastDiscard = null; this.lastDiscardByPlayer = -1; this.discardPile = [];
                        this.turnCounter = 0; this.lastAIDiscard = [null, null, null]; this.lastCardWarningShown = null;
                        
                        // ğŸ—ï¸ v4.5.12: Initialize staged construction for Hands 6-7
                        if (this.currentHand >= 6) {
                            console.log(`%cğŸ—ï¸ v4.5.12: Initializing STAGED CONSTRUCTION for Hand ${this.currentHand}`, 'color: #9b59b6; font-weight: bold; font-size: 14px;');
                            this.aiConstructionStage = [null, 'building_L1', 'building_L1'];
                            this.aiStageStartTurn = [null, this.turnCounter, this.turnCounter]; // ğŸ’š v4.5.12: Track stage start
                            this.aiLockedSequences = [[], [], []];
                            this.aiTargetCards = [null, [], []];
                            this.aiSuitFocus = [null, [], []];
                        }
                        
                        this.initDeck(); this.deal(); this.updateUI();
                    }
                }, 4000);
            }

            showFinalResults() {
                const results = this.playerScores.map((s, i) => ({ name: i === 0 ? 'You' : i === 1 ? 'Habot' : 'Jabot', score: s })).sort((a, b) => a.score - b.score);
                const winner = results[0];
                const loser = results[results.length - 1];
                persistentScores = [...this.playerScores];
                const msg = `Game Complete!\n\nğŸ† ${winner.name} wins with ${winner.score} points!\nğŸƒ ${loser.name} is the Habib Punja with ${loser.score} points!`;
                
                // ğŸ® v4.5.12: Show final results with Play Again option instead of auto-restarting
                this.showFinalResultsModal(msg, winner, loser);
            }

            // ğŸ® v4.5.12: NEW - Final results modal with Play Again option
            showFinalResultsModal(msg, winner, loser) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background:#1a4d2e;padding:40px;border-radius:15px;text-align:center;border:2px solid #ffd700;max-width:500px;';
                
                const titleEl = document.createElement('h2');
                titleEl.style.cssText = 'color:#ffd700;margin-bottom:20px;font-size:28px;';
                titleEl.textContent = 'Final Results';
                
                const msgEl = document.createElement('p');
                msgEl.style.cssText = 'color:white;margin-bottom:30px;white-space:pre-line;font-size:18px;line-height:1.6;';
                msgEl.textContent = msg;
                
                // Button container
                const btnContainer = document.createElement('div');
                btnContainer.style.cssText = 'display:flex;gap:15px;justify-content:center;';
                
                // Play Again button
                const playAgainBtn = document.createElement('button');
                playAgainBtn.style.cssText = 'padding:15px 40px;background:#28a745;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:16px;transition:transform 0.2s;';
                playAgainBtn.textContent = 'ğŸ® Play Again';
                playAgainBtn.addEventListener('mouseover', () => playAgainBtn.style.transform = 'scale(1.05)');
                playAgainBtn.addEventListener('mouseout', () => playAgainBtn.style.transform = 'scale(1)');
                playAgainBtn.addEventListener('click', async () => {
                    modal.remove();
                    console.log('%cğŸ® Starting New Game...', 'color: #2196f3; font-weight: bold; font-size: 16px;');

                    // Create game instance
                    game = new GameState(true);

                    // Draw for starting player
                    const startingPlayer = await game.drawForFirstTurn();
                    game.currentPlayer = startingPlayer;
                    game.startingPlayer = startingPlayer;

                    console.log(`%cğŸ¯ Starting player set: ${['You', 'Habot', 'Jabot'][startingPlayer]}`, 'color: #e91e63; font-weight: bold;');

                    // Initialize game
                    game.initDeck();
                    game.deal();
                    game.updateUI();

                    // If AI starts, begin their turn
                    if (game.currentPlayer !== 0) {
                        game.aiTurn();
                    }

                    console.log('%câœ… Game initialized!', 'color: #4caf50; font-weight: bold;');
                });
                
                // View Game button (closes modal, leaves game visible)
                const viewGameBtn = document.createElement('button');
                viewGameBtn.style.cssText = 'padding:15px 40px;background:#6c757d;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:16px;transition:transform 0.2s;';
                viewGameBtn.textContent = 'ğŸ‘€ View Game';
                viewGameBtn.addEventListener('mouseover', () => viewGameBtn.style.transform = 'scale(1.05)');
                viewGameBtn.addEventListener('mouseout', () => viewGameBtn.style.transform = 'scale(1)');
                viewGameBtn.addEventListener('click', () => {
                    modal.remove();
                    console.log('%cğŸ‘€ Viewing completed game', 'color: #6c757d; font-weight: bold;');
                });
                
                btnContainer.appendChild(playAgainBtn);
                btnContainer.appendChild(viewGameBtn);
                
                modalContent.appendChild(titleEl);
                modalContent.appendChild(msgEl);
                modalContent.appendChild(btnContainer);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
            }

            showModal(title, msg) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;';
                
                const titleEl = document.createElement('h2');
                titleEl.style.cssText = 'color:#ffd700;margin-bottom:15px;';
                titleEl.textContent = title;
                
                const msgEl = document.createElement('p');
                msgEl.style.cssText = 'color:white;margin-bottom:20px;white-space:pre-line;';
                msgEl.textContent = msg;
                
                const okBtn = document.createElement('button');
                okBtn.style.cssText = 'padding:12px 30px;background:#28a745;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;';
                okBtn.textContent = 'OK';
                okBtn.addEventListener('click', () => modal.remove());
                
                modalContent.appendChild(titleEl);
                modalContent.appendChild(msgEl);
                modalContent.appendChild(okBtn);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
            }



            showDisambiguationModal(card, playerIdx, cardIdx) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:10000;';

                modal.innerHTML = `
        <div style="background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;max-width:500px;">
            <h2 style="color:#ffd700;margin-bottom:15px;">ğŸ¯ Choose Sequence</h2>
            <p style="color:white;margin-bottom:20px;">
                ${card.toString()} can extend BOTH your triple and your ladder.<br><br>
                Which sequence do you want to add it to?
            </p>
            <div style="display:flex;gap:15px;justify-content:center;">
                <button id="chooseTriple" style="padding:12px 24px;background:#e74c3c;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                    Add to Triple
                </button>
                <button id="chooseLadder" style="padding:12px 24px;background:#3498db;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                    Add to Ladder
                </button>
            </div>
            <button id="cancelChoice" style="margin-top:15px;padding:8px 20px;background:#6b7280;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">
                Cancel
            </button>
        </div>`;

                document.body.appendChild(modal);

                // PATCH P: Fixed console.log syntax (was missing parentheses)
                document.getElementById('chooseTriple').onclick = () => {
                    console.log(`%câœ… FIX 6: User chose TRIPLE for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'triple');
                };

                document.getElementById('chooseLadder').onclick = () => {
                    console.log(`%câœ… FIX 6: User chose LADDER for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'ladder');
                };

                document.getElementById('cancelChoice').onclick = () => {
                    console.log(`%câŒ FIX 6: User cancelled`, 'color:#94a3b8');
                    modal.remove();
                };
            }



            executeAddToPublished(card, playerIdx, cardIdx, forceType) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const published = this.publishedSequences[playerIdx];

                // ğŸ¯ v4.2.7: When forceType is specified, user made explicit choice - DON'T re-separate!
                console.log(`%cğŸ¯ v4.2.7: executeAddToPublished - forceType: ${forceType}`, 'color:#9c27b0;font-weight:bold');

                // Remove card from hand
                this.playerHands[0].splice(cardIdx, 1);

                // ğŸ¯ v4.5.12 CRITICAL FIX: When forceType specified, ONLY check matching sequence type!
                let addedToSequence = false;
                for (let seq of published) {
                    // Determine if this sequence is triple or ladder
                    const isTriple = seq.length >= 3 && seq.every(c => c.rank === seq[0].rank);
                    const isLadder = !isTriple;
                    
                    // Only check if sequence type matches forceType
                    const typeMatches = (forceType === 'triple' && isTriple) || (forceType === 'ladder' && isLadder);
                    
                    if (typeMatches && this.canAddToPublishedSequence(card, seq)) {
                        seq.push(card);
                        
                        // v4.5.12 FIX: Auto-sort ladder after extension for visual clarity
                        if (forceType === 'ladder') {
                            seq.sort((a, b) => a.getValue() - b.getValue());
                            console.log(`%c  ğŸ”„ v4.5.12: Re-sorted ladder after extension: ${seq.map(c => c.toString()).join('-')}`, 'color:#3b82f6;font-weight:bold');
                        }
                        
                        console.log(`%c  âœ… v4.5.12: Added ${card.toString()} to ${forceType} sequence: ${seq.map(c => c.toString()).join(' ')}`, 'color:#28a745;font-weight:bold');
                        addedToSequence = true;
                        break;
                    }
                }
                
                if (!addedToSequence) {
                    console.log(`%c  âš ï¸ v4.5.12: Could not add to existing ${forceType} sequence, creating new`, 'color:#f59e0b;');
                    published.push([card]);
                }
                
                this.selectedCards = [];
                this.updateUI();
            }

            // ğŸ¯ v4.0.7: Sort published sequences while respecting explicit user assignments
            sortPublishedSequences(playerIdx) {
                // ğŸ¯ v4.0.7 FIX: Get flat view of published cards since we need to resort
                const allPublished = this.getFlatPublished(playerIdx);
                const tripleCards = [];
                const ladderCards = [];
                
                // Count occurrences for auto-categorization
                const rankCounts = {};
                allPublished.forEach(c => {
                    rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1;
                });
                
                // Categorize each card
                const processedRanks = new Set();
                
                allPublished.forEach(c => {
                    // ğŸ¯ v4.0.7: Check if card has explicit assignment from user
                    if (c.explicitAssignment === 'triple') {
                        console.log(`  ğŸ¯ v4.0.7: ${c.toString()} has explicit TRIPLE assignment`);
                        tripleCards.push(c);
                    } else if (c.explicitAssignment === 'ladder') {
                        console.log(`  ğŸ¯ v4.0.7: ${c.toString()} has explicit LADDER assignment`);
                        ladderCards.push(c);
                    } else {
                        // No explicit assignment - use count-based logic
                        if (rankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                            // This rank forms a triple - add all of this rank
                            const sameRank = allPublished.filter(card => 
                                card.rank === c.rank && !card.explicitAssignment
                            );
                            tripleCards.push(...sameRank);
                            processedRanks.add(c.rank);
                        } else if (!tripleCards.find(tc => tc.id === c.id)) {
                            // Not in a triple, must be ladder
                            ladderCards.push(c);
                        }
                    }
                });
                
                // Sort triples by value
                tripleCards.sort((a, b) => a.getValue() - b.getValue());
                
                // Sort ladders by suit then value  
                ladderCards.sort((a, b) => {
                    const suitOrder = { 'â™ ': 1, 'â™¥': 2, 'â™¦': 3, 'â™£': 4 };
                    if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                    return a.getValue() - b.getValue();
                });
                
                // ğŸ› FIX v4.1.2: Build sequences manually, respecting explicit assignments
                const sequences = [];
                
                // Group triples by rank
                const triplesByRank = {};
                tripleCards.forEach(c => {
                    if (!triplesByRank[c.rank]) triplesByRank[c.rank] = [];
                    triplesByRank[c.rank].push(c);
                });
                
                // Add each rank's cards as a sequence (handles 3, 4, 5+ of same rank)
                Object.values(triplesByRank).forEach(cards => {
                    sequences.push(cards);
                });
                
                // Group ladders by suit and find consecutive runs
                if (ladderCards.length >= 4) {
                    const laddersBySuit = {};
                    ladderCards.forEach(c => {
                        if (!laddersBySuit[c.suit]) laddersBySuit[c.suit] = [];
                        laddersBySuit[c.suit].push(c);
                    });
                    
                    Object.values(laddersBySuit).forEach(suitCards => {
                        if (suitCards.length >= 4) {
                            suitCards.sort((a, b) => a.getValue() - b.getValue());
                            sequences.push(suitCards);
                        }
                    });
                }
                
                this.publishedSequences[playerIdx] = sequences;
                
                console.log(`%cğŸ¯ v4.1.2: Sorted and separated - ${sequences.length} sequences`, 'color:#9c27b0;');
                sequences.forEach((seq, i) => {
                    console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString()).join(' ')}`);
                });
            }

            // ğŸ¯ v4.0.7: sortPublishedSequences complete


            // ============================================
            // VERIFICATION COMMANDS (for cross-version testing)
            // ============================================

            jumpToHand(handNum) {
                if (handNum < 1 || handNum > 7) {
                    console.log('âš ï¸ Hand must be 1-7');
                    return;
                }
                console.log(`ğŸ”§ Jumping to Hand ${handNum}...`);
                this.currentHand = handNum;
                this.playerBuys = handNum === 7 ? [2, 2, 2] : [3, 3, 3];
                this.publishedSequences = [[], [], []];
                this.playerHands = [[], [], []];
                this.selectedCards = [];
                this.gamePhase = 'draw';
                this.currentPlayer = 0;
                this.justPublished = false;
                this.aiJustPublished = [false, false, false];
                this.lastDiscard = null;
                this.lastDiscardByPlayer = -1;
                this.discardPile = [];
                this.turnCounter = 0;
                this.lastAIDiscard = [null, null, null];
                this.lastCardWarningShown = null;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                
                // ğŸ—ï¸ v4.5.12 FIX: Initialize staged construction when jumping to Hands 6-7
                if (handNum >= 6) {
                    console.log(`%cğŸ—ï¸ v4.5.12: Initializing STAGED CONSTRUCTION for Hand ${handNum}`, 'color: #9b59b6; font-weight: bold; font-size: 14px;');
                    this.aiConstructionStage = [null, 'building_L1', 'building_L1'];
                    this.aiStageStartTurn = [null, this.turnCounter, this.turnCounter]; // ğŸ’š v4.5.12: Track stage start
                    this.aiLockedSequences = [[], [], []];
                    this.aiTargetCards = [null, [], []];
                    this.aiSuitFocus = [null, [], []];
                }
                
                this.initDeck();
                this.deal();
                this.updateUI();
                console.log(`âœ… Hand ${handNum} started`);
            }

            resetScores() {
                console.log('ğŸ”§ Resetting all scores to 0...');
                persistentScores = [0, 0, 0];
                this.playerScores = [0, 0, 0];
                this.updateUI();
                console.log('âœ… Scores reset');
            }

            showState() {
                console.log('ğŸ“Š GAME STATE:');
                console.log(`  Hand: ${this.currentHand}/7`);
                console.log(`  Phase: ${this.gamePhase}`);
                console.log(`  Current Player: ${this.currentPlayer} (${['You', 'Habot', 'Jabot'][this.currentPlayer]})`);
                console.log(`  Scores: [${this.playerScores.join(', ')}]`);
                console.log(`  Buys: [${this.playerBuys.join(', ')}]`);
                console.log(`  Cards in hand: [${this.playerHands.map(h => h.length).join(', ')}]`);
                console.log(`  Published sequences: [${this.publishedSequences.map(p => p.length).join(', ')}]`);
                console.log(`  Deck: ${this.deck.length} cards`);
                console.log(`  Discard: ${this.discardPile.length} cards`);
            }

            verifySync() {
                const state = {
                    hand: this.currentHand,
                    phase: this.gamePhase,
                    player: this.currentPlayer,
                    scores: this.playerScores,
                    buys: this.playerBuys,
                    handSizes: this.playerHands.map(h => h.length),
                    published: this.publishedSequences.map(p => p.length),
                    deckSize: this.deck.length,
                    discardSize: this.discardPile.length
                };
                console.log('ğŸ” SYNC CHECK:', JSON.stringify(state, null, 2));
                return state;
            }

            updateUI() {
                const req = this.handReqs[this.currentHand];
                document.getElementById('currentHand').textContent = this.currentHand;
                document.getElementById('handRequirements').textContent = req.name;
                const progress = this.getPublishProgress();
                let progressParts = [];
                if (progress.needTriples > 0) progressParts.push(`${progress.hasTriples}/${progress.needTriples} triples`);
                if (progress.needLadders > 0) progressParts.push(`${progress.hasLadders}/${progress.needLadders} ladders`);
                const progressText = `${req.name} - You have: ${progressParts.join(', ')}`;
                document.getElementById('detailedRequirements').textContent = progressText;
                const reqEl = document.getElementById('detailedRequirements');
                reqEl.style.color = progress.canPublish ? '#28a745' : '#ffed4e';
                if (progress.canPublish) reqEl.classList.add('ready');
                else reqEl.classList.remove('ready');
                const turnText = this.currentPlayer === 0 ? 'Your Turn' : this.currentPlayer === 1 ? "Habot's Turn" : "Jabot's Turn";
                document.getElementById('turnIndicator').innerHTML = `${turnText} <span style="opacity:0.7;font-size:0.9em;">(Turn ${this.turnCounter})</span>`;
                document.getElementById('playerBuys').textContent = this.playerBuys[0];
                document.getElementById('player2Buys').textContent = this.playerBuys[1];
                document.getElementById('player3Buys').textContent = this.playerBuys[2];
                this.updateLeaderboard();
                const selInfo = document.getElementById('selectionInfo');
                const selCount = document.getElementById('selectedCount');
                if (this.selectedCards.length > 0) { selInfo.style.display = 'inline-block'; selCount.textContent = this.selectedCards.length }
                else selInfo.style.display = 'none';
                const playerHasPublished = this.publishedSequences[0].length > 0;
                const addSection = document.getElementById('addToPublishedSection');
                if (playerHasPublished && this.currentPlayer === 0 && this.gamePhase === 'discard' && this.selectedCards.length === 1 && !this.justPublished && this.playerHands[0].length > 1) addSection.style.display = 'block';
                else addSection.style.display = 'none';
                
                // ğŸ¨ v4.0.7: Update active-turn highlighting for round table layout
                document.querySelectorAll('.opponent-area, .player-area-center').forEach(el => el.classList.remove('active-turn'));
                if (this.currentPlayer === 0) {
                    const yourArea = document.querySelector('.player-area-center');
                    if (yourArea) yourArea.classList.add('active-turn');
                } else if (this.currentPlayer === 1) {
                    const habotArea = document.querySelector('.opponent-left');
                    if (habotArea) habotArea.classList.add('active-turn');
                } else if (this.currentPlayer === 2) {
                    const jabotArea = document.querySelector('.opponent-right');
                    if (jabotArea) jabotArea.classList.add('active-turn');
                }
                
                this.renderHand(); this.renderAIHands(); this.renderPublished();
                if (this.discardPile.length > 0) document.getElementById('topDiscard').textContent = this.discardPile[this.discardPile.length - 1].toString();
                document.getElementById('discardBtn').disabled = this.currentPlayer !== 0 || this.gamePhase !== 'discard' || this.selectedCards.length !== 1;

                // ğŸ¯ PATCH J: Only enable publish if can actually publish OR extend sequences
                const canPublishNew = this.canPublish(0);
                const canExtendExisting = this.publishedSequences[0].length > 0 &&
                    this.playerHands[0].some(card =>
                        this.publishedSequences[0].some(seq => this.canAddToPublishedSequence(card, seq))
                    );

                document.getElementById('publishBtn').disabled = this.currentPlayer !== 0 ||
                    this.gamePhase !== 'discard' ||
                    (!canPublishNew && !canExtendExisting);

                document.getElementById('buyBtn').disabled = !this.buyWindow.active || this.buyWindow.buyWindowPlayer !== 0 || this.playerBuys[0] <= 0;

                // ğŸ¯ v2.5.0: Check last card for all players (show alert only once per player)
                [0, 1, 2].forEach(p => {
                    if (this.playerHands[p].length === 1 && !this.lastCardAlertShown[p]) {
                        const playerName = p === 0 ? 'You' : p === 1 ? 'Habot' : 'Jabot';
                        showLastCardToast(playerName);
                        this.lastCardAlertShown[p] = true;  // Mark this player as alerted
                        console.log(`%câš ï¸ Last card alert shown for ${playerName}`, 'color: #ff9800; font-weight: bold;');
                    }
                });
            }

            updateLeaderboard() {
                // ğŸ‘‘ v4.0.7 Phase 3: Dynamic Crown & Pumpkin with Tie-Breaker Logic
                const container = document.getElementById('leaderboardEntries');
                if (!container) return;
                
                const names = ['You', 'Habot', 'Jabot'];
                const sorted = this.playerScores.map((score, idx) => ({ 
                    score, 
                    idx, 
                    name: names[idx] 
                })).sort((a, b) => a.score - b.score);
                
                // Find min and max scores
                const minScore = sorted[0].score;
                const maxScore = sorted[sorted.length - 1].score;
                
                // Determine crown winner (lowest score, tie-breaker: first to reach)
                const crownCandidates = sorted.filter(p => p.score === minScore);
                const crownWinner = crownCandidates.length > 1 
                    ? crownCandidates.reduce((first, current) => 
                        current.idx < first.idx ? current : first
                      )
                    : crownCandidates[0];
                
                // Determine pumpkin holder (highest score, tie-breaker: first to reach)
                const pumpkinCandidates = sorted.filter(p => p.score === maxScore);
                const pumpkinHolder = pumpkinCandidates.length > 1
                    ? pumpkinCandidates.reduce((first, current) =>
                        current.idx < first.idx ? current : first
                      )
                    : pumpkinCandidates[0];
                
                // ğŸ¨ v4.0.7: Display in VISUAL LAYOUT order for symmetry
                // Layout: Habot (left) | You (center) | Jabot (right)
                // Leaderboard order: [1]=Habot, [0]=You, [2]=Jabot
                const displayOrder = [
                    { score: this.playerScores[1], idx: 1, name: names[1] }, // Habot (left)
                    { score: this.playerScores[0], idx: 0, name: names[0] }, // You (center)
                    { score: this.playerScores[2], idx: 2, name: names[2] }  // Jabot (right)
                ];
                
                container.innerHTML = '';
                displayOrder.forEach((player) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';
                    
                    // Check if this player is currently winning or losing
                    const isWinning = player.score === minScore;
                    const isLosing = player.score === maxScore;
                    if (isWinning) entry.classList.add('first');
                    if (isLosing) entry.classList.add('last');
                    
                    // Award crown and pumpkin based on logic (not just position)
                    const hasCrown = player.idx === crownWinner.idx;
                    const hasPumpkin = player.idx === pumpkinHolder.idx;
                    
                    entry.innerHTML = `
                        <div class="leaderboard-name">
                            ${hasCrown ? 'ğŸ‘‘ ' : ''}${player.name}${hasPumpkin ? ' ğŸƒ' : ''}
                        </div>
                        <div class="leaderboard-score">${player.score} pts</div>
                    `;
                    container.appendChild(entry);
                });
            }

            renderHand() {
                const container = document.getElementById('playerCards');
                container.innerHTML = '';
                this.playerHands[0].forEach((card, i) => {
                    const el = document.createElement('div');
                    el.className = `card ${card.getColor()}`;
                    if (card.suit === 'â™¥') el.classList.add('heart');
                    if (card.suit === 'â™¦') el.classList.add('diamond');
                    if (this.selectedCards.includes(i)) el.classList.add('selected');
                    el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                    el.draggable = true;
                    el.dataset.index = i;
                    el.onclick = () => {
                        const idx = this.selectedCards.indexOf(i);
                        if (idx > -1) this.selectedCards.splice(idx, 1);
                        else this.selectedCards = [i];
                        this.updateUI();
                    };
                    el.addEventListener('dragstart', (e) => { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', i); el.classList.add('dragging') });
                    el.addEventListener('dragend', (e) => { el.classList.remove('dragging'); document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-over')) });
                    el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move' });
                    el.addEventListener('dragenter', (e) => { e.preventDefault(); if (el !== document.querySelector('.dragging')) el.classList.add('drag-over') });
                    el.addEventListener('dragleave', (e) => { el.classList.remove('drag-over') });
                    el.addEventListener('drop', (e) => {
                        e.preventDefault();
                        el.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = parseInt(el.dataset.index);
                        if (fromIdx !== toIdx) this.moveCard(fromIdx, toIdx);
                    });
                    container.appendChild(el);
                });
            }

            moveCard(fromIdx, toIdx) {
                const card = this.playerHands[0].splice(fromIdx, 1)[0];
                this.playerHands[0].splice(toIdx, 0, card);
                this.selectedCards = this.selectedCards.map(idx => {
                    if (idx === fromIdx) return toIdx;
                    if (fromIdx < toIdx) { if (idx > fromIdx && idx <= toIdx) return idx - 1 }
                    else { if (idx >= toIdx && idx < fromIdx) return idx + 1 }
                    return idx;
                });
                this.updateUI();
            }

            renderAIHands() {
                // ğŸ´ v4.0.7 Phase 2: Show last 3 cards for AI players
                [1, 2].forEach(p => {
                    const container = document.getElementById(`player${p + 1}Cards`);
                    const countBadge = document.getElementById(`player${p + 1}Count`);
                    container.innerHTML = '';
                    
                    const hand = this.playerHands[p];
                    const handSize = hand.length;
                    
                    // Update card count badge
                    if (countBadge) {
                        countBadge.textContent = handSize;
                    }
                    
                    if (handSize === 0) {
                        container.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">No cards</div>';
                        return;
                    }
                    
                    // Show last 3 cards (or fewer if hand is smaller)
                    const cardsToShow = Math.min(3, handSize);
                    const startIndex = Math.max(0, handSize - cardsToShow);
                    
                    for (let i = startIndex; i < handSize; i++) {
                        const el = document.createElement('div');
                        el.className = 'card';
                        el.style.background = '#2c3e50';
                        el.style.cursor = 'default';
                        el.innerHTML = `<div style="font-size: 28px; color: rgba(255,255,255,0.4);">?</div>`;
                        container.appendChild(el);
                    }
                    
                    // Add hidden cards indicator if more than 3 cards
                    if (handSize > 3) {
                        const hiddenEl = document.createElement('div');
                        hiddenEl.style.fontSize = '.75rem';
                        hiddenEl.style.color = 'var(--muted)';
                        hiddenEl.style.textAlign = 'center';
                        hiddenEl.style.marginTop = '6px';
                        hiddenEl.textContent = `+${handSize - 3} hidden`;
                        container.appendChild(hiddenEl);
                    }
                });
            }

            renderPublished() {
                [0, 1, 2].forEach(p => {
                    const containerId = p === 0 ? 'player1Cards' : `player${p + 1}CardsPublished`;
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    
                    // ğŸ¯ v4.5.12: Render each sequence SEPARATELY with visual gaps
                    const sequences = this.publishedSequences[p];
                    if (!sequences || sequences.length === 0) return;
                    
                    sequences.forEach((seq, seqIdx) => {
                        // Add visible sequence separator between sequences
                        if (seqIdx > 0) {
                            const separator = document.createElement('div');
                            separator.style.cssText = 'width: 3px; height: 80px; background: rgba(255, 215, 0, 0.3); border-radius: 2px; margin: 0 10px;';
                            container.appendChild(separator);
                        }
                        
                        // Track unique cards within THIS sequence
                        const seenIds = new Set();
                        
                        seq.forEach(card => {
                            if (!seenIds.has(card.id)) {
                                const el = document.createElement('div');
                                el.className = `card ${card.getColor()}`;
                                if (card.suit === 'â™¥') el.classList.add('heart');
                                if (card.suit === 'â™¦') el.classList.add('diamond');
                                el.style.transform = 'scale(0.7)';
                                el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                                container.appendChild(el);
                                seenIds.add(card.id);
                            }
                        });
                    });
                });
            }
        }

        // Global functions
        function showPublishSelector(seqs, req) {
            const selector = document.getElementById('publishSelector');
            const options = document.getElementById('publishOptions');
            options.innerHTML = '';

            game.publishSelection = { triples: [], ladders: [] };

            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            // âœ… FIX 5C: Map card IDs to consistent numbers ACROSS ALL SEQUENCES
            const duplicateCards = {};
            const cardIdToNumber = new Map();
            let nextNumber = 1;

            // First pass: Identify all duplicate rank+suit combinations
            game.playerHands[0].forEach(card => {
                const key = card.rank + card.suit;
                if (!duplicateCards[key]) duplicateCards[key] = [];
                duplicateCards[key].push(card);
            });

            // Assign consistent numbers to each UNIQUE CARD ID (only for duplicates)
            Object.entries(duplicateCards).forEach(([key, cards]) => {
                if (cards.length > 1) {
                    cards.forEach(card => {
                        cardIdToNumber.set(card.id, nextNumber++);
                    });
                }
            });

            console.log('%câœ… FIX 5C: Card ID mapping:', 'color:#4a90e2;font-weight:bold');
            cardIdToNumber.forEach((num, id) => {
                const card = game.playerHands[0].find(c => c.id === id);
                if (card) console.log(`  ${card.toString()} (id:${id.substr(0, 4)}) â†’ Badge #${num}`);
            });

            if (triplesNeeded > 0) {
                const tripleDiv = document.createElement('div');
                tripleDiv.className = 'publish-option';
                tripleDiv.innerHTML = `<h4>Select ${triplesNeeded} Triple(s):</h4><div class="option-cards" id="tripleOptions"></div>`;
                options.appendChild(tripleDiv);

                const tripleContainer = document.getElementById('tripleOptions');

                seqs.triples.forEach((triple, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;position:relative;';
                    optDiv.onclick = () => toggleTripleSelection(idx, optDiv);

                    triple.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === 'â™¥') cardEl.classList.add('heart');
                        if (card.suit === 'â™¦') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // âœ… FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                                        <div class="card-rank">${card.rank}</div>
                                        <div class="card-suit">${card.suit}</div>
                                        ${duplicateLabel}
                                    `;
                        optDiv.appendChild(cardEl);
                    });

                    tripleContainer.appendChild(optDiv);
                });
            }

            if (laddersNeeded > 0) {
                const ladderDiv = document.createElement('div');
                ladderDiv.className = 'publish-option';
                ladderDiv.innerHTML = `<h4>Select ${laddersNeeded} Ladder(s):</h4><div class="option-cards" id="ladderOptions"></div>`;
                options.appendChild(ladderDiv);

                const ladderContainer = document.getElementById('ladderOptions');

                seqs.ladders.forEach((ladder, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;';
                    optDiv.onclick = () => toggleLadderSelection(idx, optDiv);

                    ladder.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === 'â™¥') cardEl.classList.add('heart');
                        if (card.suit === 'â™¦') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // âœ… FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                                        <div class="card-rank">${card.rank}</div>
                                        <div class="card-suit">${card.suit}</div>
                                        ${duplicateLabel}
                                    `;
                        optDiv.appendChild(cardEl);
                    });

                    ladderContainer.appendChild(optDiv);
                });
            }

            selector.classList.add('active');
        }

        function toggleTripleSelection(idx, element) {
            const selected = game.publishSelection.triples;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function toggleLadderSelection(idx, element) {
            const selected = game.publishSelection.ladders;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function confirmManualPublish() {
            const req = game.handReqs[game.currentHand].seqs;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            if (game.publishSelection.triples.length !== triplesNeeded ||
                game.publishSelection.ladders.length !== laddersNeeded) {
                game.showModal('Invalid Selection', `You must select exactly ${triplesNeeded} triple(s) and ${laddersNeeded} ladder(s)`);
                return;
            }

            const seqs = game.findSequences(game.playerHands[0]);
            let published = [];
            game.publishSelection.triples.forEach(idx => { published = published.concat(seqs.triples[idx]) });
            game.publishSelection.ladders.forEach(idx => { published = published.concat(seqs.ladders[idx]) });

            // v4.5.12 CRITICAL FIX: Smart-assign card IDs before validation
            // IMPORTANT: De-duplication may leave SAME card object in multiple patterns
            // We need to track which card OBJECTS we've seen, not just IDs
            const usedIdsForAssignment = new Set();
            const processedObjects = new Set();  // Track actual object references
            
            published.forEach((card, index) => {
                // Check if we've already processed this exact card OBJECT
                if (processedObjects.has(card)) {
                    console.log(`%c  âš ï¸  v4.5.12: Card object ${card.rank}${card.suit} appears multiple times! Finding replacement...`, 'color:#f59e0b;font-weight:bold');
                    
                    // This card object is reused! Find a different card instance
                    const availableCard = game.playerHands[0].find(c => 
                        c.rank === card.rank && 
                        c.suit === card.suit && 
                        !usedIdsForAssignment.has(c.id)
                    );
                    
                    if (availableCard) {
                        // REPLACE the card object entirely (not just modify ID)
                        published[index] = availableCard;
                        usedIdsForAssignment.add(availableCard.id);
                        processedObjects.add(availableCard);
                        console.log(`%c  âœ… v4.5.12: Replaced with ${availableCard.rank}${availableCard.suit} (ID: ${availableCard.id})`, 'color:#28a745;');
                    } else {
                        console.log(`%c  âŒ v4.5.12: No available card found for ${card.rank}${card.suit}!`, 'color:#ef4444;font-weight:bold');
                    }
                } else {
                    // First time seeing this card object - check if we need to reassign
                    const availableCard = game.playerHands[0].find(c => 
                        c.rank === card.rank && 
                        c.suit === card.suit && 
                        !usedIdsForAssignment.has(c.id)
                    );
                    
                    if (availableCard) {
                        published[index] = availableCard;
                        usedIdsForAssignment.add(availableCard.id);
                        processedObjects.add(availableCard);
                        console.log(`%c  ğŸ”„ v4.5.12: Assigned ${card.rank}${card.suit} â†’ ID ${availableCard.id}`, 'color:#3b82f6;');
                    }
                }
            });
            
            console.log(`%câœ… v4.5.12: Smart-assigned ${published.length} cards with unique IDs`, 'color:#28a745;font-weight:bold');

            // ========== START FIX 5: REPLACE FROM HERE ==========

            // âœ… FIX 5: Check for duplicate card IDs (same physical card used twice)
            const usedCardIds = new Set();
            let hasDuplicateCard = false;
            let duplicateCard = null;

            for (let card of published) {
                if (usedCardIds.has(card.id)) {
                    hasDuplicateCard = true;
                    duplicateCard = card;
                    break;
                }
                usedCardIds.add(card.id);
            }

            if (hasDuplicateCard) {
                console.log('%cğŸš¨ FIX 5: Duplicate card detected!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${duplicateCard.toString()} appears in multiple sequences`);
                game.showModal('Duplicate Card',
                    `You selected ${duplicateCard.toString()} in multiple sequences!\n\n` +
                    `Each card can only be used once.\n` +
                    `Please reselect your sequences.`);
                return;
            }

            // âœ… FIX 5: Also check rank+suit counts (belt-and-suspenders validation)
            const selectedCards = {};
            published.forEach(c => {
                const key = c.rank + c.suit;
                selectedCards[key] = (selectedCards[key] || 0) + 1;
            });

            const handCards = {};
            game.playerHands[0].forEach(c => {
                const key = c.rank + c.suit;
                handCards[key] = (handCards[key] || 0) + 1;
            });

            let hasOverlap = false;
            let overlapCard = '';
            for (let key in selectedCards) {
                if (selectedCards[key] > handCards[key]) {
                    hasOverlap = true;
                    overlapCard = key;
                    break;
                }
            }

            if (hasOverlap) {
                console.log('%cğŸš¨ FIX 5: Card count overlap!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${overlapCard} - selected more than available`);
                game.showModal('Insufficient Cards',
                    `You selected more ${overlapCard} cards than you have!\n\n` +
                    `Please reselect your sequences.`);
                return;
            }

            console.log('%câœ… FIX 5: Validation passed - no duplicates', 'color:#28a745;font-weight:bold');

            // ========== END FIX 5: REPLACE TO HERE ==========

            // âœ… KEEP EVERYTHING BELOW (Execution section - unchanged)
            published.forEach(c => { const idx = game.playerHands[0].findIndex(card => card.id === c.id); if (idx > -1) game.playerHands[0].splice(idx, 1) });
            
            // v4.5.12 CRITICAL FIX: Rebuild sequences from modified published array
            // The published array has the correct card instances (with smart assignment)
            // We need to split it back into sequences based on user's original selections
            const sequences = [];
            let publishedIndex = 0;
            
            // Add selected triples (in order of selection)
            game.publishSelection.triples.forEach(idx => {
                const originalSeq = seqs.triples[idx];
                const rebuiltSeq = [];
                for (let i = 0; i < originalSeq.length; i++) {
                    rebuiltSeq.push(published[publishedIndex++]);
                }
                sequences.push(rebuiltSeq);
            });
            
            // Add selected ladders (in order of selection)
            game.publishSelection.ladders.forEach(idx => {
                const originalSeq = seqs.ladders[idx];
                const rebuiltSeq = [];
                for (let i = 0; i < originalSeq.length; i++) {
                    rebuiltSeq.push(published[publishedIndex++]);
                }
                sequences.push(rebuiltSeq);
            });
            
            game.publishedSequences[0] = sequences;
            
            console.log(`%cğŸ¯ v4.5.12: Published ${sequences.length} sequences with smart-assigned cards`, 'color: #27ae60; font-weight: bold;');
            sequences.forEach((seq, i) => {
                console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString() + '(' + c.id.substring(0,4) + ')').join(' ')}`);
            });
            
            game.justPublished = true;
            cancelManualPublish();
            if (game.playerHands[0].length === 0) { game.endHand(0); return }
            game.updateUI();
        }

        function cancelManualPublish() { document.getElementById('publishSelector').classList.remove('active'); game.publishSelection = null }

        function addToPublished(playerIdx) {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            if (game.justPublished) { game.showModal('Cannot Add', 'Cannot add in same turn you published!'); return }
            if (game.publishedSequences[playerIdx].length === 0) {
                game.showModal('Cannot Add', `${playerIdx === 0 ? 'You have' : (playerIdx === 1 ? 'Habot has' : 'Jabot has')} not published yet!`);
                return;
            }

            const cardIdx = game.selectedCards[0];
            const card = game.playerHands[0][cardIdx];
            const req = game.handReqs[game.currentHand].seqs;
            const hasTriples = req.some(s => s === 'triple');
            const hasLadders = req.some(s => s === 'ladder');
            const published = game.getFlatPublished(playerIdx);

            // âœ… FIX 6: Check if card could extend BOTH triple AND ladder (AMBIGUOUS!)
            const rankCounts = {};
            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });

            const canExtendTriple = hasTriples && rankCounts[card.rank] >= 3;

            let canExtendLadder = false;
            if (hasLadders) {
                // âœ… FIX 6A: First separate triples from ladders to avoid confusion
                const allRankCounts = {};
                published.forEach(c => { allRankCounts[c.rank] = (allRankCounts[c.rank] || 0) + 1 });

                const tripleCards = [];
                const ladderCards = [];
                const processedRanks = new Set();

                published.forEach(c => {
                    if (allRankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                        const sameRank = published.filter(card => card.rank === c.rank);
                        tripleCards.push(...sameRank);
                        processedRanks.add(c.rank);
                    }
                });

                published.forEach(c => {
                    if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                });

                console.log(`%cğŸ” FIX 6A: Separated - Triples: ${tripleCards.map(c => c.toString()).join(' ')}, Ladders: ${ladderCards.map(c => c.toString()).join(' ')}`, 'color:#4a90e2');

                // Now check if card can extend ONLY the ladder cards (not triples)
                const sameSuit = ladderCards.filter(c => c.suit === card.suit);
                if (sameSuit.length >= 4) {

                    const cardVal = card.getValue();
                    const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                    const ladders = [];
                    let remainingValues = [...values];
                    const hasAce = values.includes(1);
                    const hasJack = values.includes(11);
                    const hasQueen = values.includes(12);
                    const hasKing = values.includes(13);

                    if (hasAce && hasJack && hasQueen && hasKing) {
                        // ğŸ”§ FIX 8 (v4.0.7): Extract ALL consecutive cards from King downward
                        // Bug: Previous code only checked v >= 11, missing cards like 9-10
                        const wrapLadder = [1];  // Start with Ace (value 1)
                        
                        // Get ALL non-ace cards sorted from high to low
                        const sortedCards = values.filter(v => v >= 2).sort((a, b) => b - a);
                        
                        // Start from King (13) and work downward, taking consecutive cards
                        let expectedValue = 13;
                        for (let val of sortedCards) {
                            if (val === expectedValue) {
                                wrapLadder.push(val);
                                expectedValue--;
                            } else if (val < expectedValue) {
                                // Gap found - stop here
                                break;
                            }
                        }
                        
                        console.log(`  ğŸ”§ FIX 8: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                        ladders.push(wrapLadder);
                        remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                    }

                    if (remainingValues.length >= 4) {
                        let currentLadder = [remainingValues[0]];
                        for (let i = 1; i < remainingValues.length; i++) {
                            if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                currentLadder.push(remainingValues[i]);
                            } else {
                                if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                currentLadder = [remainingValues[i]];
                            }
                        }
                        if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                    }
                    canExtendLadder = ladders.some(ladder => {
                        return game.canCardExtendLadder(cardVal, ladder);
                    });
                }
            }

            // âœ… FIX 6: AMBIGUOUS - card could go to EITHER sequence!
            if (canExtendTriple && canExtendLadder) {
                console.log(`%cğŸš¨ FIX 6: AMBIGUOUS - ${card.toString()} could extend BOTH triple and ladder!`, 'color:#ff6b35;font-weight:bold');
                game.showDisambiguationModal(card, playerIdx, cardIdx);
                return;
            }

            // ğŸ¯ v4.0.7 FIX: published is already 2D, no need to separate again!
            if (!canExtendTriple && !canExtendLadder) {
                // published is already [[seq1], [seq2], ...] in v4.0.x
                const publishedSeqs = game.publishedSequences[playerIdx];

                console.log(`  ğŸ”§ PATCH S (v4.0.7): Validating ${card.toString()} against ${publishedSeqs.length} sequences`);

                let canExtendAny = false;
                for (let seq of publishedSeqs) {
                    // seq is already an array of cards, can pass directly
                    if (game.canAddToPublishedSequence(card, seq)) {
                        console.log(`  ğŸ”§ PATCH S: âœ… Can extend sequence`);
                        canExtendAny = true;
                        break;
                    }
                }

                if (!canExtendAny) {
                    console.log(`  ğŸ”§ PATCH S: âŒ Cannot extend any sequence after validation`);
                    let errorMsg = 'This card does not extend any sequence!\n\n';
                    if (hasTriples && !hasLadders) errorMsg += 'This hand only allows TRIPLES.';
                    else if (hasLadders && !hasTriples) errorMsg += 'This hand only allows LADDERS.';
                    else errorMsg += 'For triples: Need 3+ same rank.\nFor ladders: Need 3+ consecutive same suit.';
                    game.showModal('Invalid Card', errorMsg);
                    return;
                }
            }

            // Only one option available - use executeAddToPublished
            const forceType = canExtendTriple ? 'triple' : 'ladder';
            game.executeAddToPublished(card, playerIdx, cardIdx, forceType);

            // --- NEW: Auto-Expand AI Area if human extended their sequence ---
            // playerIdx 1 = Habot, playerIdx 2 = Jabot
            if (playerIdx === 1 || playerIdx === 2) {
                const aiId = playerIdx === 1 ? 'habot-area' : 'jabot-area';
                const content = document.getElementById(aiId).querySelector('.ai-content');

                // Only toggle if it is currently collapsed to avoid unnecessary flicker
                if (content.classList.contains('collapsed')) {
                    // NOTE: The toggleAIArea function will handle the expansion animation
                    toggleAIArea(aiId);
                }
            }
            // -----------------------------------------------------------------
        } // End of function

        //Nash: newGame
        // ============================================
        // EVENT LISTENERS (v4.1.1 - CSP Compliance)
        // ============================================
        window.onload = () => {
            // Main action buttons
            document.getElementById('publishBtn').addEventListener('click', publishSequences);
            document.getElementById('discardBtn').addEventListener('click', discardCard);
            document.getElementById('buyBtn').addEventListener('click', buyCard);
            document.getElementById('newGameBtn').addEventListener('click', newGame);
            
            // Sorting buttons
            document.getElementById('sortByRankBtn').addEventListener('click', sortByRank);
            document.getElementById('sortBySuitBtn').addEventListener('click', sortBySuit);
            document.getElementById('sortByQuantityBtn').addEventListener('click', sortByQuantity);
            
            // Deck interaction
            document.getElementById('drawDeck').addEventListener('click', drawFromDeck);
            document.getElementById('discardPile').addEventListener('click', drawFromDiscard);
            
            // Manual publish buttons
            document.getElementById('confirmManualPublish').addEventListener('click', confirmManualPublish);
            document.getElementById('cancelManualPublish').addEventListener('click', cancelManualPublish);
            
            // Add to published buttons (delegate by data-player attribute)
            document.querySelectorAll('.add-to-published').forEach(btn => {
                btn.addEventListener('click', function() {
                    const playerIdx = parseInt(this.getAttribute('data-player'));
                    addToPublished(playerIdx);
                });
            });
            
            // Start the game
            newGame();
        };

        // ============================================
        // ğŸ¨ FIX 7B: Custom Confirmation Modal
        // ============================================
        function showConfirmModal(title, message, confirmText = 'Confirm', cancelText = 'Cancel') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                // Set content
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                confirmBtn.textContent = confirmText;
                cancelBtn.textContent = cancelText;

                // Show modal
                modal.classList.add('active');

                // Handle confirm
                const handleConfirm = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                // Handle cancel
                const handleCancel = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);

                // Close on overlay click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on ESC key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // ============================================
        // ğŸ® HAND SELECTION MODAL
        // ============================================
        function showHandSelectionModal() {
            return new Promise((resolve) => {
                const modal = document.getElementById('handSelectionModal');
                const confirmBtn = document.getElementById('handSelectionConfirm');
                const cancelBtn = document.getElementById('handSelectionCancel');

                // Show modal
                modal.classList.add('active');

                // Handle confirm
                const handleConfirm = () => {
                    const selectedRadio = document.querySelector('input[name="handSelection"]:checked');
                    const selection = selectedRadio ? selectedRadio.value : 'full';
                    
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    
                    // Return selection: 'full' or '1'-'7'
                    resolve(selection);
                };

                // Handle cancel
                const handleCancel = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(null); // null means cancelled
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);

                // Close on overlay click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on ESC key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // ============================================
        // ğŸ­ v2.5.0: CHARACTER BANTER SYSTEM
        // ============================================

        function getOpeningBanter() {
            const banterPool = [
                // Habot aggressive openers
                { speaker: 'Habot', text: "Let's see who fortune favors today!", personality: 'confident' },
                { speaker: 'Habot', text: "High card takes it - may the best player win!", personality: 'competitive' },
                { speaker: 'Habot', text: "Ready to see how luck plays out?", personality: 'eager' },
                { speaker: 'Habot', text: "Time to find out who leads the charge!", personality: 'bold' },

                // Jabot patient responses
                { speaker: 'Jabot', text: "Patience... the cards will tell the story.", personality: 'calm' },
                { speaker: 'Jabot', text: "Let's draw and see what fate decides.", personality: 'measured' },
                { speaker: 'Jabot', text: "The highest card speaks for itself.", personality: 'philosophical' },
                { speaker: 'Jabot', text: "A fair draw reveals the path forward.", personality: 'wise' }
            ];

            // Pick one from each personality
            const habotLine = banterPool.filter(b => b.speaker === 'Habot')[Math.floor(Math.random() * 4)];
            const jabotLine = banterPool.filter(b => b.speaker === 'Jabot')[Math.floor(Math.random() * 4)];

            return [habotLine, jabotLine];
        }

        function getWinReaction(winner, winnerCard, loserCards) {
            const reactions = {
                // Winner reactions
                winner: {
                    0: [  // Human wins
                        "Looks like fortune favors you today!",
                        "Well drawn! You'll lead us off.",
                        "A strong start - the table is yours!",
                        "Lady Luck smiles on you this hand."
                    ],
                    1: [  // Habot wins (confident/aggressive)
                        "Habot: Yes! The rabbit leads the race!",
                        "Habot: Perfect. Time to set the pace.",
                        "Habot: High card, high energy - let's go!",
                        "Habot: I'll show you how it's done."
                    ],
                    2: [  // Jabot wins (calm/strategic)
                        "Jabot: Interesting. I shall start with care.",
                        "Jabot: The cards have spoken. I begin.",
                        "Jabot: A thoughtful start, as it should be.",
                        "Jabot: Patience rewards... even in the draw."
                    ]
                },
                // Loser reactions
                graceful: [
                    "Well drawn!",
                    "Fair enough.",
                    "The cards decided.",
                    "So it goes."
                ],
                competitive: [
                    "Next time!",
                    "We'll see how this plays out.",
                    "The game hasn't started yet.",
                    "Just wait..."
                ]
            };

            const winnerReaction = reactions.winner[winner][Math.floor(Math.random() * 4)];

            // Loser reactions based on personality
            const loserReactions = [];
            if (winner !== 1) {  // Habot lost
                loserReactions.push({ speaker: 'Habot', text: reactions.competitive[Math.floor(Math.random() * 4)] });
            }
            if (winner !== 2) {  // Jabot lost
                loserReactions.push({ speaker: 'Jabot', text: reactions.graceful[Math.floor(Math.random() * 4)] });
            }

            return { winner: winnerReaction, losers: loserReactions };
        }

        function getSuitExplanation() {
            return {
                title: "â™ â™¥â™¦â™£ Suit Hierarchy",
                message: "In Bridge tradition:\nâ™  Spades (highest)\nâ™¥ Hearts\nâ™¦ Diamonds  \nâ™£ Clubs (lowest)",
                tip: "Highest rank wins. If tied, highest suit breaks the tie."
            };
        }

        // ============================================
        // ğŸ¨ FIX 7D: Info Modal with Auto-Fade
        // ============================================
        function showInfoModal(title, message, buttonText = 'Got it!', icon = 'ğŸ’¬', autoFade = true, fadeDelay = 3000) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const modalIcon = document.querySelector('.modal-icon');
                const modalContent = document.querySelector('.modal-content');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                modalIcon.textContent = icon;
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                confirmBtn.textContent = buttonText;
                cancelBtn.style.display = 'none';

                let fadeIndicator = null;
                let skipHint = null;
                if (autoFade) {
                    fadeIndicator = document.createElement('div');
                    fadeIndicator.className = 'modal-auto-fade-indicator';
                    modalContent.appendChild(fadeIndicator);

                    skipHint = document.createElement('div');
                    skipHint.className = 'modal-skip-hint';
                    skipHint.textContent = 'Click or ESC to skip';
                    modalContent.appendChild(skipHint);
                }

                modal.classList.add('active');
                modal.classList.remove('fading-out');

                let fadeTimeout = null;
                let hasResolved = false;

                const handleClose = (wasAutomatic = false) => {
                    if (hasResolved) return;
                    hasResolved = true;

                    if (fadeTimeout) clearTimeout(fadeTimeout);

                    modal.classList.add('fading-out');

                    setTimeout(() => {
                        modal.classList.remove('active', 'fading-out');
                        cancelBtn.style.display = '';

                        if (fadeIndicator && fadeIndicator.parentNode) {
                            fadeIndicator.remove();
                        }
                        if (skipHint && skipHint.parentNode) {
                            skipHint.remove();
                        }

                        confirmBtn.removeEventListener('click', handleManualClose);
                        resolve(true);
                    }, 500);
                };

                const handleManualClose = () => handleClose(false);

                if (autoFade) {
                    fadeTimeout = setTimeout(() => {
                        handleClose(true);
                    }, fadeDelay);
                }

                confirmBtn.addEventListener('click', handleManualClose);

                const handleOverlayClick = (e) => {
                    if (e.target === modal) handleManualClose();
                };
                modal.addEventListener('click', handleOverlayClick);

                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleManualClose();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);

                setTimeout(() => {
                    modal.removeEventListener('click', handleOverlayClick);
                    document.removeEventListener('keydown', handleEscape);
                }, fadeDelay + 1000);
            });
        }

        async function newGame() {
            // Step 1: Show hand selection modal
            const selectedHand = await showHandSelectionModal();
            
            if (selectedHand === null) {
                return; // User cancelled hand selection
            }

            // Step 2: âœ… FIX 7B: Custom confirmation modal (no "This page says"!)
            if (game && game.gamePhase !== 'end') {
                const confirmed = await showConfirmModal(
                    'Start New Game?',
                    'This will end the current game and reset all scores.\n\nAre you sure you want to continue?',
                    'Start New Game',
                    'Continue Playing'
                );

                if (!confirmed) {
                    return; // User cancelled
                }
            }

            // Step 3: Start new game with selected hand
            persistentScores = [0, 0, 0];
            game = new GameState(false, selectedHand);
        }

        function drawFromDeck() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;
            if (game.buyWindow.active) game.closeBuyWindow('player-turn');
            if (game.deck.length === 0) { if (!game.reshuffleDeck()) { alert('Deck is empty!'); return } game.updateUI() }
            if (game.deck.length > 0) {
                const drawnCard = game.deck.pop();
                game.playerHands[0].push(drawnCard);
                game.gamePhase = 'discard';
                game.turnCounter++;
                game.updateUI();
            }
        }

        function drawFromDiscard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;

            // ğŸ”’ v4.1.3: Glass vault rule - check if discard pile is accessible
            if (!game.discardPileAccessible) {
                showInfoModal(
                    'Discard Pile Locked',
                    'The discard pile is locked. The last card was taken, so you must draw from the deck.',
                    'Okay',
                    'ğŸ”’',
                    true,    // auto-fade
                    2000     // 2 seconds
                );
                return;
            }

            // ğŸ¨ v2.5: Show modal if discard pile is empty
            if (game.discardPile.length === 0) {
                showInfoModal(
                    'Discard Pile Empty',
                    'The last card was taken by another player. Please draw from the deck instead.',
                    'Okay',
                    'ğŸ´',
                    true,    // auto-fade
                    2000     // 2 seconds
                );
                return;
            }

            const card = game.discardPile.pop();
            game.playerHands[0].push(card);
            game.discardPileAccessible = false; // ğŸ”’ v4.1.3: Lock vault after taking card
            if (game.buyWindow.active) game.closeBuyWindow('player-took');
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            game.gamePhase = 'discard';
            game.turnCounter++;
            game.updateUI();
        }

        function discardCard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            const card = game.playerHands[0].splice(game.selectedCards[0], 1)[0];
            game.discardPile.push(card);
            game.discardPileAccessible = true; // ğŸ”’ v4.1.3: Unlock vault - new card on top of glass
            game.selectedCards = [];
            game.lastDiscard = card;
            game.lastDiscardByPlayer = 0;
            game.justPublished = false;
            if (game.playerHands[0].length === 0) { game.updateUI(); setTimeout(() => { game.endHand(0) }, 500); return }
            game.currentPlayer = 1;
            game.gamePhase = 'draw';
            game.updateUI();
            if (game.currentPlayer !== 0) game.aiTurn();
        }

        function publishSequences() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard') return;
            if (!game.canPublish(0)) { game.showModal('Cannot Publish', 'You do not have the required sequences!'); return }
            const seqs = game.findSequences(game.playerHands[0]);
            const req = game.handReqs[game.currentHand].seqs;
            let needsManualSelection = false;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;
            if (seqs.triples.length > triplesNeeded || seqs.ladders.length > laddersNeeded) needsManualSelection = true;
            const rankCounts = {};
            game.playerHands[0].forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
            Object.values(rankCounts).forEach(count => { if (count >= 4) needsManualSelection = true });
            if (needsManualSelection) showPublishSelector(seqs, req);
            else {
                game.autoPublish(0);
                game.justPublished = true;
                if (game.playerHands[0].length === 0) { game.endHand(0); return }
                game.updateUI();
            }
        }

        function buyCard() {
            if (!game || game.playerBuys[0] <= 0) return;
            if (!game.buyWindow.active || !game.buyWindow.card) return;
            if (game.buyWindow.buyWindowPlayer !== 0) return;
            const card = game.buyWindow.card;
            const idx = game.discardPile.findIndex(c => c.id === card.id);
            if (idx === -1) { game.closeBuyWindow('taken'); showToast('Card no longer available', 'warning', 2000); return }
            game.discardPile.splice(idx, 1);
            game.playerHands[0].push(card);
            game.discardPileAccessible = false; // ğŸ”’ v4.1.3: Lock vault after buy
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            if (game.deck.length === 0) { game.reshuffleDeck(); game.updateUI() }
            if (game.deck.length > 0) {
                const penalty = game.deck.pop();
                game.playerHands[0].push(penalty);
            }
            game.playerBuys[0]--;
            showToast(`You bought ${card.toString()}!`, 'buy', 2500);
            game.updateUI();
            game.closeBuyWindow('bought');
        }




        function sortByRank() {
            if (!game) return;
            game.playerHands[0].sort((a, b) => {
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortBySuit() {
            if (!game) return;
            const order = { 'â™ ': 1, 'â™¥': 2, 'â™¦': 3, 'â™£': 4 };
            game.playerHands[0].sort((a, b) => {
                if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                return a.getValue() - b.getValue();
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortByQuantity() {
            if (!game) return;
            const counts = {};
            game.playerHands[0].forEach(card => { counts[card.rank] = (counts[card.rank] || 0) + 1 });
            game.playerHands[0].sort((a, b) => {
                const countDiff = counts[b.rank] - counts[a.rank];
                if (countDiff !== 0) return countDiff;
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        // Toast Notification System
        function showToast(message, type = 'info', duration = 2500) {
            const container = document.querySelector('.toast-container') || createToastContainer();
            const toast = document.createElement('div');
            let bgColor, textColor, icon;
            switch (type) {
                case 'buy': bgColor = 'linear-gradient(135deg, #ffc107, #ff9800)'; textColor = '#000'; icon = 'ğŸ’°'; break;
                case 'warning': bgColor = 'linear-gradient(135deg, #ff6b35, #f7931e)'; textColor = '#fff'; icon = 'âš ï¸'; break;
                case 'win': bgColor = 'linear-gradient(135deg, #ffd700, #ffed4e)'; textColor = '#000'; icon = 'ğŸ†'; duration = 3000; break;
                default: bgColor = 'linear-gradient(135deg, #4ade80, #22c55e)'; textColor = '#000'; icon = 'â„¹ï¸';
            }
            toast.style.cssText = `background: ${bgColor}; color: ${textColor}; padding: 16px 24px; border-radius: 12px; font-weight: 900; font-size: 1.1rem; box-shadow: 0 8px 24px rgba(0,0,0,0.4); animation: slideIn 0.3s ease; pointer-events: auto; ${type === 'win' ? 'animation: slideIn 0.3s ease, victoryPulse 0.5s ease 0.3s 3;' : ''}`;
            toast.innerHTML = `${icon} ${message}`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => { toast.remove(); if (container.children.length === 0) container.remove() }, 300);
            }, duration);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }

        function showBuyToast(aiName, card) { showToast(`${aiName} BOUGHT ${card.toString()}!`, 'buy') }

        // ============================================
        // ğŸ¨ v2.5: Modal Notifications (Auto-Fade)
        // ============================================
        function showAITookCardToast(aiName, card) {
            console.log(`%cğŸš¨ FIX 2: Showing AI took card modal (auto-fade)`, 'color: #ff6b35; font-weight: bold;');
            // Auto-fades after 2.5 seconds - quick notification
            showInfoModal(
                `${aiName} Bought Card`,
                `${aiName} took the ${card.toString()} from the discard pile.`,
                'Continue',
                'ğŸ’°',
                true,    // auto-fade enabled
                2500     // 2.5 seconds
            );
        }

        function showLastCardToast(playerName) {
            const verb = playerName === 'You' ? 'have' : 'has';
            // NO auto-fade - critical warning!
            showInfoModal(
                'âš ï¸ Last Card Alert!',
                `${playerName} ${verb} only 1 card remaining!`,
                'Got it!',
                'ğŸƒ',
                false    // NO auto-fade - player must acknowledge
            );
        }

        function showWinToast(playerName) {
            const verb = (playerName === 'You') ? 'Win' : 'Wins';
            // NO auto-fade - game over message!
            showInfoModal(
                'ğŸ† Game Over!',
                `${playerName} ${verb}!`,
                'New Game',
                'ğŸ‰',
                false    // NO auto-fade - player must acknowledge
            );
        }

        // --- JAVASCRIPT: AI AREA TOGGLE FUNCTION ---
        function toggleAIArea(areaId) {
            const area = document.getElementById(areaId);
            if (!area) return; // Safety check

            const content = area.querySelector('.ai-content');
            const header = area.querySelector('.ai-header');

            const isCollapsed = content.classList.contains('collapsed');

            if (isCollapsed) {
                content.classList.remove('collapsed');
                header.setAttribute('data-expanded', 'true');
            } else {
                content.classList.add('collapsed');
                header.setAttribute('data-expanded', 'false');
            }
        }

    </script>
</body>
</html>