<!DOCTYPE html>
<html lang="en">
<!--
  Habib Punja - Strategic AI Card Game
  Version: 4.4.1 - Critical Initialization & Extension Fixes
  Release Date: November 17, 2025
  Developer: AgeOfBotsGames LLC
  Website: https://ageofbotsgames.com
  Copyright ¬© 2025 AgeOfBotsGames LLC. All rights reserved.

  üéÆ VERSION 4.4.1 - CRITICAL HOTFIX: Initialization & Extension
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: Staged construction now initializes in jumpToHand()
  üêõ Fixed: User extension choice now respected (triple vs ladder)
  
  **BUG 1 - Stage Stuck at 'initial':**
  Problem: When using game.jumpToHand(6), staged construction never initialized
  - Stage stayed at 'initial' instead of 'building_L1'
  - Buying logic failed because it checks for 'building_L1' stage
  - Result: AI never bought anything (Turn 37, zero buys)
  
  Fix: Added initialization to jumpToHand() function
  - Now runs whenever jumping to Hand 6 or 7
  - Stage correctly set to 'building_L1'
  - Targets and suit focus generated immediately
  
  **BUG 2 - Extension Added to Wrong Sequence:**
  Problem: User chose LADDER but card added to TRIPLE instead
  - executeAddToPublished() ignored forceType parameter
  - Checked ALL sequences, added to first match (triple)
  - Console: "User chose LADDER" but "Added to sequence: 7‚ô† 7‚ô£ 7‚ô¶ 7‚ô¶"
  
  Fix: Respect forceType when selecting sequence
  - If forceType='ladder', ONLY check ladder sequences
  - If forceType='triple', ONLY check triple sequences
  - Correctly adds 7‚ô¶ to diamond ladder: 7‚ô¶ 8‚ô¶ 9‚ô¶...
  
  **Testing Checklist:**
  ‚úÖ game.jumpToHand(6) ‚Üí Stage should be 'building_L1'
  ‚úÖ AI should generate targets immediately
  ‚úÖ AI should buy when target cards appear
  ‚úÖ Extension choice respected (ladder vs triple)
  
  üéÆ VERSION 4.4.0 - REVOLUTIONARY: Staged Construction Strategy!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üèóÔ∏è PARADIGM SHIFT: Sequential building instead of parallel accumulation
  
  **THE BREAKTHROUGH:**
  Games 6-7 require different strategy than Games 1-5!
  - Old: Try to form all sequences simultaneously ‚Üí scattered progress ‚Üí never publish
  - New: Build L1 ‚Üí LOCK ‚Üí Build L2 ‚Üí LOCK ‚Üí Build T ‚Üí PUBLISH ‚úÖ
  
  **NEW SYSTEMS IMPLEMENTED:**
  1. ‚úÖ Stage Tracking: AI knows which sequence it's building
     - Stages: building_L1 ‚Üí building_L2 ‚Üí building_T ‚Üí ready_to_publish
  
  2. ‚úÖ Sequence Locking: Completed sequences protected from discard
     - Once ladder complete ‚Üí marked read-only ‚Üí cannot be accidentally discarded
  
  3. ‚úÖ Target Card System: AI hunts 2-3 SPECIFIC cards
     - Not "any useful card" ‚Üí specific targets like "5‚ô•, 7‚ô†, 10‚ô¶"
  
  4. ‚úÖ Near-Sequential Analysis: Finds promising partial sequences
     - Detects: [4,6,8‚ô•] ‚Üí needs [5,7] ‚Üí high potential
     - Rejects: [2,7,K‚ô•] ‚Üí too many gaps ‚Üí low potential
  
  5. ‚úÖ Suit Concentration: Focus on 2 best suits for ladders
     - Select suits with highest card count and lowest gaps
  
  6. ‚úÖ Stage-Based Buying: Different logic per construction phase
     - Building L1: Only buy target cards for first ladder
     - Building L2: Only buy target cards for second ladder  
     - Building T: Only buy cards that complete triple
  
  7. ‚úÖ Protected Discard: Never discard locked sequence cards
     - Locked cards immune to all discard logic
  
  8. ‚úÖ Stage Advancement: Auto-progress when sequences complete
     - Detects completion ‚Üí locks sequence ‚Üí updates targets ‚Üí advances stage
  
  **PLAYER-PROVEN STRATEGY:**
  This matches exactly how humans win Hand 6/7:
  - Focus on ONE ladder at a time
  - Lock progress as you go
  - Don't try to build everything simultaneously
  - Triples are easy - save for last!
  
  **EXPECTED RESULTS:**
  - AI should publish within 20-30 turns (not 172+!)
  - AI should WIN Hand 6 and Hand 7 games
  - No more infinite buy loops
  - Clean, focused gameplay
  
  üéÆ VERSION 4.3.2 - CRITICAL FIX: Wrap-Around Ladder Extension!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: Can now extend A-K-Q-J wrap-around ladders with 10
  ‚úÖ canAddToPublishedSequence now uses canCardExtendLadder (handles wrap-around!)
  ‚ùå Removed: Broken simple rank array logic that didn't understand A-K-Q-J
  üìä Result: UI extension validation matches couldExtendSequence logic!
  
  Bug: UI said "Invalid Card" even though couldExtendSequence returned true
  Fix: UI now uses same wrap-around detection as backend logic
  
  üéÆ VERSION 4.3.1 - CRITICAL FIX: Complete 4+ Card Ladder Check!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: AI now ONLY buys cards that create/extend COMPLETE 4+ card ladders
  ‚ùå Prevented: Buying scattered fragments (e.g., 4-5-6‚ô• + 9-10‚ô• = 2 incomplete)
  ‚úÖ Required: Card must form sequential run of 4+ cards AFTER adding it
  üìä Result: AI accumulates cards that actually complete ladders!
  
  Previous v4.3.0: Checked "adjacent to any suit card" = scattered fragments ‚ùå
  New v4.3.1: Verifies complete 4+ sequential run after adding card ‚úÖ

  üéÆ VERSION 4.3.0 - CRITICAL FIX: Ladders First Strategy!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: Hand 6 AI now uses SMART STRATEGY: Build 2 ladders FIRST, then triple
  ‚úÖ Ladders are harder (4+ sequential same-suit) ‚Üí prioritize these
  ‚úÖ Triples are easier (3 matching ranks) ‚Üí form from leftover cards
  ‚úÖ AI ONLY buys ladder-building cards until 2 ladders complete
  ‚úÖ After 2 ladders: AI can buy triple-completing cards from leftovers
  üìä Prevents: Wasting buys on multiple triples while missing ladders
  üìä Result: AI forms 1T + 2L efficiently and publishes!
  
  Previous v4.2.9: AI bought triple cards first = wrong order! ‚ùå
  New v4.3.0: AI builds ladders first (player-proven strategy) ‚úÖ

  üéÆ VERSION 4.2.9 - CRITICAL FIX: Goal-Oriented Buying for Hands 6-7!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: Hand 6 buying now checks if card HELPS FORM LADDERS (not just "has progress")
  üêõ Fixed: Hand 7 buying now ONLY accepts cards that build toward 3 ladders
  ‚úÖ AI now buys cards that complete/extend sequences toward actual requirements
  ‚úÖ Hand 6: Buys cards that complete triples OR extend ladders (2+ same suit + adjacent)
  ‚úÖ Hand 7: ONLY buys cards that extend ladders (3+ ladders needed)
  üìä Result: AI accumulates 12-14 cards AND forms valid sequences to publish!
  
  Previous fix (v4.2.8): AI bought 20+ times but cards didn't help ‚ùå
  New behavior: AI buys strategically toward completion ‚úÖ

  üéÆ VERSION 4.2.8 - CRITICAL FIX: AI Can Actually Win Hand 6/7 Now!
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: AI threshold lowered from 11‚Üí5 (was rejecting pairs/ladder starts!)
  üêõ Fixed: Hand 6 buying - now allows 2 buys (was 1!), threshold 35‚Üí20
  üêõ Fixed: Hand 7 buying - threshold lowered 30‚Üí20 for 3-ladder requirement
  ‚úÖ AI can accumulate 11-12 cards needed for Hands 6-7
  ‚úÖ Rabbit personality: threshold 3 (very aggressive)
  ‚úÖ Tortoise personality: threshold 7 (reasonable)
  üìä Hand 6: AI can now buy 2x to reach 12 cards (11+ needed for 1T+2L)
  üìä Hand 7: AI can buy 2x to reach 12 cards (12 needed for 3L)

  üéÆ VERSION 4.1.6 - BUGFIX: Game freezing after buy window blocks
  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üêõ Fixed: closeBuyWindow now resumes pending AI turns for all block reasons
  ‚úÖ Added 'no-buy-after-publish', 'no-buys', 'ai-no-buyback', 'invalid' to resume list
  ‚úÖ Game no longer freezes when AI blocks buy window
  
  Version 4.1.5 - November 15, 2025
  üêõ Fixed: PATCH 3 now sets aiJustPublished flag after emergency publish
  ‚úÖ AI can no longer extend on same turn as publishing
  
  Version 4.0.5 - November 14, 2025
  
  Version 4.0.4 - November 14, 2025
  üêõ Fixed: Extension validation now works with 2D sequences
  ‚úÖ Players can now extend published sequences
  
  Version 4.0.3 - November 14, 2025
  üêõ Fixed: Human manual publish now stores as 2D sequences
  ‚úÖ Eliminated renderPublished crash
  
  Version 4.0.2 - November 14, 2025
  üêõ Fixed: Game advances when buy window skipped (no buys left)
  ‚úÖ Eliminated infinite wait bug
  
  Version 4.0.1 - November 14, 2025
  üêõ Fixed: couldExtendSequence now uses getFlatPublished()
  ‚úÖ Eliminated crash when checking card extensions
  
  Base: Version 4.0.0 - 2D Sequences Architecture
  üèóÔ∏è BREAKING CHANGE: Sequences stored as 2D arrays (not flat!)
  ‚úÖ Eliminates all sequence separation bugs
  ‚úÖ No more ambiguous card assignment
  ‚úÖ Direct access to individual sequences
  ‚úÖ Simpler, cleaner code
  
  Version 4.0.0 - November 14, 2025
  The "Stop Giving Away Wins" Fix
  The "Can Actually Extend" Fix

  Experience the game like you're sitting at a real card table!
  Compete against Habot (the Rabbit) and Jabot (the Tortoise) across 7 challenging hands!
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>Habib Punja v4.5.3 - Strategic AI Card Game | AgeOfBotsGames</title>
    <meta name="title" content="Habib Punja v4.5.3 - Strategic AI Card Game | AgeOfBotsGames">
    <meta name="description" content="Play Habib Punja, a strategic Liverpool Rummy variant against AI opponents Habot and Jabot. Master triples and ladders across 7 challenging hands!">
    <meta name="keywords" content="Habib Punja, card game, rummy, Liverpool Rummy, AI card game, strategy game, online card game, AgeOfBotsGames">
    <meta name="author" content="AgeOfBotsGames LLC">
    <meta name="version" content="4.4.1">
    <meta name="copyright" content="Copyright ¬© 2025 AgeOfBotsGames LLC. All rights reserved.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ageofbotsgames.com/">
    <meta property="og:title" content="Habib Punja - Strategic AI Card Game">
    <meta property="og:description" content="Challenge AI opponents in this strategic Liverpool Rummy variant. Can you outsmart Habot and Jabot?">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ageofbotsgames.com/">
    <meta property="twitter:title" content="Habib Punja - Strategic AI Card Game">
    <meta property="twitter:description" content="Challenge AI opponents in this strategic Liverpool Rummy variant. Can you outsmart Habot and Jabot?">

    <!-- Link to external css file -->
    <link rel="stylesheet" href="css/styles.css">

    <style>
        /* [Previous CSS remains exactly the same - keeping it brief for space] */
        :root {
            --bg-1: #0b1b13;
            --bg-2: #0f2a1c;
            --surface: #132e21;
            --gold: #ffd54a;
            --gold-2: #ffea8a;
            --accent: #4ade80;
            --accent-2: #22c55e;
            --danger: #ef4444;
            --muted: #cbd5e1;
            --ring: 0 0 0 2px rgba(255,213,74,.25),0 10px 30px rgba(0,0,0,.35);
            --radius: 14px;
            --card-w: 64px;
            --card-h: 92px;
            --elev: 0 10px 25px rgba(0,0,0,.35)
        }

        * {
            box-sizing: border-box
        }

        html, body {
            height: 100%
        }

        body {
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,'Noto Sans',sans-serif;
            background: radial-gradient(1200px 800px at 30% -10%,#154d34 0%,transparent 60%),radial-gradient(1400px 900px at 120% 10%,#0b3d28 0%,transparent 55%),linear-gradient(180deg,var(--bg-1),var(--bg-2));
            color: #fff;
            min-height: 100vh;
            padding: 24px
        }

        .game-container {
            max-width: 1280px;
            margin: 0 auto
        }

        .game-header {
            text-align: center;
            margin-bottom: 18px
        }

            .game-header h1 {
                font-size: clamp(1.6rem,3vw,2.4rem);
                color: var(--gold);
                letter-spacing: .5px;
                text-shadow: 0 1px 0 #000,0 0 24px rgba(255,213,74,.25)
            }

        .game-info {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg,rgba(255,215,0,.10),rgba(255,255,255,.04));
            padding: 16px 18px;
            border-radius: var(--radius);
            border: 1px solid rgba(255,215,0,.25);
            box-shadow: var(--elev)
        }

        .current-hand {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--gold)
        }

        .requirements {
            font-size: .95rem;
            color: var(--gold-2)
        }

            .requirements.ready {
                color: var(--accent)
            }

        .turn-indicator {
            padding: 8px 14px;
            background: linear-gradient(180deg,var(--accent),var(--accent-2));
            border-radius: 999px;
            font-weight: 800;
            color: #052e1a;
            text-shadow: 0 1px 0 rgba(255,255,255,.35);
            box-shadow: var(--ring)
        }

        .leaderboard {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border: 1px solid rgba(255,255,255,.15);
            border-radius: var(--radius);
            padding: 12px 14px;
            margin: 16px 0 20px;
            box-shadow: var(--elev)
        }

            .leaderboard h3 {
                color: var(--gold);
                margin-bottom: 6px;
                text-align: center;
                font-size: 1rem
            }

        .leaderboard-entries {
            display: flex;
            gap: 10px
        }

        .leaderboard-entry {
            flex: 1;
            text-align: center;
            padding: 8px 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.12)
        }

            .leaderboard-entry.first {
                background: linear-gradient(180deg,rgba(255,215,0,.20),rgba(255,215,0,.08));
                border-color: rgba(255,215,0,.65)
            }

            .leaderboard-entry.last {
                background: linear-gradient(180deg,rgba(239,68,68,.22),rgba(239,68,68,.08));
                border-color: rgba(239,68,68,.55)
            }

        .leaderboard-name {
            font-weight: 800;
            font-size: .9rem;
            margin-bottom: 2px
        }

        .leaderboard-score {
            font-size: 1.05rem;
            font-weight: 800;
            color: var(--gold)
        }

        .players-section {
            display: grid;
            grid-template-columns: 1fr minmax(420px,1.2fr) 1fr;
            gap: 16px;
            margin-bottom: 22px
        }

        @media(max-width:980px) {
            .players-section {
                grid-template-columns: 1fr
            }

            .center-area {
                order: 3
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* üé® v4.0.7: ROUND TABLE LAYOUT STYLES                           */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .round-table-top {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            margin-bottom: 24px;
            align-items: start;
        }

        .opponent-area {
            background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
            border-radius: var(--radius);
            padding: 16px;
            border: 1px solid rgba(255,255,255,.15);
            box-shadow: var(--elev);
            transition: box-shadow .2s, border-color .2s;
        }

            .opponent-area.active-turn {
                box-shadow: 0 0 0 2px var(--gold), 0 12px 30px rgba(0,0,0,.45);
            }

        .opponent-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--player-color);
        }

            .opponent-header .player-name {
                font-weight: 900;
                color: var(--player-color);
                font-size: 1.1rem;
                letter-spacing: .3px;
                margin: 0;
                padding: 0;
                border: none;
            }

            .opponent-header .buy-info {
                font-size: .85rem;
                color: var(--muted);
            }

        .card-count-badge {
            font-size: .85rem;
            font-weight: 700;
            color: var(--gold);
            background: rgba(255, 213, 74, .15);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            width: fit-content;
        }

        .opponent-published {
            margin-bottom: 12px;
            min-height: 40px;
        }

            .opponent-published .published-header {
                font-size: .8rem;
                font-weight: 700;
                color: var(--gold-2);
                margin-bottom: 6px;
                text-transform: uppercase;
                letter-spacing: .5px;
            }

            .opponent-published .published-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                min-height: 30px;
            }

        .opponent-cards-visible {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 12px 0;
            min-height: 110px;
        }

        .ai-status-compact {
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(0,0,0,.3);
            border: 1px solid var(--player-color);
            min-height: 40px;
            font-size: .85rem;
            text-align: center;
        }

            .ai-status-compact.active {
                background: linear-gradient(180deg, rgba(255,215,0,.18), rgba(255,215,0,.08));
                border-color: var(--gold);
                box-shadow: var(--ring);
            }

            .ai-status-compact .ai-status-action {
                color: var(--muted);
                font-weight: 600;
            }

        .center-table-area {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 0;
        }

        .deck-area-compact {
            display: flex;
            gap: 12px;
        }

        .player-area-center {
            background: linear-gradient(180deg, rgba(74, 174, 226, .08), rgba(74, 174, 226, .04));
            border-radius: var(--radius);
            padding: 20px;
            border: 2px solid rgba(74, 174, 226, .3);
            box-shadow: var(--elev);
            margin-bottom: 20px;
        }

            .player-area-center.active-turn {
                box-shadow: 0 0 0 3px var(--gold), 0 15px 35px rgba(0,0,0,.5);
                border-color: var(--gold);
            }

        .your-published {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(0,0,0,.25);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,.1);
            min-height: 60px;
        }

            .your-published .published-header {
                font-size: .9rem;
                font-weight: 700;
                color: var(--gold);
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: .5px;
            }

            .your-published .published-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
            }

        .player-name-center {
            font-weight: 900;
            font-size: 1.2rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--player-color);
            color: var(--gold);
            letter-spacing: .4px;
            text-align: center;
        }

        @media(max-width:980px) {
            .round-table-top {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .opponent-area {
                max-width: 100%;
            }
        }

        /* END v4.0.7 ROUND TABLE STYLES */

        .player-area {
            background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));
            border-radius: var(--radius);
            padding: 16px;
            min-height: 180px;
            border: 1px solid rgba(255,255,255,.15);
            box-shadow: var(--elev);
            transition: box-shadow .2s,border-color .2s
        }

            .player-area.active-turn {
                box-shadow: 0 0 0 2px var(--gold),0 12px 30px rgba(0,0,0,.45)
            }

        .player-name {
            font-weight: 900;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--player-color);
            color: var(--player-color);
            letter-spacing: .3px
        }

        .ai-status {
            margin-top: 12px;
            padding: 12px;
            border-radius: 10px;
            background: rgba(0,0,0,.35);
            border: 1px solid var(--player-color);
            min-height: 56px;
            font-size: .9rem;
            line-height: 1.5
        }

            .ai-status.active {
                background: linear-gradient(180deg,rgba(255,215,0,.18),rgba(255,215,0,.08));
                border-color: var(--gold);
                box-shadow: var(--ring)
            }

        .ai-status-title {
            font-weight: 800;
            color: var(--player-color);
            margin-bottom: 4px
        }


        /* ============================================
        üé® FIX 7B: Custom Confirmation Modal
        ============================================ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

            .modal-overlay.active {
                display: flex;
            }

        .modal-content {
            background: linear-gradient(135deg, var(--surface) 0%, var(--bg-2) 100%);
            border: 2px solid var(--gold);
            border-radius: var(--radius);
            padding: 32px;
            max-width: 450px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), var(--ring);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* ============================================
                üé® FIX 7D: Auto-Fade Modal Animations
                ============================================ */
        @keyframes modalFadeOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .modal-overlay.fading-out {
            animation: modalFadeOut 0.5s ease forwards;
        }

        .modal-auto-fade-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--gold));
            width: 100%;
            border-radius: 0 0 var(--radius) var(--radius);
            transform-origin: left;
            animation: fadeProgress 3s linear forwards;
        }

        @keyframes fadeProgress {
            from {
                transform: scaleX(1);
            }

            to {
                transform: scaleX(0);
            }
        }

        .modal-skip-hint {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 600;
            pointer-events: none;
        }

        .modal-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 800;
            color: var(--gold);
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .modal-message {
            font-size: 16px;
            color: var(--muted);
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 700;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

            .modal-btn.cancel {
                background: linear-gradient(180deg, var(--accent), var(--accent-2));
                border-color: var(--accent);
                color: #052e1a;
            }

                .modal-btn.cancel:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
                }

            .modal-btn.confirm {
                background: linear-gradient(180deg, var(--danger), #dc2626);
                border-color: var(--danger);
                color: white;
            }

                .modal-btn.confirm:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
                }

        .center-area {
            display: flex;
            flex-direction: column;
            align-items: center
        }

        .deck-area {
            display: flex;
            gap: 18px;
            margin-bottom: 16px
        }

        .deck, .discard-pile {
            width: 92px;
            height: 132px;
            border: 1px solid rgba(255,255,255,.35);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform .18s,box-shadow .18s;
            box-shadow: var(--elev);
            position: relative;
            overflow: hidden
        }

            .deck::after, .discard-pile::after {
                content: '';
                position: absolute;
                inset: 0;
                opacity: .2;
                background: radial-gradient(500px 180px at 20% -10%,#fff,transparent 60%);
                pointer-events: none
            }

        .deck {
            background: linear-gradient(160deg,#2b5fff,#17318f)
        }

        .discard-pile {
            background: linear-gradient(160deg,#ff7b2b,#8f3c17)
        }

            .deck:hover, .discard-pile:hover {
                transform: translateY(-4px) scale(1.03)
            }

        .published-sequences {
            width: 100%;
            min-height: 150px;
            border: 1px dashed rgba(255,215,0,.55);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            background: linear-gradient(180deg,rgba(255,215,0,.12),rgba(255,215,0,.04))
        }

            .published-sequences > div:first-child {
                font-size: 1.05rem;
                font-weight: 900;
                color: var(--gold);
                margin-bottom: 10px;
                letter-spacing: .4px
            }

        .player-published {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,.05);
            border-radius: 10px
        }

            .player-published h5 {
                margin-bottom: 8px;
                color: var(--gold);
                font-size: .95rem;
                font-weight: 900
            }

        .published-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            max-width: 100%
        }

            .published-cards .card {
                flex: 0 0 auto;
                transform: scale(0.7)
            }

        .hand-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px
        }

        .players-section .player-area .hand-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            justify-items: center
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 900;
            cursor: move;
            user-select: none;
            position: relative;
            padding: 4px;
            background: linear-gradient(180deg,#fbfbfb,#f0f0f0);
            box-shadow: 0 6px 16px rgba(0,0,0,.25);
            transition: transform .16s ease,box-shadow .16s ease,border-color .16s ease
        }

            .card::before {
                content: '';
                position: absolute;
                inset: 0;
                border-radius: 10px;
                pointer-events: none;
                background: radial-gradient(800px 200px at 20% -10%,rgba(255,255,255,.8),transparent 60%);
                opacity: .35
            }

            .card:hover {
                transform: translateY(-8px) rotate(-.4deg);
                box-shadow: 0 12px 28px rgba(0,0,0,.35)
            }

            .card.dragging {
                opacity: .7;
                transform: rotate(3deg) scale(1.05)
            }

            .card.drag-over {
                border-left: 4px solid var(--accent)
            }

            .card.red {
                color: #db1f2f
            }

            .card.black {
                color: #0f172a
            }

            .card.red.heart {
                color: #e31c23
            }

            .card.red.diamond {
                color: #ff6b35
            }

            .card.selected {
                outline: 3px solid var(--gold);
                outline-offset: 0;
                transform: translateY(-12px) scale(1.02);
                box-shadow: 0 14px 34px rgba(255,213,74,.45)
            }

        .card-rank {
            font-size: 17px;
            line-height: 1;
            margin-bottom: 2px
        }

        .card-suit {
            font-size: 30px;
            line-height: 1
        }

        .btn {
            background: linear-gradient(180deg,#3ddc84,#1fae63);
            color: #052e1a;
            border: none;
            padding: 12px 18px;
            border-radius: 12px;
            cursor: pointer;
            margin: 0 6px 10px;
            font-size: 15px;
            font-weight: 900;
            letter-spacing: .2px;
            transition: transform .12s,box-shadow .12s;
            box-shadow: 0 6px 16px rgba(0,0,0,.25)
        }

            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 22px rgba(0,0,0,.35)
            }

            .btn:disabled {
                background: #6b7280;
                color: #1f2937;
                cursor: not-allowed;
                opacity: .7;
                box-shadow: none
            }

        .buy-info {
            background: rgba(255,193,7,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem
        }

        .selection-info {
            background: rgba(255,215,0,.25);
            padding: 6px 10px;
            border-radius: 10px;
            margin-left: 8px;
            font-size: .9rem;
            font-weight: 900
        }

        .publish-selector {
            display: none;
            background: linear-gradient(135deg,rgba(255,215,0,.22),rgba(255,215,0,.08));
            border: 2px solid var(--gold);
            border-radius: 14px;
            padding: 18px;
            margin: 12px 0
        }

            .publish-selector.active {
                display: block
            }

            .publish-selector h3 {
                color: var(--gold);
                margin-bottom: 12px;
                text-align: center;
                font-size: 1.05rem
            }

        .publish-options {
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .publish-option {
            background: rgba(255,255,255,.05);
            border: 1px solid rgba(255,255,255,.20);
            border-radius: 12px;
            padding: 12px
        }

            .publish-option h4 {
                color: var(--gold-2);
                margin-bottom: 8px;
                font-size: .95rem
            }

        .option-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
            justify-content: center
        }

        .publish-controls {
            text-align: center;
            margin-top: 10px
        }

        .add-to-published {
            margin-top: 8px;
            padding: 8px 12px;
            font-size: .85rem;
            background: #0ea5e9;
            color: #062232
        }

            .add-to-published:hover {
                background: #0284c7;
                color: #001824
            }

        .game-controls {
            text-align: center;
            margin-top: 14px
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0
            }

            to {
                transform: translateX(0);
                opacity: 1
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1
            }

            to {
                transform: translateX(400px);
                opacity: 0
            }
        }

        @keyframes victoryPulse {
            0%, 100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.05)
            }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none
        }

        .fix-badge {
            position: fixed;
            top: 80px;
            right: 16px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: #fff;
            font-weight: 900;
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            z-index: 9998;
            font-size: 0.9rem;
            border: 2px solid rgba(255,255,255,0.3)
        }
    </style>
</head>
<body>
    <div class="fix-badge">‚úÖ v4.5.3</div>
    <div class="game-container">
        <div class="game-header"><h1>Habib Punja v4.5.3</h1></div>
        <div class="game-info">
            <div class="current-hand">Hand <span id="currentHand">1</span>: <span id="handRequirements">Two Triples</span></div>
            <div class="requirements" id="detailedRequirements">Two Triples</div>
            <div class="turn-indicator" id="turnIndicator">Your Turn</div>
        </div>
        <div class="leaderboard"><div class="leaderboard-entries" id="leaderboardEntries"></div></div>
        
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- üé® v4.0.7: ROUND TABLE LAYOUT - Top Row (AI Opponents)     -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <div class="round-table-top">
            <!-- Left: Habot (The Rabbit) -->
            <div class="opponent-area opponent-left" style="--player-color: #e74c3c;">
                <div class="opponent-header">
                    <div class="player-name">üêá Habot</div>
                    <div class="buy-info">Buys: <span id="player2Buys">3</span></div>
                    <div class="card-count-badge">Cards: <span id="player2Count">10</span></div>
                </div>
                
                <!-- Habot's Published Sequences (above their cards) -->
                <div class="opponent-published" id="player2Published">
                    <div class="published-header">Published:</div>
                    <div class="published-cards" id="player2CardsPublished"></div>
                </div>
                
                <!-- Habot's Visible Cards (last 3) -->
                <div class="opponent-cards-visible" id="player2Cards"></div>
                
                <!-- Habot's Status -->
                <div class="ai-status-compact" id="habot-status">
                    <div class="ai-status-action" id="habot-action">Waiting...</div>
                </div>
            </div>
            
            <!-- Center Top: Deck & Discard -->
            <div class="center-table-area">
                <div class="deck-area-compact">
                    <div class="deck" id="drawDeck"><div>Draw<br>Deck</div></div>
                    <div class="discard-pile" id="discardPile"><div id="topDiscard">Discard<br>Pile</div></div>
                </div>
            </div>
            
            <!-- Right: Jabot (The Tortoise) -->
            <div class="opponent-area opponent-right" style="--player-color: #9b59b6;">
                <div class="opponent-header">
                    <div class="player-name">üê¢ Jabot</div>
                    <div class="buy-info">Buys: <span id="player3Buys">3</span></div>
                    <div class="card-count-badge">Cards: <span id="player3Count">10</span></div>
                </div>
                
                <!-- Jabot's Published Sequences (above their cards) -->
                <div class="opponent-published" id="player3Published">
                    <div class="published-header">Published:</div>
                    <div class="published-cards" id="player3CardsPublished"></div>
                </div>
                
                <!-- Jabot's Visible Cards (last 3) -->
                <div class="opponent-cards-visible" id="player3Cards"></div>
                
                <!-- Jabot's Status -->
                <div class="ai-status-compact" id="jabot-status">
                    <div class="ai-status-action" id="jabot-action">Waiting...</div>
                </div>
            </div>
        </div>
        
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- üé® v4.0.7: ROUND TABLE LAYOUT - Bottom (Your Area)         -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <div class="player-area-center" style="--player-color: #4a90e2;">
            <!-- Your Published Sequences (above your hand) -->
            <div class="your-published" id="player1Published">
                <div class="published-header">Your Published Sequences:</div>
                <div class="published-cards" id="player1Cards"></div>
            </div>
            
            <!-- Your Hand -->
            <div class="player-name-center">
                Your Hand 
                <span class="buy-info">Buys: <span id="playerBuys">3</span></span>
                <span id="selectionInfo" class="selection-info" style="display:none;">Selected: <span id="selectedCount">0</span></span>
            </div>
            <div class="hand-cards" id="playerCards"></div>
            
            <!-- Publish Selector -->
            <div class="publish-selector" id="publishSelector">
                <h3>Choose Cards to Publish</h3>
                <div class="publish-options" id="publishOptions"></div>
                <div class="publish-controls">
                    <button class="btn" id="confirmManualPublish">Publish Selected</button>
                    <button class="btn" id="cancelManualPublish">Cancel</button>
                </div>
            </div>
            
            <!-- Add to Published Section -->
            <div id="addToPublishedSection" style="display:none; margin-top:15px;">
                <strong style="color:#ffd700;">Add Selected Card To:</strong>
                <button class="btn add-to-published" data-player="0">Your Sequences</button>
                <button class="btn add-to-published" data-player="1">Habot's Sequences</button>
                <button class="btn add-to-published" data-player="2">Jabot's Sequences</button>
            </div>
        </div>
        
        <!-- Game Controls (unchanged) -->
        <div class="game-controls">
            <button class="btn" id="publishBtn" disabled>Publish Sequences</button>
            <button class="btn" id="sortByRankBtn">Sort by Rank</button>
            <button class="btn" id="sortBySuitBtn">Sort by Suit</button>
            <button class="btn" id="discardBtn" disabled>Discard Selected</button>
            <button class="btn" id="buyBtn" disabled>Buy from Discard <span id="buyTimer" style="display:none;"></span></button>
            <button class="btn" id="sortByQuantityBtn">Sort by Quantity</button>
            <button class="btn" id="newGameBtn">New Game</button>
        </div>
    </div>

    <!-- ============================================
     üé® FIX 7B: Custom Confirmation Modal
     ============================================ -->
    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-icon">‚ö†Ô∏è</div>
            <div class="modal-title" id="modalTitle">Confirm Action</div>
            <div class="modal-message" id="modalMessage">Are you sure?</div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" id="modalCancel">Continue Playing</button>
                <button class="modal-btn confirm" id="modalConfirm">Start New Game</button>
            </div>
        </div>
    </div>



    <script>
        // ============================================================================
        // üéÆ HABIB PUNJA v3.0 - THE CLEAN ARCHITECTURE EDITION
        // ============================================================================
        // Add this at the very top of your <script> section, before game code
        window.addEventListener('error', function (e) {
            // Ignore browser extension errors
            if (e.message && e.message.includes('runtime.lastError')) {
                e.preventDefault();
                console.log('‚ö†Ô∏è Browser extension error caught and ignored');
                return false;
            }
        });

        // ============================================================================
        // DEBUG MODE SYSTEM
        // ============================================================================
        // Enable debug mode by adding ?debug=true to the URL
        const urlParams = new URLSearchParams(window.location.search);
        const DEBUG_MODE = urlParams.get('debug') === 'true';
        
        // Enhanced console logging that respects debug mode
        const debugLog = {
            info: (...args) => { if (DEBUG_MODE) console.log(...args); },
            warn: (...args) => { if (DEBUG_MODE) console.warn(...args); },
            error: (...args) => console.error(...args), // Always show errors
            ai: (playerName, ...args) => { 
                if (DEBUG_MODE) console.log(`%cü§ñ ${playerName}:`, 'color: #9c27b0; font-weight: bold;', ...args); 
            },
            decision: (title, ...args) => {
                if (DEBUG_MODE) console.log(`%c‚ö° ${title}`, 'color: #ff9800; font-weight: bold;', ...args);
            }
        };

        if (DEBUG_MODE) {
            console.log('%cüêõ DEBUG MODE ENABLED', 'color: #f44336; font-size: 16px; font-weight: bold; background: #fff; padding: 4px 8px;');
            console.log('%cVerbose AI logging active. Remove ?debug=true from URL to disable.', 'color: #666; font-size: 12px;');
            console.log(' ');
        }

        // ============================================================================
        // GAME METADATA & BRANDING
        // ============================================================================
        console.log('%cüéÆ HABIB PUNJA v4.5.3 - STAGED CONSTRUCTION', 'color: #9b59b6; font-size: 20px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.3)');
        console.log('%cüåç PATCH M Checks Global Published Sequences!', 'color: #ff9800; font-size: 14px; font-weight: bold;');
        console.log('%c¬© 2025 AgeOfBotsGames LLC', 'color: #666; font-size: 12px;');
        console.log('%cWebsite: https://ageofbotsgames.com', 'color: #2196F3; font-size: 12px;');
        console.log('%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'color: #999;');
        console.log('%c‚ö†Ô∏è Game code is protected by copyright.', 'color: #FF9800; font-weight: bold;');
        console.log('%c‚ö†Ô∏è Unauthorized copying or distribution is prohibited.', 'color: #FF9800; font-weight: bold;');
        console.log('%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'color: #999;');
        console.log(' ');

        // Update version badge if debug mode is active
        if (DEBUG_MODE) {
            setTimeout(() => {
                const badge = document.querySelector('.fix-badge');
                if (badge) {
                    badge.innerHTML = 'üêõ v4.5.3 DEBUG';
                    badge.style.background = 'linear-gradient(135deg, #f44336, #e91e63)';
                }
            }, 100);
        }

        // Game state
        let deck = [];
        let players = [];

        class Card {
            constructor(rank, suit) { this.rank = rank; this.suit = suit; this.id = Math.random().toString(36).substr(2, 9) }
            toString() { return `${this.rank}${this.suit}` }
            getValue() { if (this.rank === 'A') return 1; if (this.rank === 'J') return 11; if (this.rank === 'Q') return 12; if (this.rank === 'K') return 13; return parseInt(this.rank) }
            getColor() { return (this.suit === '‚ô•' || this.suit === '‚ô¶') ? 'red' : 'black' }
            getPenaltyValue() { if (this.rank === 'A') return 20; if (['K', 'Q', 'J'].includes(this.rank)) return 15; return this.getValue() }
        }

        let game = null;
        let persistentScores = [0, 0, 0];

        class GameState {
            constructor(carryOverScores = false) {
                this.currentHand = 1; this.players = 3;

                this.startingPlayer = null;  // Will be set by draw
                this.currentPlayer = 0;      // Temporary, will be updated after draw

                // üéØ v2.5.0: Track last card alerts to show only once per player
                this.lastCardAlertShown = [false, false, false];  // ‚Üê ADD THIS LINE

                this.deck = []; this.discardPile = [];
                this.playerHands = [[], [], []]; this.playerBuys = [3, 3, 3];
                this.publishedSequences = [[], [], []]; this.gamePhase = 'draw';
                this.selectedCards = [];
                this.playerScores = carryOverScores ? [...persistentScores] : [0, 0, 0];
                this.lastDiscard = null; this.justPublished = false;
                this.lastDiscardByPlayer = -1; this.aiJustPublished = [false, false, false];
                this.turnCounter = 0;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                this.lastAIDiscard = [null, null, null];
                this.aiPersonality = { 1: 'rabbit', 2: 'tortoise' };
                this.lastCardWarningShown = null;
                this.discardPileAccessible = false; // üîí v4.1.3: Glass vault - only accessible after NEW discard
                
                // üèóÔ∏è v4.5.3: STAGED CONSTRUCTION SYSTEM for Games 6-7
                // AI builds sequences SEQUENTIALLY (L1 ‚Üí L2 ‚Üí T) instead of parallel accumulation
                this.aiConstructionStage = [null, 'initial', 'initial']; // [human, habot, jabot]
                // Stages: 'initial' ‚Üí 'building_L1' ‚Üí 'building_L2' ‚Üí 'building_T' ‚Üí 'ready_to_publish'
                
                this.aiLockedSequences = [[], [], []]; // Completed sequences protected from discard
                // Format: [{ type: 'ladder', cards: [...], suit: '‚ô•' }, ...]
                
                // üî∂ v4.5.3: HOLD SYSTEM - Parallel construction breakthrough!
                this.aiHeldSequences = [[], [], []]; // 3-card "almost ladders" on hold while building others
                // Format: [{ cards: [Card, Card, Card], suit: '‚ô†', targets: [5, 9], type: 'ladder', createdTurn: 15, priority: 10 }, ...]
                
                this.aiTargetCards = [null, [], []]; // Specific cards AI is hunting for
                // Format: ['5‚ô•', '7‚ô†', '10‚ô¶'] - max 3 targets per AI
                
                this.aiSuitFocus = [null, [], []]; // Concentrated suits AI is working on
                // Format: ['‚ô•', '‚ô†'] - 2-3 suits AI focuses on for ladder building
                
                // üíö v4.5.3: AGGRESSIVE BUY MODE - Track when stages started for scattered card detection
                this.aiStageStartTurn = [null, 0, 0]; // Turn number when current stage started
                // Used to detect when AI is stuck on same stage too long ‚Üí activate aggressive mode
                
                // üéØ v3.0: Cache for sequence separation to reduce logging spam
                this.sequenceSeparationCache = {
                    turnCounter: -1,
                    cache: {}
                };
                this.handReqs = {
                    1: { name: "Two Triples", seqs: ["triple", "triple"], cards: 10 },
                    2: { name: "Triple + Ladder", seqs: ["triple", "ladder"], cards: 10 },
                    3: { name: "Two Ladders", seqs: ["ladder", "ladder"], cards: 10 },
                    4: { name: "Three Triples", seqs: ["triple", "triple", "triple"], cards: 10 },
                    5: { name: "2 Triples + Ladder", seqs: ["triple", "triple", "ladder"], cards: 10 },
                    6: { name: "Triple + 2 Ladders", seqs: ["triple", "ladder", "ladder"], cards: 10 },
                    7: { name: "Three Ladders", seqs: ["ladder", "ladder", "ladder"], cards: 10 }
                };
                this.initDeck(); this.deal(); this.updateUI();
                console.log('%c====== GAME STARTED ======', 'color:#28a745;font-size:14px;font-weight:bold');
            }

            getAIPersonality(aiIdx) {
                if (this.currentHand <= 3) return this.aiPersonality[aiIdx] || 'neutral';
                const aiScore = this.playerScores[aiIdx];
                const otherScores = this.playerScores.filter((_, idx) => idx !== aiIdx);
                const minOtherScore = Math.min(...otherScores);
                const maxOtherScore = Math.max(...otherScores);
                if (aiScore >= maxOtherScore && aiScore > minOtherScore + 20) return 'rabbit';
                if (aiScore <= minOtherScore) return 'tortoise';
                return this.aiPersonality[aiIdx] || 'neutral';
            }

            // ============================================
            // üé¥ v2.5.0: DRAW FOR FIRST TURN (Bridge Style)
            // ============================================
            async drawForFirstTurn() {
                console.log(`%cüé¥ DRAW FOR FIRST TURN`, 'color: #9c27b0; font-weight: bold; font-size: 16px;');
                console.log(`%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'color: #9c27b0;');

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 1: Opening Banter
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const banter = getOpeningBanter();

                // Habot speaks first (aggressive/eager)
                await showInfoModal(
                    'üí¨ Habot',
                    banter[0].text,
                    'Continue',
                    'üêá',
                    true,   // Auto-fade
                    2000    // 2 seconds
                );

                // Jabot responds (calm/measured)
                await showInfoModal(
                    'üí¨ Jabot',
                    banter[1].text,
                    'Continue',
                    'üê¢',
                    true,   // Auto-fade
                    2000    // 2 seconds
                );

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 2: The Draw
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.initDeck();

                const drawnCards = [
                    this.deck.pop(),  // Human (Player 0)
                    this.deck.pop(),  // Habot (Player 1)
                    this.deck.pop()   // Jabot (Player 2)
                ];

                console.log(`%c  Cards drawn:`, 'color: #9c27b0; font-weight: bold;');
                console.log(`    Human: ${drawnCards[0].toString()}`);
                console.log(`    Habot: ${drawnCards[1].toString()}`);
                console.log(`    Jabot: ${drawnCards[2].toString()}`);

                // Show draws with dramatic timing
                await showInfoModal(
                    'üé¥ Habot Draws',
                    `Habot draws...\n\n${drawnCards[1].toString()}`,
                    'Continue',
                    'üêá',
                    true,
                    1800
                );

                await showInfoModal(
                    'üé¥ Jabot Draws',
                    `Jabot draws...\n\n${drawnCards[2].toString()}`,
                    'Continue',
                    'üê¢',
                    true,
                    1800
                );

                await showInfoModal(
                    'üé¥ Your Draw',
                    `You draw...\n\n${drawnCards[0].toString()}`,
                    'Got it!',
                    'üÉè',
                    false  // Must acknowledge
                );

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 3: Determine Winner
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const suitOrder = { '‚ô†': 4, '‚ô•': 3, '‚ô¶': 2, '‚ô£': 1 };

                const cardValues = drawnCards.map((card, idx) => ({
                    player: idx,
                    card: card,
                    value: card.getValue(),
                    suitValue: suitOrder[card.suit]
                }));

                // Sort by rank first, then by suit
                cardValues.sort((a, b) => {
                    if (b.value !== a.value) return b.value - a.value;
                    return b.suitValue - a.suitValue;
                });

                const winner = cardValues[0].player;
                const highestValue = cardValues[0].value;
                const tiedPlayers = cardValues.filter(cv => cv.value === highestValue);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 4: Handle Ties (Show Hierarchy)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if (tiedPlayers.length > 1) {
                    console.log(`%c  üîÑ TIE DETECTED! Multiple ${cardValues[0].card.rank}s drawn`, 'color: #ff9800; font-weight: bold;');

                    const tiedNames = tiedPlayers.map(cv => ['You', 'Habot', 'Jabot'][cv.player]).join(', ');
                    const tiedCards = tiedPlayers.map(cv => `${['You', 'Habot', 'Jabot'][cv.player]}: ${cv.card.toString()}`).join('\n');

                    // Show tie with suit hierarchy explanation
                    const suitInfo = getSuitExplanation();
                    await showInfoModal(
                        'üîÑ Tie Detected!',
                        `${tiedNames} all drew ${cardValues[0].card.rank}!\n\n${tiedCards}\n\n${suitInfo.message}`,
                        'Continue',
                        'üé¥',
                        true,   // Auto-fade
                        4000    // 4 seconds - enough time to read
                    );

                    console.log(`%c  ‚úÖ Suit hierarchy: ${drawnCards[winner].suit} wins`, 'color: #4caf50; font-weight: bold;');
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 5: Announce Winner with Reactions
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const playerNames = ['You', 'Habot', 'Jabot'];
                const winnerName = playerNames[winner];
                const winnerCard = drawnCards[winner];

                const reactions = getWinReaction(winner, winnerCard, drawnCards);

                console.log(`%c  üèÜ WINNER: ${winnerName} (${winnerCard.toString()})`, 'color: #ffd700; font-weight: bold; font-size: 14px;');

                // Show winner announcement
                let winnerMessage = `${winnerName} drew the highest card!\n\n${winnerCard.toString()}\n\n`;

                // Add summary of all draws
                winnerMessage += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                winnerMessage += `Habot: ${drawnCards[1].toString()}\n`;
                winnerMessage += `Jabot: ${drawnCards[2].toString()}\n`;
                winnerMessage += `You: ${drawnCards[0].toString()}\n`;
                winnerMessage += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                winnerMessage += `${winnerName} will start first!`;

                await showInfoModal(
                    'üèÜ Starting Player',
                    winnerMessage,
                    'Continue',
                    'üëë',
                    false  // Must acknowledge
                );

                // Show winner's reaction
                await showInfoModal(
                    winner === 0 ? 'üí¨ The Table' : `üí¨ ${winnerName}`,
                    reactions.winner,
                    'Continue',
                    winner === 1 ? 'üêá' : (winner === 2 ? 'üê¢' : 'üé¥'),
                    true,
                    2500
                );

                // Show loser reactions (if any)
                for (let loser of reactions.losers) {
                    await showInfoModal(
                        `üí¨ ${loser.speaker}`,
                        loser.text,
                        'Continue',
                        loser.speaker === 'Habot' ? 'üêá' : 'üê¢',
                        true,
                        2000
                    );
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 6: Reshuffle & Ready to Play
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                drawnCards.forEach(card => this.deck.push(card));
                this.initDeck();  // Fresh shuffle

                console.log(`%c  ‚ôªÔ∏è  Cards returned to deck, reshuffled`, 'color: #9c27b0;');
                console.log(`%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'color: #9c27b0;');

                return winner;
            }

            initDeck() {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                this.deck = [];
                for (let d = 0; d < 2; d++) {
                    for (let suit of suits) {
                        for (let rank of ranks) {
                            this.deck.push(new Card(rank, suit));
                        }
                    }
                }
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            isTripleHeavyHand() {
                const req = this.handReqs[this.currentHand].seqs;
                const tripleCount = req.filter(s => s === 'triple').length;
                const ladderCount = req.filter(s => s === 'ladder').length;
                return tripleCount > 0 && (ladderCount === 0 || tripleCount >= ladderCount);
            }

            deal() {
                // üéØ v2.5.0: Reset last card alerts for new hand
                this.lastCardAlertShown = [false, false, false];

                const cards = this.handReqs[this.currentHand].cards;
                for (let i = 0; i < cards; i++) {
                    for (let p = 0; p < this.players; p++) {
                        if (this.deck.length > 0) this.playerHands[p].push(this.deck.pop());
                    }
                }

                // üé¥ v2.5.0: Flip initial discard card with commentary
                if (this.deck.length > 0) {
                    const initialDiscard = this.deck.pop();
                    this.discardPile.push(initialDiscard);
                    this.discardPileAccessible = true; // üîí v4.1.3: Unlock vault - new card on glass

                    console.log(`%cüé¥ Initial discard card: ${initialDiscard.toString()}`, 'color: #ff9800; font-weight: bold;');

                    // Add character commentary based on card value
                    let commentary = '';
                    const rank = initialDiscard.rank;

                    if (['A', 'K', 'Q'].includes(rank)) {
                        commentary = 'Habot: "Interesting start... that\'s a valuable card."\nJabot: "Indeed. The first player has a decision to make."';
                    } else if (['J', '10', '9'].includes(rank)) {
                        commentary = 'Jabot: "A reasonable starting card."\nHabot: "Could fit into several sequences."';
                    } else {
                        commentary = 'Habot: "Low card on the pile - probably not worth the buy."\nJabot: "We shall see. Every card has its place."';
                    }

                    showInfoModal(
                        'üé¥ Starting Card',
                        `The discard pile begins with:\n\n${initialDiscard.toString()}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n${commentary}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nFirst player may take it or draw from deck.`,
                        'Start Playing!',
                        'üÉè',
                        true,
                        4000  // 4 seconds
                    );
                }

                // üéØ v2.5.0: Smart initial sort based on game type
                const currentReq = this.handReqs[this.currentHand].seqs;
                const hasLadders = currentReq.some(seq => seq === 'ladder');
                const hasOnlyTriples = currentReq.every(seq => seq === 'triple');

                console.log(`%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'color: #2196f3;');
                console.log(`%cüÉè SORTING Hand ${this.currentHand}`, 'color: #2196f3; font-weight: bold; font-size: 14px;');
                console.log(`   Requirements: ${JSON.stringify(currentReq)}`);
                console.log(`   Has ladders: ${hasLadders}`);
                console.log(`   Only triples: ${hasOnlyTriples}`);
                console.log(`   Cards before sort: ${this.playerHands[0].map(c => c.toString()).join(', ')}`);

                // Sort player hand directly (don't call global functions during initialization)
                if (hasOnlyTriples) {
                    console.log(`%c   ‚Üí Applying QUANTITY sort`, 'color: #4caf50; font-weight: bold;');

                    // Count frequency of each rank
                    const counts = {};
                    this.playerHands[0].forEach(card => {
                        counts[card.rank] = (counts[card.rank] || 0) + 1;
                    });

                    console.log(`   ‚Üí Rank counts:`, counts);

                    // Sort by quantity (descending), then by rank value
                    this.playerHands[0].sort((a, b) => {
                        const countDiff = counts[b.rank] - counts[a.rank];
                        if (countDiff !== 0) return countDiff;
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });

                } else if (hasLadders) {
                    console.log(`%c   ‚Üí Applying SUIT sort`, 'color: #4caf50; font-weight: bold;');

                    // Sort by suit, then by rank
                    const order = { '‚ô†': 1, '‚ô•': 2, '‚ô¶': 3, '‚ô£': 4 };
                    this.playerHands[0].sort((a, b) => {
                        if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                        return a.getValue() - b.getValue();
                    });

                } else {
                    console.log(`%c   ‚Üí Applying RANK sort`, 'color: #4caf50; font-weight: bold;');

                    // Sort by rank value, then by suit
                    this.playerHands[0].sort((a, b) => {
                        if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                        return a.suit.localeCompare(b.suit);
                    });
                }

                console.log(`   Cards after sort: ${this.playerHands[0].map(c => c.toString()).join(', ')}`);
                console.log(`%c‚úÖ Sort complete!`, 'color: #00ff00; font-weight: bold;');
                console.log(`%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'color: #2196f3;');

                this.selectedCards = [];
            }


            reshuffleDeck() {
                if (this.discardPile.length <= 1) { console.log('%cNo cards to reshuffle', 'color: #ffc107;'); return false }
                const topCard = this.discardPile.pop();
                this.deck = [...this.discardPile];
                this.discardPile = [topCard];
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
                console.log(`%cReshuffled ${this.deck.length} cards`, 'color: #ffc107; font-weight: bold;');
                return true;
            }

            isValidTriple(cards) { if (cards.length !== 3) return false; return cards.every(c => c.rank === cards[0].rank) }

            isValidLadder(cards) {
                if (cards.length !== 4) return false;
                if (!cards.every(c => c.suit === cards[0].suit)) return false;
                const values = cards.map(c => c.getValue());
                if (values.includes(1) && values.includes(13) && values.includes(12) && values.includes(11)) return true;
                const sorted = [...values].sort((a, b) => a - b);
                for (let i = 1; i < sorted.length; i++) { if (sorted[i] !== sorted[i - 1] + 1) return false }
                return true;
            }

            isLadderHand() { return [2, 3, 5, 6, 7].includes(this.currentHand) }

            hasThreeCardLadderProgress(hand) {
                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                return Object.values(bySuit).some(cards => {
                    if (cards.length < 3) return false;
                    const uniqueByRank = [];
                    const seenRanks = new Set();
                    cards.sort((a, b) => a.getValue() - b.getValue());
                    cards.forEach(card => { if (!seenRanks.has(card.rank)) { uniqueByRank.push(card); seenRanks.add(card.rank) } });
                    for (let i = 0; i < uniqueByRank.length - 2; i++) {
                        if (uniqueByRank[i + 1].getValue() === uniqueByRank[i].getValue() + 1 &&
                            uniqueByRank[i + 2].getValue() === uniqueByRank[i + 1].getValue() + 1) return true;
                    }
                    return false;
                });
            }

            // üéØ v4.0.7 Helper: Flatten published sequences to flat array
            getFlatPublished(playerIdx) {
                return this.publishedSequences[playerIdx].flat();
            }

            // üéØ v4.0.7 Helper: Count total published cards
            getPublishedCount(playerIdx) {
                return this.publishedSequences[playerIdx].reduce((sum, seq) => sum + seq.length, 0);
            }

            getPublishedRanks(playerIdx) { 
                const ranks = new Set(); 
                this.publishedSequences[playerIdx].forEach(seq => {
                    seq.forEach(c => ranks.add(c.rank));
                });
                return ranks;
            }
            getPublishedSuits(playerIdx) { 
                const suits = new Set(); 
                this.publishedSequences[playerIdx].forEach(seq => {
                    seq.forEach(c => suits.add(c.suit));
                });
                return suits;
            }

            getPublishProgress() {
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const seqs = this.findSequences(this.playerHands[0]);
                const hasTriples = seqs.triples.length;
                const hasLadders = seqs.ladders.length;
                return { needTriples, hasTriples, needLadders, hasLadders, canPublish: hasTriples >= needTriples && hasLadders >= needLadders };
            }

            findSequences(hand) {
                const seqs = { triples: [], ladders: [] };
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });


                Object.values(byRank).forEach(g => {
                    if (g.length >= 3) {
                        // ‚úÖ FIX 1C: Generate ALL combinations of 3 cards (not just sliding windows)
                        for (let i = 0; i < g.length - 2; i++) {
                            for (let j = i + 1; j < g.length - 1; j++) {
                                for (let k = j + 1; k < g.length; k++) {
                                    seqs.triples.push([g[i], g[j], g[k]]);
                                }
                            }
                        }
                    }
                });


                const bySuit = {};
                hand.forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c) });
                Object.values(bySuit).forEach(g => {
                    if (g.length >= 4) {
                        const hasAce = g.find(c => c.rank === 'A');
                        const hasK = g.find(c => c.rank === 'K');
                        const hasQ = g.find(c => c.rank === 'Q');
                        const hasJ = g.find(c => c.rank === 'J');
                        if (hasAce && hasK && hasQ && hasJ) seqs.ladders.push([hasAce, hasK, hasQ, hasJ]);
                        const uniqueByRank = [];
                        const seenRanks = new Set();
                        g.sort((a, b) => a.getValue() - b.getValue());
                        g.forEach(card => { if (!seenRanks.has(card.rank)) { uniqueByRank.push(card); seenRanks.add(card.rank) } });
                        for (let i = 0; i <= uniqueByRank.length - 4; i++) {
                            const ladder = uniqueByRank.slice(i, i + 4);
                            if (this.isValidLadder(ladder)) seqs.ladders.push(ladder);
                        }
                    }
                });
                return seqs;
            }

            canPublish(pIdx) {
                const hand = this.playerHands[pIdx];
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                const byRank = {};
                hand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                const tripleRanks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3);
                if (tripleRanks.length < needTriples) return false;
                const tryPublish = (tripleAssignments, triplesAssigned, usedIds, startRankIdx = 0) => {
                    if (triplesAssigned === needTriples) {
                        let laddersFound = 0; const usedForLadders = new Set(usedIds);
                        for (let i = 0; i < needLadders; i++) {
                            const remaining = hand.filter(c => !usedForLadders.has(c.id));
                            const testSeqs = this.findSequences(remaining);
                            if (testSeqs.ladders.length === 0) break;
                            testSeqs.ladders[0].forEach(c => usedForLadders.add(c.id));
                            laddersFound++;
                        }
                        return laddersFound >= needLadders;
                    }
                    for (let rankIdx = startRankIdx; rankIdx < tripleRanks.length; rankIdx++) {
                        const rank = tripleRanks[rankIdx];
                        const cards = byRank[rank];
                        if (cards.length >= 4) {
                            for (let i = 0; i < cards.length - 2; i++) {
                                for (let j = i + 1; j < cards.length - 1; j++) {
                                    for (let k = j + 1; k < cards.length; k++) {
                                        const newUsed = new Set(usedIds);
                                        newUsed.add(cards[i].id); newUsed.add(cards[j].id); newUsed.add(cards[k].id);
                                        if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                                    }
                                }
                            }
                        } else {
                            const newUsed = new Set(usedIds);
                            cards.slice(0, 3).forEach(c => newUsed.add(c.id));
                            if (tryPublish(tripleAssignments, triplesAssigned + 1, newUsed, rankIdx + 1)) return true;
                        }
                    }
                    return false;
                };
                return tryPublish([], 0, new Set());
            }

            // üéØ v4.0.7: Separate flat array of cards into 2D sequences
            separateSequences(cards, requirements) {
                const req = requirements;
                const sequences = [];
                const usedInSequence = new Set();
                
                // Extract triples first
                const byRank = {};
                cards.forEach(c => {
                    if (!byRank[c.rank]) byRank[c.rank] = [];
                    byRank[c.rank].push(c);
                });
                
                Object.values(byRank).forEach(rankCards => {
                    if (rankCards.length >= 3) {
                        // üéØ v4.0.7 FIX: Handle 4-of-a-kind properly
                        // If exactly 4 cards, keep them together
                        // If more than 4, group by 3s
                        if (rankCards.length === 4) {
                            sequences.push(rankCards);
                            rankCards.forEach(c => usedInSequence.add(c.id));
                        } else {
                            // Group by 3s for 3, 5, 6, 7+ cards
                            for (let i = 0; i + 2 < rankCards.length; i += 3) {
                                const triple = rankCards.slice(i, i + 3);
                                sequences.push(triple);
                                triple.forEach(c => usedInSequence.add(c.id));
                            }
                        }
                    }
                });
                
                // Extract ladders from remaining cards
                const remainingCards = cards.filter(c => !usedInSequence.has(c.id));
                const bySuit = {};
                remainingCards.forEach(c => {
                    if (!bySuit[c.suit]) bySuit[c.suit] = [];
                    bySuit[c.suit].push(c);
                });
                
                // üêõ FIX v4.0.9: Only accept CONSECUTIVE cards as ladders
                Object.values(bySuit).forEach(suitCards => {
                    if (suitCards.length >= 4) {
                        suitCards.sort((a, b) => a.getValue() - b.getValue());
                        
                        // Check for wrap-around ladder (A-K-Q-J...) FIRST
                        const values = suitCards.map(c => c.getValue());
                        const hasAce = values.includes(1);
                        const hasKing = values.includes(13);
                        
                        if (hasAce && hasKing) {
                            // Potential wrap-around - check if we have consecutive high cards leading to King
                            const nonAceCards = suitCards.filter(c => c.getValue() !== 1);
                            nonAceCards.sort((a, b) => b.getValue() - a.getValue()); // Sort high to low
                            
                            // Build wrap ladder from King downward
                            let wrapLadder = [];
                            let expectedValue = 13; // Start at King
                            
                            for (let card of nonAceCards) {
                                if (card.getValue() === expectedValue) {
                                    wrapLadder.push(card);
                                    expectedValue--;
                                } else {
                                    break; // Gap found
                                }
                            }
                            
                            // If we have 3+ consecutive high cards (K, Q, J minimum), add Ace at front
                            if (wrapLadder.length >= 3) {
                                const aceCard = suitCards.find(c => c.getValue() === 1);
                                wrapLadder.unshift(aceCard); // Add Ace at the beginning
                                sequences.push([...wrapLadder]);
                                
                                // Remove used cards from suitCards for normal ladder processing
                                const usedIds = new Set(wrapLadder.map(c => c.id));
                                suitCards = suitCards.filter(c => !usedIds.has(c.id));
                            }
                        }
                        
                        // Now find regular consecutive ladders in remaining cards
                        if (suitCards.length >= 4) {
                            suitCards.sort((a, b) => a.getValue() - b.getValue());
                            let currentLadder = [suitCards[0]];
                            
                            for (let i = 1; i < suitCards.length; i++) {
                                const prevValue = currentLadder[currentLadder.length - 1].getValue();
                                const currValue = suitCards[i].getValue();
                                
                                if (currValue === prevValue + 1) {
                                    currentLadder.push(suitCards[i]);
                                } else {
                                    // Gap found - save current ladder if valid, start new one
                                    if (currentLadder.length >= 4) {
                                        sequences.push([...currentLadder]);
                                    }
                                    currentLadder = [suitCards[i]];
                                }
                            }
                            
                            // Don't forget the last ladder!
                            if (currentLadder.length >= 4) {
                                sequences.push(currentLadder);
                            }
                        }
                    }
                });
                
                return sequences;
            }

            autoPublish(pIdx) {
                // üõ°Ô∏è FIX 6: CRITICAL - Block republishing!
                if (this.publishedSequences[pIdx].length > 0) {
                    console.log(`‚è≠Ô∏è FIX 6: Player ${pIdx} already has ${this.publishedSequences[pIdx].length} published sequences - blocking republish`);
                    return false;
                }

                // üèóÔ∏è v4.5.3: STAGED CONSTRUCTION - Use locked sequences for Hands 6-7
                if (this.currentHand >= 6 && this.aiLockedSequences[pIdx].length > 0) {
                    console.log(`  üèóÔ∏è v4.5.3: Using ${this.aiLockedSequences[pIdx].length} locked sequences for publishing`);
                    
                    const req = this.handReqs[this.currentHand].seqs;
                    const triplesNeeded = req.filter(s => s === 'triple').length;
                    const laddersNeeded = req.filter(s => s === 'ladder').length;
                    
                    const lockedTriples = this.aiLockedSequences[pIdx].filter(s => s.type === 'triple');
                    const lockedLadders = this.aiLockedSequences[pIdx].filter(s => s.type === 'ladder');
                    
                    console.log(`      Need: ${triplesNeeded}T + ${laddersNeeded}L`);
                    console.log(`      Have locked: ${lockedTriples.length}T + ${lockedLadders.length}L`);
                    
                    // Check if we have all requirements locked
                    if (lockedTriples.length >= triplesNeeded && lockedLadders.length >= laddersNeeded) {
                        console.log(`      ‚úÖ All requirements met! Publishing locked sequences`);
                        
                        // Build published array from locked sequences
                        const published = [];
                        for (let i = 0; i < triplesNeeded; i++) {
                            published.push(...lockedTriples[i].cards);
                        }
                        for (let i = 0; i < laddersNeeded; i++) {
                            published.push(...lockedLadders[i].cards);
                        }
                        
                        // Separate into 2D structure
                        const sequences = this.separateSequences(published, req);
                        
                        // Remove published cards from hand
                        published.forEach(c => {
                            const idx = this.playerHands[pIdx].findIndex(card => card.id === c.id);
                            if (idx > -1) this.playerHands[pIdx].splice(idx, 1);
                        });
                        
                        // Set published sequences
                        this.publishedSequences[pIdx] = sequences;
                        this.aiJustPublished[pIdx] = true;
                        
                        console.log(`      ‚úÖ v4.5.3: Published ${sequences.length} sequences from locked cards`);
                        return true;
                    } else {
                        console.log(`      ‚ùå Not all requirements locked yet - continue building`);
                        return false;
                    }
                }

                const req = this.handReqs[this.currentHand].seqs;
                const hand = this.playerHands[pIdx];
                const opponentRanks = new Set();

                const opponentSuits = new Set();
                for (let i = 0; i < this.players; i++) {
                    if (i !== pIdx) {
                        this.getPublishedRanks(i).forEach(r => opponentRanks.add(r));
                        this.getPublishedSuits(i).forEach(s => opponentSuits.add(s));
                    }
                }
                let published = [];
                const usedCardIds = new Set();
                let triplesPublished = 0;
                let laddersPublished = 0;
                const triplesNeeded = req.filter(s => s === 'triple').length;
                const laddersNeeded = req.filter(s => s === 'ladder').length;
                while (triplesPublished < triplesNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const byRank = {};
                    availableHand.forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c) });
                    const ranks = Object.keys(byRank).filter(rank => byRank[rank].length >= 3).sort((a, b) => {
                        const aOverlap = opponentRanks.has(a) ? 1 : 0;
                        const bOverlap = opponentRanks.has(b) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return parseInt(a === 'A' ? 1 : a === 'J' ? 11 : a === 'Q' ? 12 : a === 'K' ? 13 : a) -
                            parseInt(b === 'A' ? 1 : b === 'J' ? 11 : b === 'Q' ? 12 : b === 'K' ? 13 : b);
                    });
                    if (ranks.length === 0) break;
                    const rank = ranks[0];
                    const cards = byRank[rank];
                    if (cards.length >= 4) {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    } else {
                        published = published.concat(cards.slice(0, 3));
                        cards.slice(0, 3).forEach(c => usedCardIds.add(c.id));
                    }
                    triplesPublished++;
                }
                while (laddersPublished < laddersNeeded) {
                    const availableHand = hand.filter(c => !usedCardIds.has(c.id));
                    const seqs = this.findSequences(availableHand);
                    if (seqs.ladders.length === 0) break;
                    seqs.ladders.sort((a, b) => {
                        const aOverlap = opponentSuits.has(a[0].suit) ? 1 : 0;
                        const bOverlap = opponentSuits.has(b[0].suit) ? 1 : 0;
                        if (aOverlap !== bOverlap) return aOverlap - bOverlap;
                        return a[0].getValue() - b[0].getValue();
                    });
                    const ladder = seqs.ladders[0];
                    published = published.concat(ladder);
                    ladder.forEach(c => usedCardIds.add(c.id));
                    laddersPublished++;
                }
                if (triplesPublished < triplesNeeded || laddersPublished < laddersNeeded) return false;
                
                // üéØ v4.0.7: Use separateSequences to build 2D structure
                const sequences = this.separateSequences(published, req);
                
                // Remove published cards from hand
                published.forEach(c => {
                    const idx = this.playerHands[pIdx].findIndex(card => card.id === c.id);
                    if (idx > -1) this.playerHands[pIdx].splice(idx, 1);
                });
                
                // üéØ v4.0.7: Store as 2D array!
                this.publishedSequences[pIdx] = sequences;
                
                console.log(`%cüéØ v4.0.7: Published ${sequences.length} separate sequences for Player ${pIdx}`, 'color: #27ae60; font-weight: bold;');
                sequences.forEach((seq, i) => {
                    console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString()).join(' ')}`);
                });

                // ‚Üê ADD THESE TWO LINES HERE:
                this.renderAIHands();
                this.renderPublished();

                return true;
            }

            // ‚úÖ FIX 1: Explicit LOW and HIGH end ladder extension support
            canCardExtendLadder(cardVal, ladderValues) {
                const sorted = [...ladderValues].sort((a, b) => a - b);
                const minVal = sorted[0];
                const maxVal = sorted[sorted.length - 1];

                console.log(`  üîç FIX 1: Checking if ${cardVal} can extend ladder [${sorted.join(',')}]`);

                // Check for wrap-around ladder (A-K-Q-J)
                const hasAce = sorted.includes(1);
                const hasKing = sorted.includes(13);
                const hasQueen = sorted.includes(12);
                const hasJack = sorted.includes(11);
                const isWrapAroundLadder = hasAce && hasJack && hasQueen && hasKing;

                if (isWrapAroundLadder) {
                    if (cardVal === 1) return false; // No duplicate Ace
                    const nonAceValues = sorted.filter(v => v !== 1);
                    const lowEnd = Math.min(...nonAceValues);
                    const canExtend = cardVal === lowEnd - 1;
                    console.log(`  ‚úÖ FIX 1: Wrap-around ladder - Can extend LOW: ${canExtend}`);
                    return canExtend;
                }

                // ‚úÖ FIX 7: Special case - Ace can extend after King (K-A wrap)
                if (cardVal === 1 && maxVal === 13) {
                    console.log(`  ‚úÖ FIX 7: ACE after KING wrap: true`);
                    return true;
                }

                // ‚úÖ FIX 1: Normal ladders - EXPLICIT support for BOTH ends
                const canExtendLow = (cardVal === minVal - 1);
                const canExtendHigh = (cardVal === maxVal + 1);

                console.log(`  ‚úÖ FIX 1: LOW end (${minVal}-1=${minVal - 1}): ${canExtendLow}`);
                console.log(`  ‚úÖ FIX 1: HIGH end (${maxVal}+1=${maxVal + 1}): ${canExtendHigh}`);

                return canExtendLow || canExtendHigh;
            }

            // üèóÔ∏è v4.5.3 STAGED CONSTRUCTION FUNCTIONS
            // ==========================================

            analyzeNearSequential(cards, suit) {
                // Finds partial sequences in a suit and identifies gaps
                // Returns: { values: [4,6,8], gaps: [5,7], potential: 2 }
                const suitCards = cards.filter(c => c.suit === suit);
                if (suitCards.length < 2) return { values: [], gaps: [], potential: 0 };
                
                const values = suitCards.map(c => c.getValue()).sort((a, b) => a - b);
                const gaps = [];
                let gapCount = 0;
                
                for (let i = 0; i < values.length - 1; i++) {
                    const gap = values[i + 1] - values[i];
                    if (gap === 2) {
                        // One card missing: e.g., 4 and 6, missing 5
                        gaps.push(values[i] + 1);
                        gapCount++;
                    } else if (gap === 3) {
                        // Two cards missing: e.g., 4 and 7, missing 5,6
                        gaps.push(values[i] + 1, values[i] + 2);
                        gapCount += 2;
                    }
                }
                
                // Potential: high card count + low gaps = high potential
                const potential = suitCards.length - gapCount;
                
                console.log(`  üîç v4.5.3: Analyzing ${suit} - ${values.join(',')} - gaps: [${gaps.join(',')}] - potential: ${potential}`);
                return { values, gaps, potential, cardCount: suitCards.length };
            }

            selectSuitFocus(hand, numSuits = 2) {
                // Selects 2-3 suits with highest ladder-building potential
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const analysis = suits.map(suit => ({
                    suit,
                    ...this.analyzeNearSequential(hand, suit)
                }));
                
                // Sort by: 1) potential, 2) card count, 3) fewer gaps
                analysis.sort((a, b) => {
                    if (b.potential !== a.potential) return b.potential - a.potential;
                    if (b.cardCount !== a.cardCount) return b.cardCount - a.cardCount;
                    return a.gaps.length - b.gaps.length;
                });
                
                const selected = analysis.slice(0, numSuits).map(a => a.suit);
                console.log(`  üéØ v4.5.3: Selected focus suits: ${selected.join(', ')}`);
                return selected;
            }

            selectSuitFocusFromSuits(hand, availableSuits, numSuits = 2) {
                // üîß v4.5.3: Select suits from a limited set (excluding locked ladder suits)
                const analysis = availableSuits.map(suit => ({
                    suit,
                    ...this.analyzeNearSequential(hand, suit)
                }));
                
                // Sort by: 1) potential, 2) card count, 3) fewer gaps
                analysis.sort((a, b) => {
                    if (b.potential !== a.potential) return b.potential - a.potential;
                    if (b.cardCount !== a.cardCount) return b.cardCount - a.cardCount;
                    return a.gaps.length - b.gaps.length;
                });
                
                const selected = analysis.slice(0, Math.min(numSuits, availableSuits.length)).map(a => a.suit);
                console.log(`  üéØ v4.5.3: Selected focus suits from ${availableSuits.join(',')}: ${selected.join(', ')}`);
                return selected;
            }

            getUnlockedCards(hand, playerIdx) {
                // üîß v4.5.3: Get cards not in locked sequences
                const lockedCardIds = new Set();
                this.aiLockedSequences[playerIdx].forEach(seq => {
                    seq.cards.forEach(card => lockedCardIds.add(card.id));
                });
                return hand.filter(card => !lockedCardIds.has(card.id));
            }

            // üî∂ v4.5.3: HOLD SYSTEM - Parallel Construction Functions
            
            findPotentialHolds(hand, playerIdx) {
                // Find all 3-card combinations that are "one card away" from a 4-card ladder
                const holds = [];
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                
                // Exclude suits already used in locked ladders
                const lockedSuits = this.aiLockedSequences[playerIdx]
                    .filter(s => s.type === 'ladder')
                    .map(s => s.suit);
                const availableSuits = suits.filter(s => !lockedSuits.includes(s));
                
                availableSuits.forEach(suit => {
                    // Get all cards of this suit, sorted by value
                    const suitCards = hand
                        .filter(c => c.suit === suit)
                        .sort((a, b) => a.getValue() - b.getValue());
                    
                    if (suitCards.length < 3) return;
                    
                    // Check all 3-card combinations
                    for (let i = 0; i < suitCards.length - 2; i++) {
                        for (let j = i + 1; j < suitCards.length - 1; j++) {
                            for (let k = j + 1; k < suitCards.length; k++) {
                                const three = [suitCards[i], suitCards[j], suitCards[k]];
                                const targets = this.findCompletionTargets(three);
                                
                                if (targets.length > 0) {
                                    holds.push({
                                        cards: three,
                                        suit: suit,
                                        targets: targets,
                                        type: 'ladder',
                                        createdTurn: this.turnCounter,
                                        priority: this.calculateHoldPriority(three, targets)
                                    });
                                }
                            }
                        }
                    }
                });
                
                return holds;
            }

            findCompletionTargets(threeCards) {
                // Given 3 cards, find which single card would complete a 4-card ladder
                const values = threeCards.map(c => c.getValue()).sort((a, b) => a - b);
                const [v1, v2, v3] = values;
                const targets = [];
                
                // Pattern 1: [v1, v2, v3] are consecutive ‚Üí can extend left or right
                // Example: 6,7,8 ‚Üí need 5 or 9
                if (v2 === v1 + 1 && v3 === v2 + 1) {
                    if (v1 > 1) targets.push(v1 - 1);    // Extend left
                    if (v3 < 13) targets.push(v3 + 1);   // Extend right
                }
                
                // Pattern 2: Gap between v1 and v2
                // Example: 6,8,9 ‚Üí need 7 to make [6,7,8,9]
                else if (v2 === v1 + 2 && v3 === v2 + 1) {
                    targets.push(v1 + 1);  // Fill gap
                }
                
                // Pattern 3: Gap between v2 and v3
                // Example: 6,7,9 ‚Üí need 8 to make [6,7,8,9]
                else if (v2 === v1 + 1 && v3 === v2 + 2) {
                    targets.push(v2 + 1);  // Fill gap
                }
                
                // If no patterns match, this isn't "one card away" (e.g., 6,8,10 needs TWO cards)
                return targets;
            }

            calculateHoldPriority(threeCards, targets) {
                // Higher priority = more likely to complete
                let priority = 10; // Base priority
                
                // Bonus: Sequential cards (6,7,8) have 2 targets = higher chance
                if (targets.length === 2) {
                    priority += 5;
                }
                
                // Bonus: High-value cards (better for scoring)
                const avgValue = threeCards.reduce((sum, c) => sum + c.getValue(), 0) / 3;
                if (avgValue >= 8) priority += 3;
                
                // Bonus: Middle ranks (6-9) are most available
                const middleRanks = targets.filter(t => t >= 6 && t <= 9).length;
                priority += middleRanks * 2;
                
                return priority;
            }

            putOnHold(playerIdx, hold) {
                // Add to held sequences
                this.aiHeldSequences[playerIdx].push(hold);
                
                const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                const cardStr = hold.cards.map(c => c.toString()).join(',');
                const targetStr = hold.targets.map(t => `${t}${hold.suit}`).join(' or ');
                
                console.log(`üî∂ v4.5.3: ${aiName} put on HOLD: ${cardStr} - targeting ${targetStr}`);
            }

            checkHeldSequences(playerIdx) {
                // Check if any held sequences can now be completed
                const hand = this.playerHands[playerIdx];
                const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                
                // Iterate backwards to safely remove completed holds
                for (let i = this.aiHeldSequences[playerIdx].length - 1; i >= 0; i--) {
                    const hold = this.aiHeldSequences[playerIdx][i];
                    
                    // Check if we now have any of the target cards
                    const targetCard = hand.find(card => 
                        card.suit === hold.suit && 
                        hold.targets.includes(card.getValue())
                    );
                    
                    if (targetCard) {
                        // Found target! Complete the hold!
                        const completedLadder = [...hold.cards, targetCard]
                            .sort((a, b) => a.getValue() - b.getValue());
                        
                        this.lockSequence(playerIdx, completedLadder, 'ladder', hold.suit);
                        
                        console.log(`‚úÖ v4.5.3: ${aiName} completed HOLD! Got ${targetCard.toString()} ‚Üí Locked ${completedLadder.map(c => c.toString()).join(',')}`);
                        
                        // Remove from holds
                        this.aiHeldSequences[playerIdx].splice(i, 1);
                        
                        // Check if ready to publish
                        this.advanceConstructionStage(playerIdx);
                    }
                }
            }

            generateTargetCardsWithHolds(hand, suitFocus, playerIdx, maxTargets = 5) {
                // Generate targets including both current stage and all held sequences
                const targets = [];
                
                // Original targets for current stage
                const stageTargets = this.generateTargetCards(hand, suitFocus, maxTargets);
                targets.push(...stageTargets);
                
                // Add targets from ALL held sequences
                this.aiHeldSequences[playerIdx].forEach(hold => {
                    hold.targets.forEach(rank => {
                        const targetCard = `${rank}${hold.suit}`;
                        if (!targets.includes(targetCard)) {
                            targets.push(targetCard);
                            console.log(`  üéØ v4.5.3: HOLD target: ${targetCard} (completes ${hold.cards.map(c => c.toString()).join(',')})`);
                        }
                    });
                });
                
                return targets.slice(0, maxTargets + 3); // Allow a few extra for holds
            }

            // üíö v4.5.3: AGGRESSIVE BUY MODE - Detect when AI needs to be more lenient
            isAggressiveBuyMode(playerIdx) {
                // Detects "scattered card emergency" - when AI is stuck and needs to lower standards
                const stage = this.aiConstructionStage[playerIdx];
                const turnsOnStage = this.turnCounter - this.aiStageStartTurn[playerIdx];
                const buysRemaining = this.playerBuys[playerIdx];
                const hand = this.playerHands[playerIdx];
                const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                const seqs = this.findSequences(unlockedHand);
                const holds = this.findPotentialHolds(unlockedHand, playerIdx);
                const targets = this.aiTargetCards[playerIdx];
                
                // Activate aggressive mode when:
                // 1. Stuck on building_L1 or building_L2 for 20+ turns
                // 2. No complete ladders found
                // 3. No holds possible (cards too scattered)
                // 4. Still have 2+ buys remaining
                // 5. Very few targets (1-2)
                
                const isStuck = (stage === 'building_L1' || stage === 'building_L2') && turnsOnStage >= 20;
                const noProgress = seqs.ladders.length === 0 && holds.length === 0;
                const hasBuys = buysRemaining >= 2;
                const fewTargets = targets.length <= 2;
                
                const aggressive = isStuck && noProgress && hasBuys && fewTargets;
                
                if (aggressive) {
                    const aiName = playerIdx === 1 ? 'Habot' : 'Jabot';
                    console.log(`%cüíö v4.5.3: ${aiName} AGGRESSIVE BUY MODE activated!`, 'color: #27ae60; font-weight: bold;');
                    console.log(`   Reason: Stuck on ${stage} for ${turnsOnStage} turns, ${buysRemaining} buys left, only ${targets.length} targets`);
                }
                
                return aggressive;
            }


            generateTargetCards(hand, suitFocus, maxTargets = 3) {
                // Identifies specific cards needed to complete sequences
                const targets = [];
                
                for (let suit of suitFocus) {
                    const analysis = this.analyzeNearSequential(hand, suit);
                    
                    // Prioritize gaps that would create 4+ sequential runs
                    for (let gap of analysis.gaps) {
                        const rank = this.valueToRank(gap);
                        const targetCard = `${rank}${suit}`;
                        
                        // Check if adding this card would create 4+ run
                        const testValues = [...analysis.values, gap].sort((a, b) => a - b);
                        let maxRun = 1, currentRun = 1;
                        for (let i = 1; i < testValues.length; i++) {
                            if (testValues[i] === testValues[i-1] + 1) {
                                currentRun++;
                                maxRun = Math.max(maxRun, currentRun);
                            } else {
                                currentRun = 1;
                            }
                        }
                        
                        if (maxRun >= 4 && !targets.includes(targetCard)) {
                            targets.push(targetCard);
                            console.log(`  üéØ v4.5.3: Target card: ${targetCard} (would create ${maxRun}-card run)`);
                            if (targets.length >= maxTargets) break;
                        }
                    }
                    if (targets.length >= maxTargets) break;
                }
                
                return targets;
            }

            valueToRank(value) {
                // Converts card value (1-13) to rank string
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                return ranks[value - 1] || 'A';
            }

            lockSequence(playerIdx, cards, type, suit = null) {
                // Marks a completed sequence as protected from discard
                const locked = { type, cards: [...cards], suit };
                this.aiLockedSequences[playerIdx].push(locked);
                console.log(`  üîí v4.5.3: LOCKED ${type} sequence (${cards.length} cards) for Player ${playerIdx}`);
                return locked;
            }

            isSequenceLocked(playerIdx, card) {
                // Checks if a card is part of any locked sequence
                for (let locked of this.aiLockedSequences[playerIdx]) {
                    if (locked.cards.some(c => c.id === card.id)) {
                        return true;
                    }
                }
                return false;
            }

            advanceConstructionStage(playerIdx) {
                // Moves AI to next construction stage based on completed sequences
                const currentStage = this.aiConstructionStage[playerIdx];
                const hand = this.playerHands[playerIdx];
                const seqs = this.findSequences(hand);
                const req = this.handReqs[this.currentHand].seqs;
                const needTriples = req.filter(s => s === 'triple').length;
                const needLadders = req.filter(s => s === 'ladder').length;
                
                console.log(`  üèóÔ∏è v4.5.3: Stage check for Player ${playerIdx} - Current: ${currentStage}`);
                console.log(`      Has: ${seqs.triples.length} triples, ${seqs.ladders.length} ladders`);
                console.log(`      Need: ${needTriples} triples, ${needLadders} ladders`);
                console.log(`      Locked: ${this.aiLockedSequences[playerIdx].length} sequences`);
                
                // Count locked ladders
                const lockedLadders = this.aiLockedSequences[playerIdx].filter(s => s.type === 'ladder').length;
                
                if (currentStage === 'building_L1' && lockedLadders >= 1) {
                    // First ladder complete ‚Üí move to building second ladder
                    if (needLadders >= 2) {
                        this.aiConstructionStage[playerIdx] = 'building_L2';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // üíö v4.5.3: Track stage change
                        console.log(`  üéØ v4.5.3: ADVANCED to building_L2 (first ladder locked)`);
                        // üîß v4.5.3: Exclude suits already used in locked ladders
                        const lockedSuits = this.aiLockedSequences[playerIdx]
                            .filter(s => s.type === 'ladder')
                            .map(s => s.suit);
                        console.log(`      üö´ v4.5.3: Excluding locked ladder suits: ${lockedSuits.join(', ')}`);
                        const availableSuits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'].filter(s => !lockedSuits.includes(s));
                        // Select from UNLOCKED hand only, in different suits
                        const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                        const focusSuits = this.selectSuitFocusFromSuits(unlockedHand, availableSuits, 2);
                        this.aiSuitFocus[playerIdx] = focusSuits;
                        this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(unlockedHand, focusSuits, playerIdx);
                    } else {
                        // Only need 1 ladder total ‚Üí move to triple
                        this.aiConstructionStage[playerIdx] = 'building_T';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // üíö v4.5.3: Track stage change
                        console.log(`  üéØ v4.5.3: ADVANCED to building_T (only 1 ladder needed)`);
                    }
                } else if (currentStage === 'building_L2' && lockedLadders >= 2) {
                    // üîß v4.5.3: Check if we need a third ladder or a triple
                    if (needLadders >= 3) {
                        // Hand 7: Need 3 ladders ‚Üí build third ladder
                        this.aiConstructionStage[playerIdx] = 'building_L3';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // üíö v4.5.3: Track stage change
                        console.log(`  üéØ v4.5.3: ADVANCED to building_L3 (need third ladder)`);
                        // üîß v4.5.3: Exclude suits from L1 and L2
                        const lockedSuits = this.aiLockedSequences[playerIdx]
                            .filter(s => s.type === 'ladder')
                            .map(s => s.suit);
                        console.log(`      üö´ v4.5.3: Excluding locked ladder suits: ${lockedSuits.join(', ')}`);
                        const availableSuits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'].filter(s => !lockedSuits.includes(s));
                        const unlockedHand = this.getUnlockedCards(hand, playerIdx);
                        const focusSuits = this.selectSuitFocusFromSuits(unlockedHand, availableSuits, 2);
                        this.aiSuitFocus[playerIdx] = focusSuits;
                        this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(unlockedHand, focusSuits, playerIdx);
                    } else if (needTriples >= 1) {
                        // Hand 6: Need triple ‚Üí build triple
                        this.aiConstructionStage[playerIdx] = 'building_T';
                        this.aiStageStartTurn[playerIdx] = this.turnCounter; // üíö v4.5.3: Track stage change
                        console.log(`  üéØ v4.5.3: ADVANCED to building_T (need triple)`);
                    } else {
                        // Edge case: already have everything
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  ‚úÖ v4.5.3: READY TO PUBLISH! All requirements met!`);
                    }
                } else if (currentStage === 'building_L3' && lockedLadders >= 3) {
                    // üîß v4.5.3: Third ladder complete (Hand 7)
                    const lockedTriples = this.aiLockedSequences[playerIdx].filter(s => s.type === 'triple').length;
                    if (lockedTriples >= needTriples && lockedLadders >= needLadders) {
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  ‚úÖ v4.5.3: READY TO PUBLISH! All 3 ladders locked!`);
                    }
                } else if (currentStage === 'building_T') {
                    // Check if we have all requirements
                    const lockedTriples = this.aiLockedSequences[playerIdx].filter(s => s.type === 'triple').length;
                    if (lockedTriples >= needTriples && lockedLadders >= needLadders) {
                        this.aiConstructionStage[playerIdx] = 'ready_to_publish';
                        console.log(`  ‚úÖ v4.5.3: READY TO PUBLISH! All sequences complete!`);
                    }
                }
            }

            updateStagedConstructionTargets(playerIdx) {
                // Updates target cards and suit focus based on current stage and hand
                if (this.currentHand < 6) return; // Only for Hands 6-7
                
                const hand = this.playerHands[playerIdx];
                const stage = this.aiConstructionStage[playerIdx];
                
                if (stage === 'building_L1' || stage === 'building_L2') {
                    // Select best suits for ladder building
                    const focusSuits = this.selectSuitFocus(hand, 2);
                    this.aiSuitFocus[playerIdx] = focusSuits;
                    this.aiTargetCards[playerIdx] = this.generateTargetCardsWithHolds(hand, focusSuits, playerIdx, 3);
                }
            }

            couldExtendSequence(card, playerIdx) {
                // üéØ v4.0.7: Get flat view since we need to check individual cards
                const published = this.getFlatPublished(playerIdx);
                if (published.length === 0) return false;
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const publishedRankCounts = {};
                published.forEach(c => { publishedRankCounts[c.rank] = (publishedRankCounts[c.rank] || 0) + 1 });
                const hasActualTriples = Object.values(publishedRankCounts).some(count => count >= 3);
                const publishedSuits = {};
                published.forEach(c => { if (!publishedSuits[c.suit]) publishedSuits[c.suit] = []; publishedSuits[c.suit].push(c.getValue()) });
                const hasActualLadders = Object.values(publishedSuits).some(vals => vals.length >= 4);
                if (hasTriples || hasActualTriples) { if (publishedRankCounts[card.rank] >= 3) return true }

                if (hasLadders || hasActualLadders) {
                    // ‚úÖ FIX 1B: Don't filter out "triple cards" - just get ALL cards of matching suit
                    // This handles cases where a rank appears in both triple and ladder (e.g., 8‚ô¶ 8‚ô£ 8‚ô¶ + 7‚ô• 8‚ô• 9‚ô• 10‚ô•)
                    const sameSuit = published.filter(c => c.suit === card.suit);

                    console.log(`  üîç FIX 1B: Checking ${card.toString()} against ${sameSuit.length} published ${card.suit} cards`);

                    if (sameSuit.length >= 4) {
                        const cardVal = card.getValue();
                        const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                        const ladders = []; let remainingValues = [...values];
                        const hasAce = values.includes(1); const hasJack = values.includes(11);
                        const hasQueen = values.includes(12); const hasKing = values.includes(13);

                        if (hasAce && hasJack && hasQueen && hasKing) {
                            // üîß FIX 8 (v4.0.7): Extract ALL consecutive cards from King downward
                            // Bug: Previous code only checked v >= 11, missing cards like 9-10
                            const wrapLadder = [1];  // Start with Ace (value 1)
                            
                            // Get ALL non-ace cards sorted from high to low
                            const sortedCards = values.filter(v => v >= 2).sort((a, b) => b - a);
                            
                            // Start from King (13) and work downward, taking consecutive cards
                            let expectedValue = 13;
                            for (let val of sortedCards) {
                                if (val === expectedValue) {
                                    wrapLadder.push(val);
                                    expectedValue--;
                                } else if (val < expectedValue) {
                                    // Gap found - stop here (e.g., have K-Q but missing J)
                                    break;
                                }
                                // If val > expectedValue, skip it (shouldn't happen in sorted order)
                            }
                            
                            console.log(`  üîß FIX 8: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                            ladders.push(wrapLadder);
                            remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                        }

                        if (remainingValues.length >= 4) {
                            let currentLadder = [remainingValues[0]];
                            for (let i = 1; i < remainingValues.length; i++) {
                                if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                    currentLadder.push(remainingValues[i]);
                                } else {
                                    if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                    currentLadder = [remainingValues[i]];
                                }
                            }
                            if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                        }
                        const canExtend = ladders.some(ladder => {
                            return this.canCardExtendLadder(cardVal, ladder);
                        });
                        if (canExtend) return true;
                    }
                }

                return false;
            }

            canAddToPublishedSequence(card, publishedSequence) {
                // üîß PATCH S: Handle both structured sequence objects and legacy flat arrays
                const seq = publishedSequence.cards || publishedSequence;

                // For triples/quads - check if same rank
                if (seq.length >= 3 && seq.every(c => c.rank === seq[0].rank)) {
                    return card.rank === seq[0].rank;
                }

                // For ladders - use canCardExtendLadder (handles wrap-around!)
                if (seq.length >= 3) {
                    // üîß PATCH S: Check suit consistency in sequence first
                    const suits = [...new Set(seq.map(c => c.suit))];
                    if (suits.length !== 1) {
                        // Mixed suits = not a valid ladder, probably a triple
                        return false;
                    }

                    const seqSuit = seq[0].suit;
                    if (card.suit !== seqSuit) return false;

                    // ‚úÖ v4.3.2 FIX: Use canCardExtendLadder which handles wrap-around A-K-Q-J
                    const cardVal = card.getValue();
                    const ladderValues = seq.map(c => c.getValue());
                    return this.canCardExtendLadder(cardVal, ladderValues);
                }

                return false;
            }

            // üîß PATCH S: Helper to separate flat published array into individual sequences
            // üéØ v3.0: Added smart caching to reduce logging spam from 50+ to 3 logs per turn
            separatePublishedSequences(flatArray, playerIdx) {
                if (!flatArray || flatArray.length === 0) return [];

                // üéØ v3.0: Check cache first
                const cacheKey = `p${playerIdx}_turn${this.turnCounter}`;
                
                // Reset cache if we're on a new turn
                if (this.sequenceSeparationCache.turnCounter !== this.turnCounter) {
                    this.sequenceSeparationCache.turnCounter = this.turnCounter;
                    this.sequenceSeparationCache.cache = {};
                }
                
                // Return cached result if available (prevents log spam)
                if (this.sequenceSeparationCache.cache[cacheKey]) {
                    return this.sequenceSeparationCache.cache[cacheKey];
                }

                // First time this turn for this player - do the work and log
                const handReq = this.handReqs[this.currentHand];
                const sequences = [];
                let currentIndex = 0;

                debugLog.info(`  üîß PATCH S: Separating ${flatArray.length} cards for Hand ${this.currentHand}`);
                debugLog.info(`  üîß PATCH S: Requirements: ${handReq.seqs.join(', ')}`);

                for (let req of handReq.seqs) {
                    if (currentIndex >= flatArray.length) break;

                    if (req === 'triple') {
                        // Take consecutive cards of same rank
                        const rank = flatArray[currentIndex].rank;
                        const triple = [];
                        while (currentIndex < flatArray.length &&
                            flatArray[currentIndex].rank === rank) {
                            triple.push(flatArray[currentIndex]);
                            currentIndex++;
                        }
                        if (triple.length >= 3) {
                            sequences.push({ type: 'triple', cards: triple });
                            debugLog.info(`  üîß PATCH S: Found triple of ${rank} (${triple.length} cards)`);
                        }
                    } else if (req === 'ladder') {
                        // Take consecutive cards of same suit in sequence
                        const suit = flatArray[currentIndex].suit;
                        const ladder = [flatArray[currentIndex]];
                        currentIndex++;

                        // üéØ CRITICAL FIX: When building ladder, look ahead for ALL cards of same suit
                        // This handles cases where a card (e.g., 7‚ô†) might be in a triple but ladder needs it
                        
                        // First pass: collect all remaining cards of same suit
                        const sameSuitCards = [];
                        for (let i = currentIndex; i < flatArray.length; i++) {
                            if (flatArray[i].suit === suit) {
                                sameSuitCards.push({ card: flatArray[i], originalIndex: i });
                            }
                        }
                        
                        // Sort by value to find consecutive runs
                        sameSuitCards.sort((a, b) => a.card.getValue() - b.card.getValue());
                        
                        // Build ladder by taking consecutive cards
                        let lastValue = ladder[0].getValue();
                        const usedIndices = new Set();
                        
                        for (let { card, originalIndex } of sameSuitCards) {
                            const cardValue = card.getValue();
                            
                            // Check if consecutive (or wrap K->A)
                            if (cardValue === lastValue + 1 || (lastValue === 13 && cardValue === 1)) {
                                ladder.push(card);
                                usedIndices.add(originalIndex);
                                lastValue = cardValue;
                            } else if (cardValue > lastValue + 1) {
                                // Gap found - stop building this ladder
                                break;
                            }
                        }
                        
                        // Update currentIndex to skip cards we used
                        // Advance past all cards we added to ladder
                        const maxUsedIndex = Math.max(...Array.from(usedIndices), currentIndex - 1);
                        currentIndex = maxUsedIndex + 1;

                        if (ladder.length >= 4) {
                            sequences.push({ type: 'ladder', cards: ladder });
                            debugLog.info(`  üîß PATCH S: Found ladder of ${suit} (${ladder.length} cards): ${ladder.map(c => c.rank).join('-')}`);
                        }
                    }
                }

                debugLog.info(`  üîß PATCH S: Separated into ${sequences.length} sequences`);
                
                // üéØ v3.0: Cache the result for this turn
                this.sequenceSeparationCache.cache[cacheKey] = sequences;
                
                return sequences;
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ü§ñ AI DECISION ENGINE - v3.0 Clean Architecture
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // This section contains the core AI logic for card evaluation,
            // discard selection, and strategic decision-making.
            //
            // Key Methods:
            // - evaluateCard(): Scores a card's value for pickup decisions
            // - findWorstCard(): Selects the optimal card to discard
            // - couldExtendSequence(): Checks if card helps opponent
            // - canAddToPublishedSequence(): Validates extension legality
            //
            // All bug fixes from v2.5.0 are preserved:
            // ‚úÖ FIX 1: Ladder extension (both high/low ends)
            // ‚úÖ PATCH G: AI win detection (extend own sequences)
            // ‚úÖ PATCH K: Enhanced endgame protection
            // ‚úÖ PATCH L: Smart pair valuation
            // ‚úÖ PATCH R/S: Universal discard safety (never help opponents)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            evaluateCard(card, pIdx) {
                const hand = this.playerHands[pIdx];
                let val = 0;

                const sameRank = hand.filter(c => c.rank === card.rank).length;
                const sameSuit = hand.filter(c => c.suit === card.suit);

                // üéØ PATCH L: Smart pair valuation based on game type
                const req = this.handReqs[this.currentHand].seqs;
                const hasOnlyTriples = req.every(s => s === 'triple');

                // Count existing pairs in hand
                const rankCounts = {};
                hand.forEach(c => rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1);
                const numPairs = Object.values(rankCounts).filter(count => count === 2).length;

                if (sameRank >= 2) {
                    // Already have 2+ of this rank - GREAT for triples!
                    val += 20;
                } else if (sameRank === 1) {
                    // Would CREATE a new pair
                    if (hasOnlyTriples && numPairs >= 4) {
                        // Triple game with 4+ pairs already - PENALIZE new pairs
                        console.log(`  ‚Üí PATCH L: Penalizing ${card.toString()} - already have ${numPairs} pairs in triple game`);
                        val -= 10;  // Negative value = don't want this card
                    } else if (numPairs >= 2 && !hasOnlyTriples) {
                        // Mixed game with 2+ pairs - slight penalty
                        val += 3;  // Reduced from 8
                    } else {
                        // Normal pair value
                        val += 8;
                    }
                }

                if (sameSuit.length >= 3) {
                    const values = sameSuit.map(c => c.getValue());
                    const cardVal = card.getValue();
                    const allValues = [...values, cardVal].sort((a, b) => a - b);
                    let maxConsecutive = 1;
                    let currentConsecutive = 1;
                    for (let i = 1; i < allValues.length; i++) {
                        if (allValues[i] === allValues[i - 1] + 1) {
                            currentConsecutive++;
                            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                        } else if (allValues[i] !== allValues[i - 1]) {
                            currentConsecutive = 1;
                        }
                    }
                    if (maxConsecutive >= 4) val += 25;
                    else if (maxConsecutive === 3) val += 15;
                    else if (maxConsecutive === 2) val += 5;
                } else if (sameSuit.length >= 2) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 6;
                } else if (sameSuit.length === 1) {
                    const hasAdj = sameSuit.some(c => Math.abs(c.getValue() - card.getValue()) === 1);
                    if (hasAdj) val += 3;
                }
                if (this.publishedSequences[pIdx].length > 0) {
                    if (this.couldExtendSequence(card, pIdx)) val += 100;
                }
                // üéØ v4.2.7 FIX: Cards that extend ANY published sequence are valuable!
                // Published sequences are global resources - extending them reduces YOUR hand!
                for (let p = 0; p < this.players; p++) {
                    if (this.publishedSequences[p].length === 0) continue;
                    if (p === pIdx) continue;
                    if (this.couldExtendSequence(card, p)) {
                        val += 30;  // ALWAYS good - you'll play it to extend and reduce your hand!
                    }
                }
                return val;
            }

            findWorstCard(pIdx) {
                let hand = this.playerHands[pIdx];  // üêõ v4.0.7: Changed to 'let' to allow reassignment

                // üîí v4.5.3: PROTECT LOCKED SEQUENCES from discard!
                if (this.currentHand >= 6 && this.aiLockedSequences[pIdx].length > 0) {
                    console.log(`  üîí v4.5.3: Protecting ${this.aiLockedSequences[pIdx].length} locked sequences from discard`);
                    
                    // Filter out ALL cards that are in locked sequences
                    const unlockedCards = hand.filter(card => !this.isSequenceLocked(pIdx, card));
                    
                    console.log(`      Total cards: ${hand.length}, Unlocked: ${unlockedCards.length}`);
                    
                    if (unlockedCards.length > 0) {
                        // Only consider unlocked cards for discard
                        hand = unlockedCards;
                        console.log(`      ‚úÖ Will only discard from unlocked cards`);
                    } else {
                        console.log(`      ‚ö†Ô∏è All cards are locked! Using full hand (emergency)`);
                    }
                }

                // üéØ PATCH LADDER-DISCARD: In ladder games, prioritize keeping sequential cards of same suit!
                const req = this.handReqs[this.currentHand].seqs;
                const needsLadders = req.some(s => s === 'ladder');
                
                // üéØ v4.2.7 FIX: Calculate minimum cards needed to publish
                const minCardsNeeded = req.reduce((sum, s) => sum + (s === 'triple' ? 3 : 4), 0);
                
                if (needsLadders && !this.publishedSequences[pIdx].length) {
                    // üéØ v4.2.7 CRITICAL FIX: Check if AI can ACTUALLY publish, not just card count!
                    // If hand size < minimum OR can't form valid sequences, skip PATCH LADDER-DISCARD
                    let canPublish = false;
                    if (hand.length >= minCardsNeeded) {
                        // Check if we have enough valid sequences
                        const seqs = this.findSequences(hand);
                        const needTriples = req.filter(s => s === 'triple').length;
                        const needLadders = req.filter(s => s === 'ladder').length;
                        const hasTriples = seqs.triples.length;
                        const hasLadders = seqs.ladders.length;
                        canPublish = (hasTriples >= needTriples && hasLadders >= needLadders);
                    }
                    
                    if (!canPublish) {
                        console.log(`%cüö® v4.2.7: Can't publish yet (need ${minCardsNeeded} cards, have ${hand.length}) - must keep buying! Skipping PATCH LADDER-DISCARD`, 'color: #ef4444; font-weight: bold;');
                        // Fall through to normal evaluation logic below
                    } else {
                        // Before publishing, focus on building ladders
                        console.log(`%cüéØ PATCH LADDER-DISCARD: Evaluating cards for ladder building`, 'color: #3498db;');
                        
                        // Group cards by suit and find sequential runs
                        const cardsBySuit = {};
                        hand.forEach(card => {
                            if (!cardsBySuit[card.suit]) cardsBySuit[card.suit] = [];
                            cardsBySuit[card.suit].push(card);
                        });
                        
                        // Score each card based on ladder potential
                        const cardScores = hand.map(card => {
                            const sameSuitCards = cardsBySuit[card.suit];
                            if (sameSuitCards.length < 2) {
                                // Isolated card - low score (good to discard)
                                return { card, score: 0, reason: 'isolated' };
                            }
                            
                            // Check if part of sequential run
                            const values = sameSuitCards.map(c => c.value).sort((a, b) => a - b);
                            let inRun = false;
                            let runLength = 0;
                            
                            for (let i = 0; i < values.length; i++) {
                                if (values[i] === card.value) {
                                    // Check neighbors
                                    let run = 1;
                                    // Check left
                                    for (let j = i - 1; j >= 0 && values[j] === values[j + 1] - 1; j--) run++;
                                    // Check right
                                    for (let j = i + 1; j < values.length && values[j] === values[j - 1] + 1; j++) run++;
                                    
                                    if (run >= 3) {
                                        inRun = true;
                                        runLength = run;
                                        break;
                                    }
                                }
                            }
                            
                            if (inRun) {
                                return { card, score: runLength * 10, reason: `in ${runLength}-run` };
                            } else if (sameSuitCards.length >= 3) {
                                return { card, score: sameSuitCards.length * 2, reason: `${sameSuitCards.length} same suit` };
                            } else {
                                return { card, score: 1, reason: 'pair only' };
                            }
                        });
                        
                        // Sort by score (lowest = worst = discard first)
                        cardScores.sort((a, b) => a.score - b.score);
                        
                        // üéØ v4.2.7 FIX: Add discard safety check - don't help opponents!
                        // Filter out cards that would extend opponent sequences when they're close to winning
                        const safeCardScores = cardScores.filter(scoreObj => {
                            for (let p = 0; p < this.players; p++) {
                                if (p === pIdx) continue; // Skip self
                                if (this.publishedSequences[p].length === 0) continue; // Skip unpublished opponents
                                
                                const opponentHandSize = this.playerHands[p].length;
                                if (opponentHandSize <= 4 && this.couldExtendSequence(scoreObj.card, p)) {
                                    console.log(`  üö´ v4.2.7: Can't discard ${scoreObj.card.toString()} - would help Player ${p} (${opponentHandSize} cards)`);
                                    return false; // Not safe - opponent is close to winning
                                }
                            }
                            return true; // Safe to discard
                        });
                        
                        // If we filtered out all cards, fall back to original list (edge case)
                        const finalScores = safeCardScores.length > 0 ? safeCardScores : cardScores;
                        
                        // Discard lowest scoring SAFE card (least useful for ladders, won't help opponents)
                        const worst = finalScores[0];
                        console.log(`%cüéØ PATCH LADDER-DISCARD: Discarding ${worst.card.toString()} (${worst.reason}, score: ${worst.score})`, 'color: #e67e22;');
                        return worst.card;
                    }
                }

                // üèÜ v4.0.7 FIX: ALWAYS protect cards that extend MY OWN sequences
                debugLog.decision(`üéØ v4.0.7: Checking if any cards extend MY sequences (ALWAYS)`);

                const myPublished = this.publishedSequences[pIdx];
                if (myPublished && myPublished.length > 0) {
                    // Find ALL cards that can extend my own sequences
                    const cardsExtendingOwn = hand.filter(card => 
                        myPublished.some(pubSeq => this.canAddToPublishedSequence(card, pubSeq))
                    );

                    if (cardsExtendingOwn.length > 0) {
                        debugLog.decision(`üèÜ v4.0.7 CRITICAL: Found ${cardsExtendingOwn.length} card(s) that extend MY sequences:`);
                        cardsExtendingOwn.forEach(c => debugLog.decision(`   - ${c.toString()} extends my sequence`));

                        // NEVER discard cards that extend my own sequences!
                        const nonExtendingCards = hand.filter(c => !cardsExtendingOwn.includes(c));

                        if (nonExtendingCards.length > 0) {
                            debugLog.decision(`üèÜ v4.0.7: Discarding from ${nonExtendingCards.length} non-extending cards`);
                            // Pick worst from cards that DON'T extend my sequences
                            hand = nonExtendingCards; // Override working hand for rest of logic
                        } else {
                            // ALL cards extend my sequences (rare case)
                            // This means tryAddToPublished should have played them already
                            // But if we're here, pick the least valuable extension
                            debugLog.decision(`‚ö†Ô∏è v4.0.7: ALL cards extend my sequences - picking least valuable`);
                        }
                    }

                    // üèÜ PATCH G: Check if AI can WIN by extending sequences (when close to winning)
                    if (hand.length <= 3) {
                        debugLog.decision(`PATCH G: Checking if AI can win this turn (${hand.length} cards)`);
                        
                        // Check if ANY card can extend my sequences and leave me with ‚â§1 cards
                        for (let card of hand) {
                            const canExtend = myPublished.some(pubSeq => this.canAddToPublishedSequence(card, pubSeq));

                            if (canExtend && hand.length === 2) {
                                // Playing this card wins the game!
                                debugLog.decision(`üèÜ CRITICAL: ${card.toString()} extends my sequence - WINNING MOVE! Keeping it!`);
                                // Return a DIFFERENT card (not the winning one)
                                const otherCards = hand.filter(c => c !== card);
                                if (otherCards.length > 0) {
                                    debugLog.decision(`üèÜ Discarding ${otherCards[0].toString()} instead to keep winning card`);
                                    return otherCards[0];
                                }
                            }
                        }
                    }
                }

                // üéØ PATCH K: Enhanced danger detection - protect before publishing too
                debugLog.info(`  ‚Üí PATCH K: Checking danger with published sequences (expanded)`);

                // üîß PATCH S: UNIVERSAL CHECK - Always filter out cards that extend ANY opponent's published sequences
                // üéØ v4.0.7 FIX: This should apply ESPECIALLY when all players published (racing!)
                const allPlayersPublished = this.publishedSequences.every(seq => seq.length > 0);
                const isRacing = allPlayersPublished && this.publishedSequences[pIdx].length > 0;
                
                if (isRacing) {
                    debugLog.info(`  üèÅ v4.0.7: RACING MODE - All players published! Defensive discard engaged.`);
                }
                
                debugLog.info(`  üîß v4.0.7: Universal discard safety - checking all opponents`);
                const universallySafeCards = hand.filter(c => {
                    for (let p = 0; p < this.players; p++) {
                        if (p === pIdx) continue; // Skip self

                        const opponentSequences = this.publishedSequences[p];
                        if (opponentSequences && opponentSequences.length > 0) {
                            // üéØ v4.0.7: DIRECT ACCESS - already stored as 2D array!
                            for (let seq of opponentSequences) {
                                if (this.canAddToPublishedSequence(c, seq)) {
                                    const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                    const opponentCards = this.playerHands[p].length;
                                    
                                    // üéØ CRITICAL: ALWAYS block if opponent has ‚â§3 cards (winning move!)
                                    if (opponentCards <= 3) {
                                        debugLog.info(`  üö´ CRITICAL: ${c.toString()} extends ${playerName}'s sequence (${opponentCards} cards) - WOULD LET THEM WIN!`);
                                        return false;
                                    }
                                    
                                    // üéØ v4.0.7: Be defensive in racing mode or if opponent close to winning
                                    if (isRacing || opponentCards <= 5) {
                                        debugLog.info(`  üö´ v4.0.7: ${c.toString()} extends ${playerName}'s sequence (${opponentCards} cards) - BLOCKING!`);
                                        return false; // Not safe - helps opponent
                                    }
                                }
                            }
                        }
                    }
                    return true; // Safe - doesn't extend any opponent's sequences
                });

                // Use filtered cards if we found any unsafe ones
                let workingHand = hand;
                if (universallySafeCards.length > 0 && universallySafeCards.length < hand.length) {
                    const blockedCount = hand.length - universallySafeCards.length;
                    debugLog.info(`  üõ°Ô∏è v4.0.7: Defensive filter removed ${blockedCount} dangerous cards`);
                    workingHand = universallySafeCards;
                } else if (universallySafeCards.length === 0) {
                    // üéØ v4.2.7 FIX: ALL cards are dangerous - pick LEAST dangerous!
                    debugLog.warn(`  ‚ö†Ô∏è v4.2.7: ALL ${hand.length} cards extend opponents - picking least dangerous`);
                    
                    // Build danger map: which opponents does each card help?
                    const dangerMap = hand.map(card => {
                        const helpsOpponents = [];
                        for (let p = 0; p < this.players; p++) {
                            if (p === pIdx) continue;
                            const opponentSequences = this.publishedSequences[p];
                            if (opponentSequences && opponentSequences.length > 0) {
                                for (let seq of opponentSequences) {
                                    if (this.canAddToPublishedSequence(card, seq)) {
                                        helpsOpponents.push({
                                            player: p,
                                            handSize: this.playerHands[p].length,
                                            name: p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot')
                                        });
                                        break; // Only count once per opponent
                                    }
                                }
                            }
                        }
                        return { card, helpsOpponents };
                    });
                    
                    // Sort by danger level (prefer helping opponents with MORE cards = farther from winning)
                    dangerMap.sort((a, b) => {
                        // If one card doesn't help anyone (shouldn't happen here, but safety check)
                        if (a.helpsOpponents.length === 0) return -1;
                        if (b.helpsOpponents.length === 0) return 1;
                        
                        // Get minimum opponent hand size that each card helps
                        const minOpponentA = Math.min(...a.helpsOpponents.map(o => o.handSize));
                        const minOpponentB = Math.min(...b.helpsOpponents.map(o => o.handSize));
                        
                        // Prefer card that helps opponent with MORE cards (farther from winning)
                        return minOpponentB - minOpponentA;
                    });
                    
                    // Pick least dangerous card
                    const leastDangerous = dangerMap[0];
                    debugLog.warn(`  üéØ v4.2.7: Least dangerous = ${leastDangerous.card.toString()}`);
                    leastDangerous.helpsOpponents.forEach(opp => {
                        debugLog.warn(`     Helps ${opp.name} (${opp.handSize} cards)`);
                    });
                    
                    // Return immediately - don't continue with other logic
                    return leastDangerous.card;
                }

                // THEN do critical/midgame specific checks
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue; // Skip self
                    const opponentCards = this.playerHands[p].length;
                    const opponentPublished = this.publishedSequences[p].length > 0;
                    const iHavePublished = this.publishedSequences[pIdx].length > 0;

                    // SCENARIO 1: Critical endgame (original logic)
                    const criticalEndgame = opponentPublished && opponentCards <= 2;

                    // SCENARIO 2: I haven't published yet, opponent is mid-game threat
                    const midGameThreat = !iHavePublished && opponentPublished && opponentCards <= 4;

                    if (criticalEndgame || midGameThreat) {

                        const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                        const scenario = criticalEndgame ? 'CRITICAL' : 'MID-GAME THREAT';
                        debugLog.decision(`PATCH K: ${scenario} - ${playerName} has ${opponentCards} card(s)${opponentPublished ? ' and published' : ''}!`);

                        // üéØ PATCH O: Enhanced safety check with turn order priority

                        const safeCards = workingHand.filter(c => {

                            // üîß PATCH R (v4.0.7): Check if card extends opponent's published sequences
                            const opponentPublished = this.publishedSequences[p];
                            if (opponentPublished && opponentPublished.length > 0) {
                                // üéØ v4.0.7: opponentPublished is already 2D [[seq1], [seq2], ...]
                                for (let seq of opponentPublished) {
                                    // seq is already an array of cards
                                    if (this.canAddToPublishedSequence(c, seq)) {
                                        const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                        debugLog.info(`  ‚Üí PATCH R: ${c.toString()} can extend ${playerName}'s published sequence - NOT SAFE`);
                                        return false; // Not safe - helps opponent extend published sequences
                                    }
                                }
                            }
                            
                            // Check if extends opponent's hand
                            if (this.couldExtendSequence(c, p)) return false;

                            // Check published sequences with turn order awareness
                            // After pIdx discards, who gets buy window? Next player!
                            const nextPlayer = (pIdx + 1) % this.players;

                            // CRITICAL: Check if helps players who come BEFORE current player in buy window order
                            // Buy window order after pIdx discards: nextPlayer, then nextPlayer+1, etc.
                            for (let offset = 0; offset < this.players - 1; offset++) {
                                const buyWindowPlayer = (pIdx + 1 + offset) % this.players;
                                const published = this.publishedSequences[buyWindowPlayer];

                                if (published && published.length > 0) {
                                    for (let pubSeq of published) {
                                        if (this.canAddToPublishedSequence(c, pubSeq)) {
                                            const playerName = buyWindowPlayer === 0 ? 'Human' : (buyWindowPlayer === 1 ? 'Habot' : 'Jabot');
                                            const priority = offset === 0 ? 'FIRST' : 'SECOND';
                                            debugLog.info(`  ‚Üí PATCH O: ${c.toString()} helps ${playerName} (${priority} in buy window) - NOT SAFE`);
                                            return false; // Not safe - helps player with buy window priority
                                        }
                                    }
                                }
                            }
                            return true; // Safe - doesn't help anyone in buy window order
                        });

                        if (safeCards.length > 0) {
                            // Discard highest penalty from safe cards
                            const worst = safeCards.reduce((max, c) =>
                                c.getPenaltyValue() > max.getPenaltyValue() ? c : max
                            );
                            debugLog.decision(`PATCH K: Safe discard: ${worst.toString()} (doesn't help ${playerName})`);
                            return worst;
                        } else {
                            debugLog.warn(`  ‚Üí PATCH K: WARNING - ALL cards help ${playerName}! Using least valuable...`);
                            // If all cards help, pick the least strategically valuable
                            let minValue = this.evaluateCard(hand[0], pIdx);
                            let worst = hand[0];
                            hand.forEach(c => {
                                const val = this.evaluateCard(c, pIdx);
                                if (val < minValue) {
                                    minValue = val;
                                    worst = c;
                                }
                            });
                            return worst;
                        }
                    }
                }

                const isLadderOnlyHand = this.handReqs[this.currentHand].seqs.every(seq => seq === 'ladder');
                if (isLadderOnlyHand && this.turnCounter > 80 && hand.length >= 15) {
                    const potentialLadders = {};
                    hand.forEach(card => { if (!potentialLadders[card.suit]) potentialLadders[card.suit] = []; potentialLadders[card.suit].push(card.getValue()) });
                    const keepCards = new Set();
                    Object.entries(potentialLadders).forEach(([suit, values]) => {
                        const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
                        for (let i = 0; i < uniqueValues.length; i++) {
                            let runLength = 1;
                            let currentValue = uniqueValues[i];
                            while (i + runLength < uniqueValues.length && uniqueValues[i + runLength] === currentValue + runLength) runLength++;
                            if (runLength >= 3) {
                                for (let k = 0; k < runLength; k++) {
                                    const cardValue = currentValue + k;
                                    const cardsWithValue = hand.filter(c => c.suit === suit && c.getValue() === cardValue);
                                    cardsWithValue.forEach(c => keepCards.add(c.id));
                                }
                            }
                        }
                    });
                    const dumpCandidates = hand.filter(c => !keepCards.has(c.id));
                    if (dumpCandidates.length > 0) {
                        const worst = dumpCandidates.reduce((max, c) => c.getPenaltyValue() > max.getPenaltyValue() ? c : max);
                        return worst;
                    }
                }
                const hasPublished = this.publishedSequences[pIdx].length > 0;
                if (!hasPublished) {
                    const othersPublished = this.publishedSequences.some((seq, idx) => idx !== pIdx && seq.length > 0);
                    const othersLowCards = this.playerHands.some((h, idx) => idx !== pIdx && h.length <= 2);
                    if (othersPublished && othersLowCards) {
                        if (this.turnCounter > 120) {
                            const highestPenalty = hand.reduce((max, card) => card.getPenaltyValue() > max.getPenaltyValue() ? card : max);
                            return highestPenalty;
                        }
                        const seqs = this.findSequences(hand);
                        const inSequences = new Set();
                        seqs.triples.forEach(t => t.forEach(c => inSequences.add(c.id)));
                        seqs.ladders.forEach(l => l.forEach(c => inSequences.add(c.id)));
                        const safeToDump = hand.filter(c => {
                            if (inSequences.has(c.id)) return false;
                            for (let p = 0; p < this.players; p++) {
                                if (p === pIdx) continue;
                                if (this.playerHands[p].length <= 2 && this.couldExtendSequence(c, p)) return false;
                            }
                            return true;
                        });
                        if (safeToDump.length > 0) {
                            const highPenalty = safeToDump.sort((a, b) => b.getPenaltyValue() - a.getPenaltyValue())[0];
                            return highPenalty;
                        }
                        const pairs = {};
                        hand.forEach(c => { pairs[c.rank] = (pairs[c.rank] || []); pairs[c.rank].push(c) });
                        const pairCards = [];
                        Object.entries(pairs).forEach(([rank, cards]) => { if (cards.length === 2) pairCards.push(...cards) });
                        if (pairCards.length > 0) {
                            const worst = pairCards.reduce((min, c) => c.getValue() < min.getValue() ? c : min);
                            return worst;
                        }
                        const notInSeq = hand.filter(c => !inSequences.has(c.id));
                        if (notInSeq.length > 0) {
                            const lowest = notInSeq.reduce((min, c) => c.getPenaltyValue() < min.getPenaltyValue() ? c : min);
                            return lowest;
                        }
                    }
                }
                const rankCounts = {};
                hand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { hand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[pIdx].length > 0) {
                    hand.forEach(c => { if (this.couldExtendSequence(c, pIdx)) protectedCards.add(c.id) });
                }
                const criticalDanger = new Set();
                const moderateDanger = new Set();
                for (let p = 0; p < this.players; p++) {
                    if (p === pIdx) continue;
                    if (this.publishedSequences[p].length === 0) continue;
                    const opponentCards = this.playerHands[p].length;
                    hand.forEach(c => {
                        if (this.couldExtendSequence(c, p)) {
                            if (opponentCards <= 2) { criticalDanger.add(c.id); protectedCards.add(c.id) }
                            else if (opponentCards <= 4) { moderateDanger.add(c.id); protectedCards.add(c.id) }
                        }
                    });
                }
                const safeCards = hand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worst = safeCards[0];
                    let minVal = this.evaluateCard(worst, pIdx);
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; worst = c }
                    });
                    return worst;
                }
                const nonCriticalCards = hand.filter(c => !criticalDanger.has(c.id));
                if (nonCriticalCards.length > 0) {
                    const cardsNotExtendingOwn = [];
                    const cardsExtendingOwn = [];
                    nonCriticalCards.forEach(c => {
                        if (this.couldExtendSequence(c, pIdx)) cardsExtendingOwn.push(c);
                        else cardsNotExtendingOwn.push(c);
                    });
                    if (cardsNotExtendingOwn.length > 0) {
                        let worst = cardsNotExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsNotExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                    if (cardsExtendingOwn.length > 0) {
                        let worst = cardsExtendingOwn[0];
                        let minVal = this.evaluateCard(worst, pIdx);
                        cardsExtendingOwn.forEach(c => {
                            const val = this.evaluateCard(c, pIdx);
                            if (val < minVal) { minVal = val; worst = c }
                        });
                        return worst;
                    }
                }
                let leastUrgent = hand[0];
                let maxOpponentCards = 0;
                hand.forEach(c => {
                    for (let p = 0; p < this.players; p++) {
                        if (p === pIdx) continue;
                        if (this.couldExtendSequence(c, p)) {
                            const opponentCards = this.playerHands[p].length;
                            if (opponentCards > maxOpponentCards) { maxOpponentCards = opponentCards; leastUrgent = c }
                        }
                    }
                });
                if (maxOpponentCards === 0) {
                    let minVal = this.evaluateCard(leastUrgent, pIdx);
                    hand.forEach(c => {
                        const val = this.evaluateCard(c, pIdx);
                        if (val < minVal) { minVal = val; leastUrgent = c }
                    });
                }
                return leastUrgent;
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // END OF AI DECISION ENGINE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            shouldAllowBuy(ai, discardCard) {
                const buysRemaining = this.playerBuys[ai];
                if (buysRemaining === 0) return false;
                const hand = this.playerHands[ai];
                const buysUsed = (this.currentHand === 7 ? 2 : 3) - buysRemaining;
                const seqs = this.findSequences(hand);
                const hasTriple = seqs.triples.length > 0;
                const hasLadder = seqs.ladders.length > 0;
                const strategicValue = this.evaluateCard(discardCard, ai);
                const penaltyValue = discardCard.getPenaltyValue();
                const cardValue = strategicValue + penaltyValue;
                switch (this.currentHand) {
                    case 1: if (buysUsed >= 2) return false; if (!hasTriple && cardValue < 30) return false; return hasTriple || cardValue >= 30;
                    case 2: if (buysUsed >= 2) return false; const hasSequence = hasTriple || hasLadder; return hasSequence && cardValue >= 25;
                    case 3:
                        if (buysUsed < 2) return cardValue >= 35;
                        if (buysUsed === 2) { const has3CardProgress = this.hasThreeCardLadderProgress(hand); return has3CardProgress && cardValue >= 30 }
                        return false;
                    case 4: if (buysUsed >= 2) return false; return hasTriple && cardValue >= 25;
                    case 5: if (buysUsed >= 2) return false; const hasAnySequence = hasTriple || hasLadder; return hasAnySequence && cardValue >= 30;
                    case 6:
                    case 7:
                        // üèóÔ∏è v4.5.3: STAGED CONSTRUCTION STRATEGY
                        // Build sequences SEQUENTIALLY: L1 ‚Üí L2 ‚Üí T (not parallel!)
                        
                        const stage = this.aiConstructionStage[ai];
                        const aiName = ai === 1 ? 'Habot' : 'Jabot';
                        
                        console.log(`  üèóÔ∏è v4.5.3 ${aiName} BUY CHECK - Stage: ${stage}, Buys used: ${buysUsed}/2-3`);
                        
                        // Stage 1 & 2: Building Ladders - TARGET-BASED BUYING
                        if (stage === 'building_L1' || stage === 'building_L2') {
                            // Update targets if needed
                            if (this.aiTargetCards[ai].length === 0 || this.aiSuitFocus[ai].length === 0) {
                                this.updateStagedConstructionTargets(ai);
                            }
                            
                            const targets = this.aiTargetCards[ai];
                            const cardString = `${discardCard.rank}${discardCard.suit}`;
                            
                            // Is this one of our target cards?
                            const isTarget = targets.includes(cardString);
                            
                            console.log(`      Targets: ${targets.join(', ')}`);
                            console.log(`      Card: ${cardString} - Is target? ${isTarget}`);
                            
                            if (isTarget) {
                                console.log(`      ‚úÖ BUY! This is a target card for ${stage}`);
                                return true; // BUY immediately if it's a target!
                            }
                            
                            // üíö v4.5.3: AGGRESSIVE BUY MODE - Lower standards when stuck with scattered cards
                            const aggressiveMode = this.isAggressiveBuyMode(ai);
                            
                            if (aggressiveMode) {
                                // In aggressive mode: Accept ANY card in focus suits!
                                const focusSuits = this.aiSuitFocus[ai];
                                const inFocusSuit = focusSuits.includes(discardCard.suit);
                                
                                if (inFocusSuit && cardValue >= 15) {
                                    console.log(`      üíö AGGRESSIVE BUY! In focus suit ${discardCard.suit}, accumulating cards`);
                                    return true;
                                }
                                
                                // Also more lenient on high-value cards
                                if (cardValue >= 25) {
                                    console.log(`      üíö AGGRESSIVE BUY! High-value card, trying anything`);
                                    return true;
                                }
                            }
                            
                            // Not a target - check if it's still valuable for ladder building
                            if (buysUsed === 0 && cardValue >= 20) {
                                // First buy - be more flexible to get more cards
                                const sameSuit = hand.filter(c => c.suit === discardCard.suit);
                                if (sameSuit.length >= 2) {
                                    console.log(`      ‚úÖ First buy - accept valuable card in promising suit`);
                                    return true;
                                }
                            }
                            
                            console.log(`      ‚ùå REJECT - not a target, not valuable enough`);
                            return false;
                        }
                        
                        // Stage 3: Building Triple - EASIER, just need matching ranks
                        if (stage === 'building_T') {
                            const completesTriple = hand.filter(c => c.rank === discardCard.rank).length >= 2;
                            
                            console.log(`      Checking triple: have ${hand.filter(c => c.rank === discardCard.rank).length} ${discardCard.rank}s`);
                            console.log(`      Would complete triple? ${completesTriple}`);
                            
                            if (completesTriple && cardValue >= 10) {
                                console.log(`      ‚úÖ BUY! Completes triple for publishing`);
                                return true;
                            }
                            
                            // Also accept cards that start triples if we have buys left
                            const pairCount = hand.filter(c => c.rank === discardCard.rank).length;
                            if (pairCount === 1 && buysUsed < 1 && cardValue >= 15) {
                                console.log(`      ‚úÖ BUY! Forms pair toward triple`);
                                return true;
                            }
                            
                            console.log(`      ‚ùå REJECT - doesn't help triple`);
                            return false;
                        }
                        
                        // Ready to publish or unknown stage - don't buy
                        console.log(`      ‚ùå Stage ${stage} - no buying`);
                        return false;
                    default: return false;
                }
            }

            shouldRequestBuy(ai) {
                if (this.playerBuys[ai] === 0) return false;
                if (this.publishedSequences[ai].length > 0) return false;
                const humanPublished = this.publishedSequences[0].length > 0;
                if (humanPublished) return false;
                const othersPublishedWith3Plus = this.publishedSequences.some((seq, idx) => {
                    if (idx === ai) return false;
                    return seq.length > 0 && this.playerHands[idx].length >= 3;
                });
                if (othersPublishedWith3Plus && this.playerHands[ai].length >= 3) return true;
                return false;
            }

            setAIStatus(aiId, message) { const actionElement = document.getElementById(`${aiId}-action`); if (actionElement) actionElement.textContent = message }

            // ‚úÖ FIX 3: Reduced buy window after publishing (5s instead of 10s)
            startBuyWindow(card, discardingPlayer) {
                if (!card) { console.log(`%c‚ö†Ô∏è Cannot open buy window - no card provided`, 'color: #ff6600; font-weight: bold;'); return }
                const buyWindowPlayer = (discardingPlayer + 2) % 3;
                
                // üéØ CRITICAL: Don't open buy window if player has no buys left!
                if (this.playerBuys[buyWindowPlayer] <= 0) {
                    const playerNames = ['Human', 'Habot', 'Jabot'];
                    console.log(`%c‚è≠Ô∏è SKIP: ${playerNames[buyWindowPlayer]} has no buys left (${this.playerBuys[buyWindowPlayer]}) - no buy window`, 'color: #9e9e9e; font-weight: bold;');
                    
                    // üêõ v4.0.7 FIX: Advance to next player when skipping buy window!
                    const nextPlayer = (this.currentPlayer + 1) % this.players;
                    console.log(`%c‚ñ∂Ô∏è Advancing to next player: Player ${nextPlayer}`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        this.currentPlayer = nextPlayer;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) {
                            this.aiTurn();
                        }
                    }, 500);
                    return;
                }
                
                if (this.buyWindow.active) this.closeBuyWindow();

                // üéØ v4.0.7: Longer buy window for humans (8s), shorter for AI (3s)
                const duration = buyWindowPlayer === 0 ? 8000 : 3000;
                console.log(`%c‚è±Ô∏è v4.0.7: Buy window duration: ${duration / 1000}s (${buyWindowPlayer === 0 ? 'Human' : 'AI'})`, 'color: #ffc107; font-weight: bold;');

                this.buyWindow.active = true;
                this.buyWindow.card = card;
                this.buyWindow.discardingPlayer = discardingPlayer;
                this.buyWindow.buyWindowPlayer = buyWindowPlayer;
                this.buyWindow.expiresAt = Date.now() + duration; // ‚úÖ FIX 3: Variable duration

                const playerNames = ['Human', 'Habot', 'Jabot'];
                console.log(`%cüîî Buy window opened for ${playerNames[buyWindowPlayer]} (${card.toString()}) - ${duration / 1000}s`, 'color: #ffc107; font-weight: bold;');
                if (buyWindowPlayer === 0) document.getElementById('buyBtn').disabled = false;
                this.updateBuyTimer();
            }


            checkAndOpenBuyWindowAfterDiscard(currentAI, statusId) {
                const aiName = currentAI === 1 ? 'Habot' : 'Jabot';

                // Check if we have a valid lastDiscard to create buy window for
                if (!this.lastDiscard || this.lastDiscardByPlayer === -1) {
                    console.log(`%c  ‚è≠Ô∏è  No buy window: no valid lastDiscard`, 'color: #95a5a6;');
                    return false; // No buy window opened
                }

                const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                console.log(`%c  üí° Buy window check after ${aiName} discard`, 'color: #9b59b6; font-weight: bold;');
                console.log(`     lastDiscard: ${this.lastDiscard.toString()}`);
                console.log(`     lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);
                console.log(`     buyWindowPlayer: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                // Validate buy window conditions
                if (buyWindowPlayer === currentAI || buyWindowPlayer === this.lastDiscardByPlayer) {
                    console.log(`     ‚ùå Buy window blocked: invalid player configuration`);
                    return false;
                }

                console.log(`     ‚úÖ Opening buy window!`);

                // Save next player info for after buy window closes
                const nextPlayer = (this.currentPlayer + 1) % this.players;
                this.buyWindow.pendingNextPlayer = nextPlayer;

                // Open the buy window
                this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);

                // Handle AI buy window if needed
                if (buyWindowPlayer > 0) {
                    this.handleAIBuyWindow(buyWindowPlayer);
                }

                // Clean up status after a delay
                if (statusId) {
                    setTimeout(() => { document.getElementById(`${statusId}-status`).classList.remove('active') }, 800);  // üéØ v2.5.0: Faster (was 2000ms)
                }

                return true; // Buy window was opened
            }

            closeBuyWindow(reason = 'expired') {
                if (!this.buyWindow.active) return;

                const wasActive = this.buyWindow.active;
                const pendingDraw = this.buyWindow.pendingDeckDraw;
                const pendingNextPlayer = this.buyWindow.pendingNextPlayer; // ‚úÖ NEW

                // Clear buy window state
                this.buyWindow.active = false;
                this.buyWindow.card = null;
                this.buyWindow.discardingPlayer = -1;
                this.buyWindow.buyWindowPlayer = -1;
                this.buyWindow.pendingDeckDraw = null;
                this.buyWindow.pendingNextPlayer = null; // ‚úÖ NEW

                if (this.buyWindow.timerInterval) {
                    clearTimeout(this.buyWindow.timerInterval);
                    this.buyWindow.timerInterval = null;
                }

                document.getElementById('buyBtn').disabled = true;
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) timerEl.style.display = 'none';

                // Log the closure reason
                if (reason === 'taken') {
                    showToast('Buy Denied - Card was taken', 'warning', 2000);
                } else if (reason === 'expired') {
                    console.log('%c‚è±Ô∏è Buy window expired', 'color: #94a3b8;');
                } else if (reason === 'player-turn') {
                    console.log('%cüéÆ Buy window closed - your turn', 'color: #4a90e2;');
                } else if (reason === 'player-took') {
                    console.log('%c‚úÖ Buy window closed - you took the card', 'color: #28a745;');
                } else if (reason === 'bought') {
                    console.log('%cüí∞ Human bought card', 'color: #ffc107;');
                } else if (reason === 'ai-bought') {
                    console.log('%cüí∞ AI bought card', 'color: #ffc107;');
                } else if (reason === 'no-buy-after-publish') {
                    console.log('%cüö´ Buy window closed - AI already published in triple-only hand', 'color: #ff9800;');
                } else if (reason === 'no-buys') {
                    console.log('%cüö´ Buy window closed - AI has no buys left', 'color: #9e9e9e;');
                } else if (reason === 'ai-no-buyback') {
                    console.log('%cüö´ Buy window closed - AI cannot buy back own discard', 'color: #ff6b35;');
                }

                // Handle pendingDeckDraw (buy window opened during deck draw)
                // Resume if buy window closed without anyone buying
                const noBuyReasons = ['expired', 'no-buy-after-publish', 'no-buys', 'ai-no-buyback', 'invalid'];
                if (pendingDraw && noBuyReasons.includes(reason)) {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%c‚ñ∂Ô∏è Resuming ${aiName}'s turn after buy window (${reason})`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before drawing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`‚úÖ PATCH 1: ${aiName} auto-published sequences after buy window!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                } else if (pendingDraw && reason === 'bought') {
                    // Human bought - resume AI turn
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%c‚ñ∂Ô∏è Resuming ${aiName}'s turn after buy window`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before drawing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`‚úÖ PATCH 1: ${aiName} auto-published sequences after buy window!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                } else if (pendingDraw && reason === 'ai-bought') {
                    const { ai, statusId } = pendingDraw;
                    const aiName = ai === 1 ? 'Habot' : 'Jabot';

                    console.log(`%c‚ñ∂Ô∏è Resuming ${aiName}'s turn (AI bought, skipping duplicate draw)`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        // PATCH 1: Try auto-publish before continuing
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`‚úÖ PATCH 1: ${aiName} auto-published after AI bought!`);
                        }
                        this.drawDeckCardForAI(ai, statusId);
                        this.continueAITurnAfterDraw(ai, statusId);
                    }, 500);

                }
                // ‚úÖ NEW: Handle pendingNextPlayer (buy window opened after AI discarded from discard pile)
                else if (pendingNextPlayer !== null && pendingNextPlayer !== undefined) {
                    console.log(`%c‚ñ∂Ô∏è Advancing to next player after buy window: Player ${pendingNextPlayer}`, 'color: #4a90e2; font-weight: bold;');
                    setTimeout(() => {
                        this.currentPlayer = pendingNextPlayer;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) {
                            this.aiTurn();
                        }
                    }, 500);

                }
            }

            updateBuyTimer() {
                if (!this.buyWindow.active) return;
                const remaining = Math.ceil((this.buyWindow.expiresAt - Date.now()) / 1000);
                if (remaining <= 0) { this.closeBuyWindow('expired'); return }
                const timerEl = document.getElementById('buyTimer');
                if (timerEl) {
                    timerEl.textContent = ` (${remaining}s)`;
                    timerEl.style.display = 'inline';
                    timerEl.style.color = remaining <= 2 ? '#ff6b35' : '#ffd700';
                }
                this.buyWindow.timerInterval = setTimeout(() => this.updateBuyTimer(), 100);
            }

            handleAIBuyWindow(aiPlayer) {
                const aiName = aiPlayer === 1 ? 'Habot' : 'Jabot';
                const card = this.buyWindow.card;

                // ‚úÖ FIX 9: If buy window is for HUMAN, don't let AI handle it!
                if (this.buyWindow.buyWindowPlayer === 0) {
                    console.log(`%cüö´ FIX 9: Buy window is for HUMAN - AI should not interfere!`, 'color: #ff6b35; font-weight: bold;');
                    return;
                }

                // üéØ CRITICAL FIX: Don't let AI buy back the card they just discarded!
                if (this.buyWindow.discardingPlayer === aiPlayer) {
                    console.log(`%cüö´ CRITICAL: ${aiName} just discarded this card - blocking stupid buyback!`, 'color: #ff6b35; font-weight: bold;');
                    this.closeBuyWindow('ai-no-buyback');
                    return;
                }

                // üéØ SAFETY CHECK: If AI has no buys left, don't process buy window
                if (this.playerBuys[aiPlayer] <= 0) {
                    console.log(`%c‚è≠Ô∏è SKIP: ${aiName} has no buys left (${this.playerBuys[aiPlayer]}) - closing buy window`, 'color: #9e9e9e; font-weight: bold;');
                    this.closeBuyWindow('no-buys');
                    return;
                }

                // üéØ PATCH I v4.1.4: Block buying after publishing in triple-only games (buy window version)
                if (this.publishedSequences[aiPlayer].length > 0) {
                    const req = this.handReqs[this.currentHand].seqs;
                    const needLadders = req.filter(s => s === 'ladder').length;

                    if (needLadders === 0) {
                        // Triple-only game and AI has published - NO MORE BUYING
                        console.log(`%c  üõë PATCH I v4.1.4: ${aiName} blocking buy window - Triple-only hand, already published`, 'color: #ff9800; font-weight: bold;');
                        this.closeBuyWindow('no-buy-after-publish');
                        return;
                    }
                }

                if (!card) {
                    console.log(`%c‚ö†Ô∏è ${aiName} buy window has no card - closing`, 'color: #ff6600; font-weight: bold;');
                    this.closeBuyWindow('invalid');
                    if (this.buyWindow.pendingDeckDraw) {
                        const { ai, statusId } = this.buyWindow.pendingDeckDraw;
                        setTimeout(() => { this.drawDeckCardForAI(ai, statusId); this.continueAITurnAfterDraw(ai, statusId) }, 100);
                    }
                    return;
                }

                const statusId = aiPlayer === 1 ? 'habot' : 'jabot';
                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, `Considering buy...`);
                setTimeout(() => {
                    const shouldBuy = this.shouldAllowBuy(aiPlayer, card);
                    if (shouldBuy && this.playerBuys[aiPlayer] > 0) {
                        const idx = this.discardPile.findIndex(c => c.id === card.id);
                        if (idx > -1) {
                            this.discardPile.splice(idx, 1);
                            this.playerHands[aiPlayer].push(card);
                            this.discardPileAccessible = false; // üîí v4.1.3: Lock vault after buy
                            if (this.lastDiscard && this.lastDiscard.rank === card.rank && this.lastDiscard.suit === card.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (this.deck.length === 0) this.reshuffleDeck();
                            if (this.deck.length > 0) {
                                const penalty = this.deck.pop();
                                this.playerHands[aiPlayer].push(penalty);
                            }
                            this.playerBuys[aiPlayer]--;
                            showBuyToast(aiName, card);
                            this.updateUI();
                        }
                    }
                    document.getElementById(`${statusId}-status`).classList.remove('active');
                    this.closeBuyWindow('ai-bought');
                }, 2500);
            }

            wouldDiscardImmediately(card, ai) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                const tempHand = [...this.playerHands[ai], card];
                const rankCounts = {};
                tempHand.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                const protectedCards = new Set();
                Object.entries(rankCounts).forEach(([rank, count]) => {
                    if (count >= 2) { tempHand.forEach(c => { if (c.rank === rank) protectedCards.add(c.id) }) }
                });
                if (this.publishedSequences[ai].length > 0) {
                    if (this.couldExtendSequence(card, ai)) protectedCards.add(card.id);
                }
                const safeCards = tempHand.filter(c => !protectedCards.has(c.id));
                if (safeCards.length > 0) {
                    let worstValue = 9999;
                    let worstCard = null;
                    safeCards.forEach(c => {
                        const val = this.evaluateCard(c, ai);
                        if (val < worstValue) { worstValue = val; worstCard = c }
                    });
                    const cardValue = this.evaluateCard(card, ai);
                    const wouldDiscard = worstCard && worstCard.rank === card.rank && worstCard.suit === card.suit;
                    console.log(`%c  üîç v4.2.7: wouldDiscardImmediately(${card.toString()}) for ${aiName}`, 'color: #8b5cf6;');
                    console.log(`     Card value: ${cardValue}, Worst card: ${worstCard ? worstCard.toString() : 'none'} (value: ${worstValue})`);
                    console.log(`     Result: ${wouldDiscard ? 'YES - would discard' : 'NO - would keep'}`);
                    if (wouldDiscard && worstCard.rank === card.rank && worstCard.suit === card.suit) return true;
                }
                return false;
            }

            aiTurn() {
                const ai = this.currentPlayer;
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                const statusId = ai === 1 ? 'habot' : 'jabot';

                console.log(`%cü§ñ ${aiName} starting turn`, 'color: #3498db; font-weight: bold;');

                // üéØ v4.0.7 FIX: Reset publish flag at START of turn (not end of previous turn!)
                // This ensures AI cannot extend on the SAME turn as publishing
                // Flag is set when AI publishes, and cleared on NEXT turn start
                this.aiJustPublished[ai] = false;

                document.getElementById(`${statusId}-status`).classList.add('active');
                this.setAIStatus(statusId, 'Taking turn...');

                // üéØ v2.5.0: Dynamic AI speed based on decision complexity
                const handSize = this.playerHands[ai].length;
                const hasPublished = this.publishedSequences[ai].length > 0;

                let delay = 0;
                if (!this.aiInstant) {
                    // Critical decisions = slower for realism
                    if (handSize <= 3 || (!hasPublished && this.canPublish(ai))) {
                        delay = 1000;  // Important moment - 1 second
                    }
                    // Routine play = faster
                    else {
                        delay = 500;  // Quick routine turn - 0.5 seconds
                    }
                }
                console.log(`%c  ‚è±Ô∏è  AI delay: ${delay}ms (${handSize} cards, ${hasPublished ? 'published' : 'not published'})`, 'color: #9e9e9e;');

                setTimeout(() => {
                    this.turnCounter++;
                    console.log(`%c  Turn ${this.turnCounter}`, 'color: #3498db;');

                    // PATCH 2: Check hand size - block buying if 13+ cards
                    const currentHandSize = this.playerHands[ai].length;
                    if (currentHandSize >= 13) {
                        console.log(`%c‚õî PATCH 2: ${aiName} has ${currentHandSize} cards - must reduce hand`, 'color: #e74c3c; font-weight: bold;');
                        // Force draw from deck instead of evaluating discard
                        console.log(`%c  ${aiName} drawing from deck (hand too large)...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    // PATCH 3: Try to auto-publish at turn start if hand is large
                    if (currentHandSize >= 12 && this.publishedSequences[ai].length === 0) {
                        console.log(`%cüö® PATCH 3: ${aiName} has ${currentHandSize} cards and hasn't published - forcing publish check`, 'color: #e74c3c; font-weight: bold;');
                        const published = this.autoPublish(ai);
                        if (published) {
                            console.log(`%c‚úÖ PATCH 3: ${aiName} emergency published!`, 'color: #27ae60; font-weight: bold;');
                            this.aiJustPublished[ai] = true; // üêõ v4.1.5: Set flag to block extensions this turn
                            // Update hand size after publishing
                            const newHandSize = this.playerHands[ai].length;
                            console.log(`%c   Hand size reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                        }
                    }

                    let discardCard = null;
                    let discardScore = 0;
                    if (this.discardPile.length > 0) {
                        discardCard = this.discardPile[this.discardPile.length - 1];
                        discardScore = this.evaluateCard(discardCard, ai);
                        if (this.lastAIDiscard[ai] && this.lastAIDiscard[ai].rank === discardCard.rank && this.lastAIDiscard[ai].suit === discardCard.suit) {
                            discardScore = -999;
                        }
                    }

                    //Nash: Changed threshold from 15 to 11 to 5 - AI MUST take cards to form sequences!
                    let threshold = 5;
                    if (this.publishedSequences[ai].length === 0) {
                        const seqs = this.findSequences(this.playerHands[ai]);
                        const req = this.handReqs[this.currentHand].seqs;
                        const needTriples = req.filter(s => s === 'triple').length;
                        const needLadders = req.filter(s => s === 'ladder').length;
                        const hasTriples = seqs.triples.length;
                        const hasLadders = seqs.ladders.length;
                        if (hasTriples >= needTriples - 1 || hasLadders >= needLadders - 1) threshold = 4;
                    }
                    const personality = this.getAIPersonality(ai);
                    if (personality === 'rabbit') threshold -= 2;
                    else if (personality === 'tortoise') threshold += 2;
                    const forceBuy = discardCard && this.shouldAllowBuy(ai, discardCard);
                    let shouldTake = forceBuy || (discardCard && discardScore >= threshold);

                    // üéØ PATCH M: In triple games, only buy if completes/extends a triple
                    // üéØ v4.0.7 FIX: Check BOTH hand AND published sequences!
                    // üéØ v4.0.7 FIX: Check ALL published sequences (global resources), not just AI's own!
                    if (shouldTake && this.discardPile.length > 0) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const hasOnlyTriples = req.every(s => s === 'triple');

                        if (hasOnlyTriples && !forceBuy) {
                            const topCard = this.discardPile[this.discardPile.length - 1];
                            const matchingInHand = this.playerHands[ai].filter(c => c.rank === topCard.rank).length;
                            
                            // üéØ v4.0.7: Check ALL published sequences (anyone's!)
                            let matchingInAnyPublished = 0;
                            for (let p = 0; p < this.players; p++) {
                                const matching = this.getFlatPublished(p).filter(c => c.rank === topCard.rank).length;
                                if (matching > 0) {
                                    matchingInAnyPublished = matching;
                                    break; // Found one - that's enough! No need to check more
                                }
                            }
                            
                            const totalMatching = matchingInHand + matchingInAnyPublished;

                            if (totalMatching < 2) {
                                // Need at least 2 existing (hand OR any published) + 1 buy = 3 minimum
                                console.log(`  ‚Üí PATCH M: Blocking buy - ${topCard.toString()} won't complete triple (${matchingInHand} in hand, ${matchingInAnyPublished} in any published = ${totalMatching} total)`);
                                shouldTake = false;
                            } else {
                                console.log(`  ‚Üí PATCH M: Allowing buy - ${topCard.toString()} extends/completes triple! (${matchingInHand} in hand + ${matchingInAnyPublished} in published + 1 buy = extends global sequence)`);
                            }
                        }
                    }

                    // üéØ PATCH LADDER: In ladder games, force take cards that extend ANY published ladder!
                    if (!shouldTake && this.discardPile.length > 0) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const hasLadders = req.some(s => s === 'ladder');
                        
                        if (hasLadders) {
                            const topCard = this.discardPile[this.discardPile.length - 1];
                            
                            // Check if this card extends ANY published ladder (from any player)
                            for (let p = 0; p < this.players; p++) {
                                const flatPublished = this.getFlatPublished(p);
                                if (flatPublished.length === 0) continue;
                                
                                // Group published cards by suit to find ladders
                                const cardsBySuit = {};
                                flatPublished.forEach(card => {
                                    if (!cardsBySuit[card.suit]) cardsBySuit[card.suit] = [];
                                    cardsBySuit[card.suit].push(card.value);
                                });
                                
                                // Check each suit's ladder
                                for (const [suit, values] of Object.entries(cardsBySuit)) {
                                    if (values.length >= 4 && suit === topCard.suit) {
                                        // This is a ladder in the same suit!
                                        values.sort((a, b) => a - b);
                                        const lowValue = values[0];
                                        const highValue = values[values.length - 1];
                                        
                                        // Check if topCard extends this ladder
                                        if (topCard.value === lowValue - 1 || topCard.value === highValue + 1) {
                                            console.log(`%c  üéØ PATCH LADDER: ${topCard.toString()} extends published ladder! FORCE TAKE!`, 'color: #27ae60; font-weight: bold;');
                                            shouldTake = true;
                                            break;
                                        }
                                    }
                                }
                                if (shouldTake) break;
                            }
                        }
                    }

                    // üéØ PATCH H: Block buying in endgame
                    const aiHandSize = this.playerHands[ai].length;  // ‚Üê Changed name
                    const anyPlayerNearWin = this.playerHands.some((h, idx) => h.length <= 3 && this.publishedSequences[idx].length > 0);

                    // üéØ v4.2.7 FIX: Don't block if card extends ANY published sequence!
                    // Published sequences are GLOBAL resources - extending ANY sequence helps AI win!
                    let extendsAnySequence = false;
                    if (shouldTake && discardCard) {
                        for (let p = 0; p < this.players; p++) {
                            if (this.publishedSequences[p].length > 0 && this.couldExtendSequence(discardCard, p)) {
                                extendsAnySequence = true;
                                const playerName = p === 0 ? 'Human' : (p === 1 ? 'Habot' : 'Jabot');
                                console.log(`  üåç v4.2.7: ${discardCard.toString()} extends ${playerName}'s published sequence (global resource)`);
                                break;
                            }
                        }
                    }

                    if (shouldTake && aiHandSize <= 3 && this.publishedSequences[ai].length > 0 && !extendsAnySequence) {
                        console.log(`%c  üõë PATCH H: Blocking buy - AI has ${aiHandSize} cards in endgame`, 'color: #e74c3c; font-weight: bold;');
                        shouldTake = false;
                    }

                    if (shouldTake && anyPlayerNearWin && !extendsAnySequence) {
                        console.log(`%c  üõë PATCH H: Blocking buy - Someone near win (‚â§3 cards + published)`, 'color: #e74c3c; font-weight: bold;');
                        shouldTake = false;
                    }
                    
                    if (extendsAnySequence && aiHandSize <= 3) {
                        console.log(`%c  ‚úÖ v4.2.7: ALLOWING buy - ${discardCard.toString()} extends published sequences (global resource, helps AI win)!`, 'color: #27ae60; font-weight: bold;');
                    }

                    console.log(`%c  üéØ ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                    console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                    console.log(`     discardScore: ${discardScore}`);
                    console.log(`     threshold: ${threshold}`);
                    console.log(`     forceBuy: ${forceBuy}`);
                    console.log(`     shouldTake: ${shouldTake} ${!shouldTake && (aiHandSize <= 3 || anyPlayerNearWin) ? '(BLOCKED - endgame)' : ''}`);

                    // üéØ PATCH I v4.1.1: Block ALL buying after publishing in triple-only games
                    if (shouldTake && this.publishedSequences[ai].length > 0) {
                        const req = this.handReqs[this.currentHand].seqs;
                        const needLadders = req.filter(s => s === 'ladder').length;

                        if (needLadders === 0) {
                            // Triple-only game and AI has published - NO MORE BUYING
                            console.log(`%c  üõë PATCH I v4.1.1: Blocking buy - Triple-only hand, AI already published`, 'color: #ff9800; font-weight: bold;');
                            shouldTake = false;
                        }
                    }

                    if (shouldTake && this.discardPile.length > 0) {

                        if (this.wouldDiscardImmediately(this.discardPile[this.discardPile.length - 1], ai)) {
                            this.setAIStatus(statusId, `Evaluating options...`);
                            this.handleDeckDraw(ai, statusId);
                            return;
                        } else {
                            const drawnCard = this.discardPile.pop();
                            this.playerHands[ai].push(drawnCard);
                            this.discardPileAccessible = false; // üîí v4.1.3: Lock vault after taking card

                            // ‚úÖ FIX 2: Show specific toast when AI takes card during buy window
                            if (this.buyWindow.active && this.buyWindow.buyWindowPlayer === 0 && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                console.log(`%cüö® FIX 2: AI took card during human buy window`, 'color: #ff6b35; font-weight: bold;');
                                showAITookCardToast(aiName, drawnCard);
                            }

                            if (this.buyWindow.active && this.buyWindow.card && this.buyWindow.card.id === drawnCard.id) {
                                this.closeBuyWindow('taken');
                            }
                            if (this.lastDiscard && this.lastDiscard.rank === drawnCard.rank && this.lastDiscard.suit === drawnCard.suit) {
                                this.lastDiscard = null;
                                this.lastDiscardByPlayer = -1;
                            }
                            if (forceBuy) this.setAIStatus(statusId, `Analyzing hand...`);
                            else this.setAIStatus(statusId, `Drawing card...`);
                        }

                    } else {

                        console.log(`%c  üéØ ${aiName} evaluation:`, 'color: #e67e22; font-weight: bold;');
                        console.log(`     discardCard: ${discardCard ? discardCard.toString() : 'none'}`);
                        console.log(`     discardScore: ${discardScore}`);
                        console.log(`     threshold: ${threshold}`);
                        console.log(`     forceBuy: ${forceBuy}`);
                        console.log(`     shouldTake: ${shouldTake}`);

                        console.log(`%c  ${aiName} drawing from deck...`, 'color: #3498db;');
                        this.setAIStatus(statusId, `Drawing from deck...`);
                        this.handleDeckDraw(ai, statusId);
                        return;
                    }

                    this.continueAITurnAfterDraw(ai, statusId);
                }, 1500);
            }

            handleDeckDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';

                console.log(`%cüîç handleDeckDraw called for ${aiName}`, 'color: #9b59b6; font-weight: bold;');
                console.log(`  lastDiscard: ${this.lastDiscard ? this.lastDiscard.toString() : 'null'}`);
                console.log(`  lastDiscardByPlayer: ${this.lastDiscardByPlayer}`);

                if (this.lastDiscard && this.lastDiscardByPlayer !== -1) {
                    const buyWindowPlayer = (this.lastDiscardByPlayer + 2) % 3;
                    console.log(`  buyWindowPlayer would be: ${buyWindowPlayer} (${['Human', 'Habot', 'Jabot'][buyWindowPlayer]})`);

                    if (buyWindowPlayer !== ai && buyWindowPlayer !== this.lastDiscardByPlayer) {
                        console.log(`  ‚úÖ Buy window conditions met!`);
                        const cardStillExists = this.discardPile.some(c => c.rank === this.lastDiscard.rank && c.suit === this.lastDiscard.suit);

                        if (!cardStillExists) {
                            this.lastDiscard = null;
                            this.lastDiscardByPlayer = -1;
                            this.drawDeckCardForAI(ai, statusId);
                            this.continueAITurnAfterDraw(ai, statusId);
                            return;
                        }
                        this.startBuyWindow(this.lastDiscard, this.lastDiscardByPlayer);
                        this.buyWindow.pendingDeckDraw = { ai, statusId };
                        if (buyWindowPlayer > 0) this.handleAIBuyWindow(buyWindowPlayer);
                        return;
                    }
                }
                this.drawDeckCardForAI(ai, statusId);
                this.continueAITurnAfterDraw(ai, statusId);
            }

            drawDeckCardForAI(ai, statusId) {
                if (this.deck.length === 0) { this.reshuffleDeck(); this.updateUI() }
                if (this.deck.length > 0) {
                    const drawnCard = this.deck.pop();
                    this.playerHands[ai].push(drawnCard);
                    this.setAIStatus(statusId, `Analyzed hand`);
                }
            }

            continueAITurnAfterDraw(ai, statusId) {
                const aiName = ai === 1 ? 'Habot' : 'Jabot';
                
                // üèóÔ∏è v4.5.3: STAGED CONSTRUCTION WITH HOLD SYSTEM
                if (this.currentHand >= 6 && this.aiConstructionStage[ai] !== 'ready_to_publish') {
                    const hand = this.playerHands[ai];
                    const unlockedHand = this.getUnlockedCards(hand, ai); // üîß v4.5.3: Only check unlocked cards!
                    const seqs = this.findSequences(unlockedHand);
                    const stage = this.aiConstructionStage[ai];
                    
                    console.log(`  üèóÔ∏è v4.5.3: ${aiName} turn - Stage: ${stage}`);
                    console.log(`      Hand: ${hand.length} total (${unlockedHand.length} unlocked) - ${seqs.triples.length}T, ${seqs.ladders.length}L`);
                    
                    // üî∂ v4.5.3: FIRST - Check all held sequences for completion
                    this.checkHeldSequences(ai);
                    
                    // Check if we completed a sequence in current stage
                    if (stage === 'building_L1' && seqs.ladders.length > 0) {
                        // Lock first ladder
                        const firstLadder = seqs.ladders[0];
                        const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                        
                        if (locked.length === 0) {
                            // First ladder not yet locked - lock it now!
                            this.lockSequence(ai, firstLadder, 'ladder', firstLadder[0].suit);
                            console.log(`      üîí Locked first ladder: ${firstLadder.map(c => c.toString()).join(', ')}`);
                            
                            // Advance to next stage
                            this.advanceConstructionStage(ai);
                        }
                    } else if (stage === 'building_L1' && seqs.ladders.length === 0) {
                        // üî∂ v4.5.3: No complete ladder ‚Üí Check for HOLDS
                        const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                        
                        if (potentialHolds.length > 0 && this.aiHeldSequences[ai].length === 0) {
                            // Found 3-card "almost ladder" and no holds yet ‚Üí PUT ON HOLD
                            const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                            this.putOnHold(ai, bestHold);
                            
                            // IMMEDIATELY advance to L2 (don't wait!)
                            console.log(`      ‚è≠Ô∏è v4.5.3: Advancing to L2 while L1 on hold`);
                            this.advanceConstructionStage(ai);
                        }
                        // else: Keep accumulating cards on building_L1
                    } else if (stage === 'building_L2' && seqs.ladders.length >= 2) {
                        // Lock second ladder
                        const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                        
                        if (locked.length === 1) {
                            // Find the unlocked ladder
                            const unlockedLadder = seqs.ladders.find(ladder => {
                                const firstCard = ladder[0];
                                return !locked.some(l => l.cards.some(c => c.id === firstCard.id));
                            });
                            
                            if (unlockedLadder) {
                                this.lockSequence(ai, unlockedLadder, 'ladder', unlockedLadder[0].suit);
                                console.log(`      üîí Locked second ladder: ${unlockedLadder.map(c => c.toString()).join(', ')}`);
                                
                                // Advance to next stage (L3 or T depending on requirements)
                                this.advanceConstructionStage(ai);
                            }
                        }
                    } else if (stage === 'building_L2' && seqs.ladders.length < 2) {
                        // üî∂ v4.5.3: No second ladder yet ‚Üí Check for HOLDS
                        const unlockedHand = this.getUnlockedCards(hand, ai);
                        const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                        
                        // Only add one hold for L2 (may already have L1 on hold)
                        const l2Holds = this.aiHeldSequences[ai].filter(h => h.createdTurn >= this.turnCounter - 5);
                        if (potentialHolds.length > 0 && l2Holds.length < 1) {
                            const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                            this.putOnHold(ai, bestHold);
                            
                            // Advance to next stage while L2 on hold
                            console.log(`      ‚è≠Ô∏è v4.5.3: Advancing while L2 on hold`);
                            this.advanceConstructionStage(ai);
                        }
                    } else if (stage === 'building_L3' && seqs.ladders.length >= 3) {
                        // üîß v4.5.3: Lock third ladder (Hand 7)
                        const locked = this.aiLockedSequences[ai].filter(s => s.type === 'ladder');
                        
                        if (locked.length === 2) {
                            // Find the unlocked ladder
                            const unlockedLadder = seqs.ladders.find(ladder => {
                                const firstCard = ladder[0];
                                return !locked.some(l => l.cards.some(c => c.id === firstCard.id));
                            });
                            
                            if (unlockedLadder) {
                                this.lockSequence(ai, unlockedLadder, 'ladder', unlockedLadder[0].suit);
                                console.log(`      üîí v4.5.3: Locked THIRD ladder: ${unlockedLadder.map(c => c.toString()).join(', ')}`);
                                
                                // Check if ready to publish
                                this.advanceConstructionStage(ai);
                            }
                        }
                    } else if (stage === 'building_L3' && seqs.ladders.length < 3) {
                        // üî∂ v4.5.3: No third ladder yet ‚Üí Can put on hold if needed
                        const unlockedHand = this.getUnlockedCards(hand, ai);
                        const potentialHolds = this.findPotentialHolds(unlockedHand, ai);
                        
                        if (potentialHolds.length > 0 && this.aiHeldSequences[ai].length < 2) {
                            const bestHold = potentialHolds.sort((a, b) => b.priority - a.priority)[0];
                            this.putOnHold(ai, bestHold);
                        }
                        // Note: Don't advance past L3, stay on L3 until third ladder found
                    } else if (stage === 'building_T' && seqs.triples.length > 0) {
                        // Lock triple
                        const firstTriple = seqs.triples[0];
                        const lockedTriples = this.aiLockedSequences[ai].filter(s => s.type === 'triple');
                        
                        if (lockedTriples.length === 0) {
                            this.lockSequence(ai, firstTriple, 'triple');
                            console.log(`      üîí Locked triple: ${firstTriple.map(c => c.toString()).join(', ')}`);
                            
                            // Check if ready to publish
                            this.advanceConstructionStage(ai);
                        }
                    }
                }
                
                // PATCH 4: Emergency publish if hand is too large
                const currentHandSize = this.playerHands[ai].length;
                if (currentHandSize >= 13 && this.publishedSequences[ai].length === 0 && this.canPublish(ai)) {
                    console.log(`%cüö® PATCH 4: ${aiName} has ${currentHandSize} cards - FORCING publish!`, 'color: #e74c3c; font-weight: bold;');
                    const publishSuccess = this.autoPublish(ai);
                    if (publishSuccess) {
                        this.aiJustPublished[ai] = true;
                        this.setAIStatus(statusId, `Emergency Published!`);
                        console.log(`%c‚úÖ PATCH 4: ${aiName} emergency publish SUCCESS!`, 'color: #27ae60; font-weight: bold;');
                        const newHandSize = this.playerHands[ai].length;
                        console.log(`%c   Hand reduced from ${currentHandSize} to ${newHandSize}`, 'color: #27ae60;');
                    } else {
                        console.log(`%c‚ö†Ô∏è PATCH 4: ${aiName} emergency publish FAILED - no valid sequences`, 'color: #f39c12; font-weight: bold;');
                    }
                }

                // üéØ PATCH L2: Auto-drop excess pairs in triple games
                const req = this.handReqs[this.currentHand].seqs;
                const hasOnlyTriples = req.every(s => s === 'triple');

                if (hasOnlyTriples) {
                    // Count pairs
                    const rankCounts = {};
                    this.playerHands[ai].forEach(c => {
                        rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1;
                    });

                    const pairs = Object.entries(rankCounts).filter(([rank, count]) => count === 2);

                    if (pairs.length > 4) {
                        console.log(`%c  ‚Üí PATCH L2: ${aiName} has ${pairs.length} pairs - dropping worst one`, 'color: #e67e22; font-weight: bold;');

                        // Find highest-value pair to drop
                        let worstPairRank = null;
                        let highestValue = -1;

                        pairs.forEach(([rank, count]) => {
                            const cardValue = this.playerHands[ai].find(c => c.rank === rank).getValue();
                            if (cardValue > highestValue) {
                                highestValue = cardValue;
                                worstPairRank = rank;
                            }
                        });

                        // Drop one card from worst pair
                        const cardToDrop = this.playerHands[ai].find(c => c.rank === worstPairRank);
                        const dropIndex = this.playerHands[ai].indexOf(cardToDrop);
                        this.playerHands[ai].splice(dropIndex, 1);
                        this.discardPile.push(cardToDrop);
                        this.discardPileAccessible = true; // üîí v4.1.3: Unlock vault

                        console.log(`%c  ‚Üí PATCH L2: Auto-dropped ${cardToDrop.toString()} (highest-value pair)`, 'color: #e67e22; font-weight: bold;');
                        this.updateUI();

                        // End turn - we already discarded
                        this.setAIStatus(statusId, '');
                        document.getElementById(`${statusId}-status`).classList.remove('active');

                        this.currentPlayer = (this.currentPlayer + 1) % this.players;
                        this.gamePhase = 'draw';
                        this.updateUI();
                        if (this.currentPlayer !== 0) this.aiTurn();

                        return;
                    }
                }

                const canPublishNow = this.canPublish(ai) && this.publishedSequences[ai].length === 0;

                if (canPublishNow) {
                    let shouldPublish = false;
                    const opponentDanger = this.publishedSequences.some((seq, idx) => idx !== ai && seq.length > 0 && this.playerHands[idx].length <= 3);
                    if (opponentDanger) shouldPublish = true;
                    const personality = this.getAIPersonality(ai);

                    //Nash: changed it from 22 : 30 to make the game faster
                    const turnLimit = personality === 'rabbit' ? 15 : 20;
                    if (this.turnCounter >= turnLimit) shouldPublish = true;
                    else {
                        let optimalSize = this.currentHand <= 3 ? 7 : 6;
                        if (personality === 'rabbit') optimalSize += 1;
                        else if (personality === 'tortoise') optimalSize -= 1;
                        if (this.playerHands[ai].length <= optimalSize) shouldPublish = true;
                    }

                    console.log(`%c  üìã ${aiName} publish check:`, 'color: #9b59b6; font-weight: bold;');
                    console.log(`     canPublishNow: ${canPublishNow}`);
                    console.log(`     opponentDanger: ${opponentDanger}`);
                    console.log(`     turnCounter: ${this.turnCounter}`);
                    console.log(`     handSize: ${this.playerHands[ai].length}`);
                    console.log(`     shouldPublish: ${shouldPublish}`);

                    if (shouldPublish) {
                        console.log(`%c  üéâ ${aiName} attempting to publish!`, 'color: #28a745; font-weight: bold;');
                        const publishSuccess = this.autoPublish(ai);
                        console.log(`     publishSuccess: ${publishSuccess}`);

                        if (publishSuccess) {
                            this.aiJustPublished[ai] = true;
                            this.setAIStatus(statusId, `Published!`);
                            console.log(`%c  ‚úÖ ${aiName} PUBLISHED successfully!`, 'color: #28a745; font-weight: bold;');
                            console.log(`     Published sequences:`, this.publishedSequences[ai]);
                        } else {
                            console.log(`%c  ‚ùå ${aiName} publish FAILED`, 'color: #dc3545; font-weight: bold;');
                        }
                        if (this.playerHands[ai].length === 0) {
                            console.log(`%c  üèÜ ${aiName} has NO cards left - WINS!`, 'color: #ffc107; font-weight: bold;');
                            this.endHand(ai);
                            return;
                        }
                    }
                }

                // PATCH 5: Try to publish again if still holding 12+ cards after first publish
                if (this.playerHands[ai].length >= 12 && this.publishedSequences[ai].length > 0 && this.canPublish(ai)) {
                    console.log(`%cüö® PATCH 5: ${aiName} still has ${this.playerHands[ai].length} cards after publishing - checking for more sequences`, 'color: #e74c3c; font-weight: bold;');
                    const additionalPublish = this.autoPublish(ai);
                    if (additionalPublish) {
                        console.log(`%c‚úÖ PATCH 5: ${aiName} published additional sequences!`, 'color: #27ae60; font-weight: bold;');
                    }
                }

                if (!this.aiJustPublished[ai] && this.playerHands[ai].length > 0 && this.publishedSequences[ai].length > 0) {
                    // üéØ v4.0.7: Try to add MULTIPLE cards if possible (loop until no more extensions)
                    let addedAny = false;
                    let addCount = 0;
                    const maxExtensions = 10; // Safety limit
                    
                    console.log(`%cüéØ v4.0.7: Checking for extension opportunities...`, 'color: #9c27b0; font-weight: bold;');
                    
                    while (addCount < maxExtensions) {
                        const addResult = this.tryAddToPublished(ai);
                        
                        if (addResult === 'win') {
                            this.setAIStatus(statusId, `Added and WINS!`);
                            this.updateUI();
                            setTimeout(() => { this.endHand(ai) }, 50);
                            return;
                        } else if (addResult === true) {
                            addedAny = true;
                            addCount++;
                            console.log(`%c  ‚úÖ v4.0.7: Extended sequence (${addCount} card(s) played)`, 'color: #9c27b0;');
                            // Continue loop to check if we can add more
                        } else {
                            // No more extensions possible
                            break;
                        }
                    }
                    
                    if (addedAny) {
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ` ‚Üí Added ${addCount} card(s)`);
                        console.log(`%cüéØ v4.0.7: Total extensions played: ${addCount}`, 'color: #9c27b0; font-weight: bold;');
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 1500);
                    return;
                }
                if (this.playerHands[ai].length > 0) {
                    const worst = this.findWorstCard(ai);
                    const idx = this.playerHands[ai].findIndex(c => c.id === worst.id);
                    if (idx > -1) {
                        this.playerHands[ai].splice(idx, 1);
                        this.discardPile.push(worst);
                        this.discardPileAccessible = true; // üîí v4.1.3: Unlock vault
                        this.lastAIDiscard[ai] = worst;
                        this.lastDiscard = worst;
                        this.lastDiscardByPlayer = ai;
                        const current = document.getElementById(`${statusId}-action`).textContent;
                        this.setAIStatus(statusId, current + ` ‚Üí Discarded: ${worst.toString()}`);
                    }
                }
                if (this.playerHands[ai].length === 0) {
                    this.setAIStatus(statusId, `WINS!`);
                    this.updateUI();
                    setTimeout(() => { this.endHand(ai) }, 50);
                    return;
                }
                if (this.shouldRequestBuy(ai)) {
                    const current = document.getElementById(`${statusId}-action`).textContent;
                    if (!current.includes('BUY!')) this.setAIStatus(statusId, current + ' ‚Üí Says "BUY!"');
                }

                this.lastDiscard = this.discardPile[this.discardPile.length - 1];
                this.lastDiscardByPlayer = ai;
                // üéØ v4.0.7: REMOVED aiJustPublished[ai] = false from here
                // Flag now resets at START of NEXT turn, not end of THIS turn
                // This prevents extending on same turn as publishing

                // ‚úÖ Check if buy window should open after AI discarded
                const buyWindowOpened = this.checkAndOpenBuyWindowAfterDiscard(ai, statusId);

                if (buyWindowOpened) {
                    // Buy window is open - it will handle game continuation
                    return;
                }

                // No buy window - continue normally
                setTimeout(() => { document.getElementById(`${statusId}-status`).classList.remove('active') }, 2000);
                this.currentPlayer = (this.currentPlayer + 1) % this.players;
                this.gamePhase = 'draw';
                this.updateUI();
                if (this.currentPlayer !== 0) this.aiTurn();
            }

            tryAddToPublished(aiIdx) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const playerOrder = [aiIdx];
                for (let p = 0; p < this.players; p++) {
                    if (p !== aiIdx) playerOrder.push(p);
                }
                for (let p of playerOrder) {
                    if (this.publishedSequences[p].length === 0) continue;

                    // üéØ v4.0.7 FIX: REMOVED PATCH Q entirely!
                    // OLD LOGIC (WRONG):
                    // "Don't extend opponent AI when all published" - prevented Jabot from extending Habot
                    // 
                    // NEW UNDERSTANDING:
                    // Extending ANY sequence (even opponent's) is GOOD for the extending player!
                    // - Reduces your hand size ‚úì
                    // - Gets you closer to winning ‚úì  
                    // - Opponent doesn't get cards back ‚úì
                    // - It's ALWAYS beneficial to extend!
                    //
                    // Example: Jabot extends Habot's 7‚ô†7‚ô•7‚ô¶ with 7‚ô£
                    // - Jabot's hand: 3 ‚Üí 2 cards (progress!) ‚úì
                    // - Habot's published: 3 ‚Üí 4 cards (but Habot's hand unchanged)
                    // - Net result: Jabot closer to winning! ‚úì

                    // üéØ v4.2.7 FIX: REMOVED opponent hand size check entirely!
                    // After publishing, ALWAYS extend ALL sequences (global resources)!
                    // Playing cards to extend reduces YOUR hand - it's always good!
                    // OLD BUG: if (p !== aiIdx && this.playerHands[p].length <= 4 && this.playerHands[aiIdx].length > 1) continue;
                    // This prevented AI from aggressively extending after publishing
                    
                    for (let i = 0; i < this.playerHands[aiIdx].length; i++) {
                        const card = this.playerHands[aiIdx][i];
                        
                        // üéØ v4.0.7: Get flat view of published cards for extension logic
                        const published = this.getFlatPublished(p);
                        
                        // üéØ v4.0.7 FIX: REMOVED incorrect check
                        // OLD BUG: const inOwnSequences = this.publishedSequences[aiIdx].find(c => c.rank === card.rank && c.suit === card.suit);
                        // OLD BUG: if (inOwnSequences) continue;
                        // This was blocking cards like "second 8‚ô¶" from extending "first 8‚ô¶" in triples!
                        // Cards are unique by ID, not by rank+suit. Multiple cards can have same rank+suit.
                        
                        const alreadyPublished = published.find(c => c.id === card.id);
                        if (alreadyPublished) continue;  // Skip if this exact card already published
                        const sameRankSuit = published.filter(c => c.rank === card.rank && c.suit === card.suit);
                        if (sameRankSuit.length >= 2) continue;  // Skip if 2+ of same rank/suit already there
                        if (hasTriples) {
                            const rankCounts = {};
                            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                            if (rankCounts[card.rank] >= 3) {
                                this.playerHands[aiIdx].splice(i, 1);
                                
                                // üéØ v4.0.7: Build new flat array with added card
                                const allPublished = [...published, card];
                                const tripleCards = [];
                                const ladderCards = [];
                                const processedRanks = new Set();
                                allPublished.forEach(c => {
                                    const count = allPublished.filter(pc => pc.rank === c.rank).length;
                                    if (count >= 3 && !processedRanks.has(c.rank)) {
                                        const sameRank = allPublished.filter(card => card.rank === c.rank);
                                        tripleCards.push(...sameRank);
                                        processedRanks.add(c.rank);
                                    }
                                });
                                allPublished.forEach(c => {
                                    if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                                });
                                tripleCards.sort((a, b) => a.getValue() - b.getValue());
                                ladderCards.sort((a, b) => {
                                    const suitOrder = { '‚ô†': 1, '‚ô•': 2, '‚ô¶': 3, '‚ô£': 4 };
                                    if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                                    return a.getValue() - b.getValue();
                                });
                                
                                // üéØ v4.0.7: Store back as 2D array (autoPublish will handle separation)
                                const combinedFlat = [...tripleCards, ...ladderCards];
                                const sequences = this.separateSequences(combinedFlat, req);
                                this.publishedSequences[p] = sequences;
                                
                                if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                return true;
                            }
                        }
                        if (hasLadders) {
                            const sameSuit = published.filter(c => c.suit === card.suit);
                            console.log(`  üîç tryAddToPublished: Checking ${card.toString()} - found ${sameSuit.length} published ${card.suit} cards`);
                            if (sameSuit.length >= 4) {
                                const cardVal = card.getValue();
                                const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                                const ladders = []; let remainingValues = [...values];
                                const hasAce = values.includes(1); const hasJack = values.includes(11);
                                const hasQueen = values.includes(12); const hasKing = values.includes(13);

                                if (hasAce && hasJack && hasQueen && hasKing) {
                                    // üîß PATCH O: Extract ALL consecutive high cards from King downward
                                    const wrapLadder = [1];  // Start with Ace (value 1)
                                    const highCards = values.filter(v => v >= 11).sort((a, b) => b - a);
                                    for (let i = 0; i < highCards.length; i++) {
                                        if (i === 0 || highCards[i] === highCards[i - 1] - 1) {
                                            wrapLadder.push(highCards[i]);
                                        } else {
                                            break;
                                        }
                                    }
                                    console.log(`  üîß PATCH O: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                                    ladders.push(wrapLadder);
                                    remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                                }

                                if (remainingValues.length >= 4) {
                                    let currentLadder = [remainingValues[0]];
                                    for (let i = 1; i < remainingValues.length; i++) {
                                        if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                            currentLadder.push(remainingValues[i]);
                                        } else {
                                            if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                            currentLadder = [remainingValues[i]];
                                        }
                                    }
                                    if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                                }
                                const canExtendLadder = ladders.some(ladder => {
                                    return this.canCardExtendLadder(cardVal, ladder);
                                });
                                if (canExtendLadder) {
                                    this.playerHands[aiIdx].splice(i, 1);
                                    
                                    // üéØ v4.0.7: Build new flat array with added card
                                    const allPublished = [...published, card];
                                    const rankCounts = {};
                                    allPublished.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
                                    const tripleCards = [];
                                    const ladderCards = [];
                                    const processedRanks = new Set();
                                    allPublished.forEach(c => {
                                        if (rankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                                            const sameRank = allPublished.filter(card => card.rank === c.rank);
                                            tripleCards.push(...sameRank);
                                            processedRanks.add(c.rank);
                                        }
                                    });
                                    allPublished.forEach(c => {
                                        if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                                    });
                                    tripleCards.sort((a, b) => a.getValue() - b.getValue());
                                    ladderCards.sort((a, b) => {
                                        const suitOrder = { '‚ô†': 1, '‚ô•': 2, '‚ô¶': 3, '‚ô£': 4 };
                                        if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                                        return a.getValue() - b.getValue();
                                    });
                                    
                                    // üéØ v4.0.7: Store back as 2D array (autoPublish will handle separation)
                                    const combinedFlat = [...tripleCards, ...ladderCards];
                                    const sequences = this.separateSequences(combinedFlat, req);
                                    this.publishedSequences[p] = sequences;
                                    
                                    if (this.playerHands[aiIdx].length === 0) { this.endHand(aiIdx); return 'win' }
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            endHand(winner) {
                const winnerName = winner === 0 ? 'You' : winner === 1 ? 'Habot' : 'Jabot';
                showWinToast(winnerName);
                for (let i = 0; i < this.players; i++) {
                    if (i === winner) continue;
                    let score = 0;
                    this.playerHands[i].forEach(c => score += c.getPenaltyValue());
                    this.playerScores[i] += score;
                }
                setTimeout(() => { this.showModal('Hand Complete', `${winnerName} won Hand ${this.currentHand}!`) }, 2000);
                setTimeout(() => {
                    this.currentHand++;
                    if (this.currentHand > 7) this.showFinalResults();
                    else {
                        this.playerBuys = this.currentHand === 7 ? [2, 2, 2] : [3, 3, 3];
                        this.publishedSequences = [[], [], []]; this.playerHands = [[], [], []]; this.selectedCards = [];
                        this.gamePhase = 'draw'; this.currentPlayer = 0; this.justPublished = false; this.aiJustPublished = [false, false, false];
                        this.lastDiscard = null; this.lastDiscardByPlayer = -1; this.discardPile = [];
                        this.turnCounter = 0; this.lastAIDiscard = [null, null, null]; this.lastCardWarningShown = null;
                        
                        // üèóÔ∏è v4.5.3: Initialize staged construction for Hands 6-7
                        if (this.currentHand >= 6) {
                            console.log(`%cüèóÔ∏è v4.5.3: Initializing STAGED CONSTRUCTION for Hand ${this.currentHand}`, 'color: #9b59b6; font-weight: bold; font-size: 14px;');
                            this.aiConstructionStage = [null, 'building_L1', 'building_L1'];
                            this.aiStageStartTurn = [null, this.turnCounter, this.turnCounter]; // üíö v4.5.3: Track stage start
                            this.aiLockedSequences = [[], [], []];
                            this.aiTargetCards = [null, [], []];
                            this.aiSuitFocus = [null, [], []];
                        }
                        
                        this.initDeck(); this.deal(); this.updateUI();
                    }
                }, 4000);
            }

            showFinalResults() {
                const results = this.playerScores.map((s, i) => ({ name: i === 0 ? 'You' : i === 1 ? 'Habot' : 'Jabot', score: s })).sort((a, b) => a.score - b.score);
                const winner = results[0];
                const loser = results[results.length - 1];
                persistentScores = [...this.playerScores];
                const msg = `Game Complete!\n\nüèÜ ${winner.name} wins with ${winner.score} points!\nüéÉ ${loser.name} is the Habib Punja with ${loser.score} points!`;
                this.showModal('Final Results', msg);

                setTimeout(async () => {
                    console.log('%cüéÆ Starting New Game...', 'color: #2196f3; font-weight: bold; font-size: 16px;');

                    // Create game instance
                    game = new GameState(true);

                    // Draw for starting player
                    const startingPlayer = await game.drawForFirstTurn();
                    game.currentPlayer = startingPlayer;
                    game.startingPlayer = startingPlayer;

                    console.log(`%cüéØ Starting player set: ${['You', 'Habot', 'Jabot'][startingPlayer]}`, 'color: #e91e63; font-weight: bold;');

                    // Initialize game
                    game.initDeck();
                    game.deal();
                    game.updateUI();

                    // If AI starts, begin their turn
                    if (game.currentPlayer !== 0) {
                        game.aiTurn();
                    }

                    console.log('%c‚úÖ Game initialized!', 'color: #4caf50; font-weight: bold;');
                }, 5000);

            }

            showModal(title, msg) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;';
                
                const titleEl = document.createElement('h2');
                titleEl.style.cssText = 'color:#ffd700;margin-bottom:15px;';
                titleEl.textContent = title;
                
                const msgEl = document.createElement('p');
                msgEl.style.cssText = 'color:white;margin-bottom:20px;white-space:pre-line;';
                msgEl.textContent = msg;
                
                const okBtn = document.createElement('button');
                okBtn.style.cssText = 'padding:12px 30px;background:#28a745;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;';
                okBtn.textContent = 'OK';
                okBtn.addEventListener('click', () => modal.remove());
                
                modalContent.appendChild(titleEl);
                modalContent.appendChild(msgEl);
                modalContent.appendChild(okBtn);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
            }



            showDisambiguationModal(card, playerIdx, cardIdx) {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:10000;';

                modal.innerHTML = `
        <div style="background:#1a4d2e;padding:30px;border-radius:15px;text-align:center;border:2px solid #ffd700;max-width:500px;">
            <h2 style="color:#ffd700;margin-bottom:15px;">üéØ Choose Sequence</h2>
            <p style="color:white;margin-bottom:20px;">
                ${card.toString()} can extend BOTH your triple and your ladder.<br><br>
                Which sequence do you want to add it to?
            </p>
            <div style="display:flex;gap:15px;justify-content:center;">
                <button id="chooseTriple" style="padding:12px 24px;background:#e74c3c;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                    Add to Triple
                </button>
                <button id="chooseLadder" style="padding:12px 24px;background:#3498db;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;font-size:1rem;">
                    Add to Ladder
                </button>
            </div>
            <button id="cancelChoice" style="margin-top:15px;padding:8px 20px;background:#6b7280;color:white;border:none;border-radius:8px;cursor:pointer;font-weight:bold;">
                Cancel
            </button>
        </div>`;

                document.body.appendChild(modal);

                // PATCH P: Fixed console.log syntax (was missing parentheses)
                document.getElementById('chooseTriple').onclick = () => {
                    console.log(`%c‚úÖ FIX 6: User chose TRIPLE for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'triple');
                };

                document.getElementById('chooseLadder').onclick = () => {
                    console.log(`%c‚úÖ FIX 6: User chose LADDER for ${card.toString()}`, 'color:#28a745;font-weight:bold');
                    modal.remove();
                    this.executeAddToPublished(card, playerIdx, cardIdx, 'ladder');
                };

                document.getElementById('cancelChoice').onclick = () => {
                    console.log(`%c‚ùå FIX 6: User cancelled`, 'color:#94a3b8');
                    modal.remove();
                };
            }



            executeAddToPublished(card, playerIdx, cardIdx, forceType) {
                const req = this.handReqs[this.currentHand].seqs;
                const hasTriples = req.some(s => s === 'triple');
                const hasLadders = req.some(s => s === 'ladder');
                const published = this.publishedSequences[playerIdx];

                // üéØ v4.2.7: When forceType is specified, user made explicit choice - DON'T re-separate!
                console.log(`%cüéØ v4.2.7: executeAddToPublished - forceType: ${forceType}`, 'color:#9c27b0;font-weight:bold');

                // Remove card from hand
                this.playerHands[0].splice(cardIdx, 1);

                // üéØ v4.5.3 CRITICAL FIX: When forceType specified, ONLY check matching sequence type!
                let addedToSequence = false;
                for (let seq of published) {
                    // Determine if this sequence is triple or ladder
                    const isTriple = seq.length >= 3 && seq.every(c => c.rank === seq[0].rank);
                    const isLadder = !isTriple;
                    
                    // Only check if sequence type matches forceType
                    const typeMatches = (forceType === 'triple' && isTriple) || (forceType === 'ladder' && isLadder);
                    
                    if (typeMatches && this.canAddToPublishedSequence(card, seq)) {
                        seq.push(card);
                        console.log(`%c  ‚úÖ v4.5.3: Added ${card.toString()} to ${forceType} sequence: ${seq.map(c => c.toString()).join(' ')}`, 'color:#28a745;font-weight:bold');
                        addedToSequence = true;
                        break;
                    }
                }
                
                if (!addedToSequence) {
                    console.log(`%c  ‚ö†Ô∏è v4.5.3: Could not add to existing ${forceType} sequence, creating new`, 'color:#f59e0b;');
                    published.push([card]);
                }
                
                this.selectedCards = [];
                this.updateUI();
            }

            // üéØ v4.0.7: Sort published sequences while respecting explicit user assignments
            sortPublishedSequences(playerIdx) {
                // üéØ v4.0.7 FIX: Get flat view of published cards since we need to resort
                const allPublished = this.getFlatPublished(playerIdx);
                const tripleCards = [];
                const ladderCards = [];
                
                // Count occurrences for auto-categorization
                const rankCounts = {};
                allPublished.forEach(c => {
                    rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1;
                });
                
                // Categorize each card
                const processedRanks = new Set();
                
                allPublished.forEach(c => {
                    // üéØ v4.0.7: Check if card has explicit assignment from user
                    if (c.explicitAssignment === 'triple') {
                        console.log(`  üéØ v4.0.7: ${c.toString()} has explicit TRIPLE assignment`);
                        tripleCards.push(c);
                    } else if (c.explicitAssignment === 'ladder') {
                        console.log(`  üéØ v4.0.7: ${c.toString()} has explicit LADDER assignment`);
                        ladderCards.push(c);
                    } else {
                        // No explicit assignment - use count-based logic
                        if (rankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                            // This rank forms a triple - add all of this rank
                            const sameRank = allPublished.filter(card => 
                                card.rank === c.rank && !card.explicitAssignment
                            );
                            tripleCards.push(...sameRank);
                            processedRanks.add(c.rank);
                        } else if (!tripleCards.find(tc => tc.id === c.id)) {
                            // Not in a triple, must be ladder
                            ladderCards.push(c);
                        }
                    }
                });
                
                // Sort triples by value
                tripleCards.sort((a, b) => a.getValue() - b.getValue());
                
                // Sort ladders by suit then value  
                ladderCards.sort((a, b) => {
                    const suitOrder = { '‚ô†': 1, '‚ô•': 2, '‚ô¶': 3, '‚ô£': 4 };
                    if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
                    return a.getValue() - b.getValue();
                });
                
                // üêõ FIX v4.1.2: Build sequences manually, respecting explicit assignments
                const sequences = [];
                
                // Group triples by rank
                const triplesByRank = {};
                tripleCards.forEach(c => {
                    if (!triplesByRank[c.rank]) triplesByRank[c.rank] = [];
                    triplesByRank[c.rank].push(c);
                });
                
                // Add each rank's cards as a sequence (handles 3, 4, 5+ of same rank)
                Object.values(triplesByRank).forEach(cards => {
                    sequences.push(cards);
                });
                
                // Group ladders by suit and find consecutive runs
                if (ladderCards.length >= 4) {
                    const laddersBySuit = {};
                    ladderCards.forEach(c => {
                        if (!laddersBySuit[c.suit]) laddersBySuit[c.suit] = [];
                        laddersBySuit[c.suit].push(c);
                    });
                    
                    Object.values(laddersBySuit).forEach(suitCards => {
                        if (suitCards.length >= 4) {
                            suitCards.sort((a, b) => a.getValue() - b.getValue());
                            sequences.push(suitCards);
                        }
                    });
                }
                
                this.publishedSequences[playerIdx] = sequences;
                
                console.log(`%cüéØ v4.1.2: Sorted and separated - ${sequences.length} sequences`, 'color:#9c27b0;');
                sequences.forEach((seq, i) => {
                    console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString()).join(' ')}`);
                });
            }

            // üéØ v4.0.7: sortPublishedSequences complete


            // ============================================
            // VERIFICATION COMMANDS (for cross-version testing)
            // ============================================

            jumpToHand(handNum) {
                if (handNum < 1 || handNum > 7) {
                    console.log('‚ö†Ô∏è Hand must be 1-7');
                    return;
                }
                console.log(`üîß Jumping to Hand ${handNum}...`);
                this.currentHand = handNum;
                this.playerBuys = handNum === 7 ? [2, 2, 2] : [3, 3, 3];
                this.publishedSequences = [[], [], []];
                this.playerHands = [[], [], []];
                this.selectedCards = [];
                this.gamePhase = 'draw';
                this.currentPlayer = 0;
                this.justPublished = false;
                this.aiJustPublished = [false, false, false];
                this.lastDiscard = null;
                this.lastDiscardByPlayer = -1;
                this.discardPile = [];
                this.turnCounter = 0;
                this.lastAIDiscard = [null, null, null];
                this.lastCardWarningShown = null;
                this.buyWindow = { active: false, card: null, discardingPlayer: -1, buyWindowPlayer: -1, expiresAt: 0, timerInterval: null, pendingDeckDraw: null };
                
                // üèóÔ∏è v4.5.3 FIX: Initialize staged construction when jumping to Hands 6-7
                if (handNum >= 6) {
                    console.log(`%cüèóÔ∏è v4.5.3: Initializing STAGED CONSTRUCTION for Hand ${handNum}`, 'color: #9b59b6; font-weight: bold; font-size: 14px;');
                    this.aiConstructionStage = [null, 'building_L1', 'building_L1'];
                    this.aiStageStartTurn = [null, this.turnCounter, this.turnCounter]; // üíö v4.5.3: Track stage start
                    this.aiLockedSequences = [[], [], []];
                    this.aiTargetCards = [null, [], []];
                    this.aiSuitFocus = [null, [], []];
                }
                
                this.initDeck();
                this.deal();
                this.updateUI();
                console.log(`‚úÖ Hand ${handNum} started`);
            }

            resetScores() {
                console.log('üîß Resetting all scores to 0...');
                persistentScores = [0, 0, 0];
                this.playerScores = [0, 0, 0];
                this.updateUI();
                console.log('‚úÖ Scores reset');
            }

            showState() {
                console.log('üìä GAME STATE:');
                console.log(`  Hand: ${this.currentHand}/7`);
                console.log(`  Phase: ${this.gamePhase}`);
                console.log(`  Current Player: ${this.currentPlayer} (${['You', 'Habot', 'Jabot'][this.currentPlayer]})`);
                console.log(`  Scores: [${this.playerScores.join(', ')}]`);
                console.log(`  Buys: [${this.playerBuys.join(', ')}]`);
                console.log(`  Cards in hand: [${this.playerHands.map(h => h.length).join(', ')}]`);
                console.log(`  Published sequences: [${this.publishedSequences.map(p => p.length).join(', ')}]`);
                console.log(`  Deck: ${this.deck.length} cards`);
                console.log(`  Discard: ${this.discardPile.length} cards`);
            }

            verifySync() {
                const state = {
                    hand: this.currentHand,
                    phase: this.gamePhase,
                    player: this.currentPlayer,
                    scores: this.playerScores,
                    buys: this.playerBuys,
                    handSizes: this.playerHands.map(h => h.length),
                    published: this.publishedSequences.map(p => p.length),
                    deckSize: this.deck.length,
                    discardSize: this.discardPile.length
                };
                console.log('üîç SYNC CHECK:', JSON.stringify(state, null, 2));
                return state;
            }

            updateUI() {
                const req = this.handReqs[this.currentHand];
                document.getElementById('currentHand').textContent = this.currentHand;
                document.getElementById('handRequirements').textContent = req.name;
                const progress = this.getPublishProgress();
                let progressParts = [];
                if (progress.needTriples > 0) progressParts.push(`${progress.hasTriples}/${progress.needTriples} triples`);
                if (progress.needLadders > 0) progressParts.push(`${progress.hasLadders}/${progress.needLadders} ladders`);
                const progressText = `${req.name} - You have: ${progressParts.join(', ')}`;
                document.getElementById('detailedRequirements').textContent = progressText;
                const reqEl = document.getElementById('detailedRequirements');
                reqEl.style.color = progress.canPublish ? '#28a745' : '#ffed4e';
                if (progress.canPublish) reqEl.classList.add('ready');
                else reqEl.classList.remove('ready');
                const turnText = this.currentPlayer === 0 ? 'Your Turn' : this.currentPlayer === 1 ? "Habot's Turn" : "Jabot's Turn";
                document.getElementById('turnIndicator').innerHTML = `${turnText} <span style="opacity:0.7;font-size:0.9em;">(Turn ${this.turnCounter})</span>`;
                document.getElementById('playerBuys').textContent = this.playerBuys[0];
                document.getElementById('player2Buys').textContent = this.playerBuys[1];
                document.getElementById('player3Buys').textContent = this.playerBuys[2];
                this.updateLeaderboard();
                const selInfo = document.getElementById('selectionInfo');
                const selCount = document.getElementById('selectedCount');
                if (this.selectedCards.length > 0) { selInfo.style.display = 'inline-block'; selCount.textContent = this.selectedCards.length }
                else selInfo.style.display = 'none';
                const playerHasPublished = this.publishedSequences[0].length > 0;
                const addSection = document.getElementById('addToPublishedSection');
                if (playerHasPublished && this.currentPlayer === 0 && this.gamePhase === 'discard' && this.selectedCards.length === 1 && !this.justPublished && this.playerHands[0].length > 1) addSection.style.display = 'block';
                else addSection.style.display = 'none';
                
                // üé® v4.0.7: Update active-turn highlighting for round table layout
                document.querySelectorAll('.opponent-area, .player-area-center').forEach(el => el.classList.remove('active-turn'));
                if (this.currentPlayer === 0) {
                    const yourArea = document.querySelector('.player-area-center');
                    if (yourArea) yourArea.classList.add('active-turn');
                } else if (this.currentPlayer === 1) {
                    const habotArea = document.querySelector('.opponent-left');
                    if (habotArea) habotArea.classList.add('active-turn');
                } else if (this.currentPlayer === 2) {
                    const jabotArea = document.querySelector('.opponent-right');
                    if (jabotArea) jabotArea.classList.add('active-turn');
                }
                
                this.renderHand(); this.renderAIHands(); this.renderPublished();
                if (this.discardPile.length > 0) document.getElementById('topDiscard').textContent = this.discardPile[this.discardPile.length - 1].toString();
                document.getElementById('discardBtn').disabled = this.currentPlayer !== 0 || this.gamePhase !== 'discard' || this.selectedCards.length !== 1;

                // üéØ PATCH J: Only enable publish if can actually publish OR extend sequences
                const canPublishNew = this.canPublish(0);
                const canExtendExisting = this.publishedSequences[0].length > 0 &&
                    this.playerHands[0].some(card =>
                        this.publishedSequences[0].some(seq => this.canAddToPublishedSequence(card, seq))
                    );

                document.getElementById('publishBtn').disabled = this.currentPlayer !== 0 ||
                    this.gamePhase !== 'discard' ||
                    (!canPublishNew && !canExtendExisting);

                document.getElementById('buyBtn').disabled = !this.buyWindow.active || this.buyWindow.buyWindowPlayer !== 0 || this.playerBuys[0] <= 0;

                // üéØ v2.5.0: Check last card for all players (show alert only once per player)
                [0, 1, 2].forEach(p => {
                    if (this.playerHands[p].length === 1 && !this.lastCardAlertShown[p]) {
                        const playerName = p === 0 ? 'You' : p === 1 ? 'Habot' : 'Jabot';
                        showLastCardToast(playerName);
                        this.lastCardAlertShown[p] = true;  // Mark this player as alerted
                        console.log(`%c‚ö†Ô∏è Last card alert shown for ${playerName}`, 'color: #ff9800; font-weight: bold;');
                    }
                });
            }

            updateLeaderboard() {
                // üëë v4.0.7 Phase 3: Dynamic Crown & Pumpkin with Tie-Breaker Logic
                const container = document.getElementById('leaderboardEntries');
                if (!container) return;
                
                const names = ['You', 'Habot', 'Jabot'];
                const sorted = this.playerScores.map((score, idx) => ({ 
                    score, 
                    idx, 
                    name: names[idx] 
                })).sort((a, b) => a.score - b.score);
                
                // Find min and max scores
                const minScore = sorted[0].score;
                const maxScore = sorted[sorted.length - 1].score;
                
                // Determine crown winner (lowest score, tie-breaker: first to reach)
                const crownCandidates = sorted.filter(p => p.score === minScore);
                const crownWinner = crownCandidates.length > 1 
                    ? crownCandidates.reduce((first, current) => 
                        current.idx < first.idx ? current : first
                      )
                    : crownCandidates[0];
                
                // Determine pumpkin holder (highest score, tie-breaker: first to reach)
                const pumpkinCandidates = sorted.filter(p => p.score === maxScore);
                const pumpkinHolder = pumpkinCandidates.length > 1
                    ? pumpkinCandidates.reduce((first, current) =>
                        current.idx < first.idx ? current : first
                      )
                    : pumpkinCandidates[0];
                
                // üé® v4.0.7: Display in VISUAL LAYOUT order for symmetry
                // Layout: Habot (left) | You (center) | Jabot (right)
                // Leaderboard order: [1]=Habot, [0]=You, [2]=Jabot
                const displayOrder = [
                    { score: this.playerScores[1], idx: 1, name: names[1] }, // Habot (left)
                    { score: this.playerScores[0], idx: 0, name: names[0] }, // You (center)
                    { score: this.playerScores[2], idx: 2, name: names[2] }  // Jabot (right)
                ];
                
                container.innerHTML = '';
                displayOrder.forEach((player) => {
                    const entry = document.createElement('div');
                    entry.className = 'leaderboard-entry';
                    
                    // Check if this player is currently winning or losing
                    const isWinning = player.score === minScore;
                    const isLosing = player.score === maxScore;
                    if (isWinning) entry.classList.add('first');
                    if (isLosing) entry.classList.add('last');
                    
                    // Award crown and pumpkin based on logic (not just position)
                    const hasCrown = player.idx === crownWinner.idx;
                    const hasPumpkin = player.idx === pumpkinHolder.idx;
                    
                    entry.innerHTML = `
                        <div class="leaderboard-name">
                            ${hasCrown ? 'üëë ' : ''}${player.name}${hasPumpkin ? ' üéÉ' : ''}
                        </div>
                        <div class="leaderboard-score">${player.score} pts</div>
                    `;
                    container.appendChild(entry);
                });
            }

            renderHand() {
                const container = document.getElementById('playerCards');
                container.innerHTML = '';
                this.playerHands[0].forEach((card, i) => {
                    const el = document.createElement('div');
                    el.className = `card ${card.getColor()}`;
                    if (card.suit === '‚ô•') el.classList.add('heart');
                    if (card.suit === '‚ô¶') el.classList.add('diamond');
                    if (this.selectedCards.includes(i)) el.classList.add('selected');
                    el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                    el.draggable = true;
                    el.dataset.index = i;
                    el.onclick = () => {
                        const idx = this.selectedCards.indexOf(i);
                        if (idx > -1) this.selectedCards.splice(idx, 1);
                        else this.selectedCards = [i];
                        this.updateUI();
                    };
                    el.addEventListener('dragstart', (e) => { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', i); el.classList.add('dragging') });
                    el.addEventListener('dragend', (e) => { el.classList.remove('dragging'); document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-over')) });
                    el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move' });
                    el.addEventListener('dragenter', (e) => { e.preventDefault(); if (el !== document.querySelector('.dragging')) el.classList.add('drag-over') });
                    el.addEventListener('dragleave', (e) => { el.classList.remove('drag-over') });
                    el.addEventListener('drop', (e) => {
                        e.preventDefault();
                        el.classList.remove('drag-over');
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIdx = parseInt(el.dataset.index);
                        if (fromIdx !== toIdx) this.moveCard(fromIdx, toIdx);
                    });
                    container.appendChild(el);
                });
            }

            moveCard(fromIdx, toIdx) {
                const card = this.playerHands[0].splice(fromIdx, 1)[0];
                this.playerHands[0].splice(toIdx, 0, card);
                this.selectedCards = this.selectedCards.map(idx => {
                    if (idx === fromIdx) return toIdx;
                    if (fromIdx < toIdx) { if (idx > fromIdx && idx <= toIdx) return idx - 1 }
                    else { if (idx >= toIdx && idx < fromIdx) return idx + 1 }
                    return idx;
                });
                this.updateUI();
            }

            renderAIHands() {
                // üé¥ v4.0.7 Phase 2: Show last 3 cards for AI players
                [1, 2].forEach(p => {
                    const container = document.getElementById(`player${p + 1}Cards`);
                    const countBadge = document.getElementById(`player${p + 1}Count`);
                    container.innerHTML = '';
                    
                    const hand = this.playerHands[p];
                    const handSize = hand.length;
                    
                    // Update card count badge
                    if (countBadge) {
                        countBadge.textContent = handSize;
                    }
                    
                    if (handSize === 0) {
                        container.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">No cards</div>';
                        return;
                    }
                    
                    // Show last 3 cards (or fewer if hand is smaller)
                    const cardsToShow = Math.min(3, handSize);
                    const startIndex = Math.max(0, handSize - cardsToShow);
                    
                    for (let i = startIndex; i < handSize; i++) {
                        const el = document.createElement('div');
                        el.className = 'card';
                        el.style.background = '#2c3e50';
                        el.style.cursor = 'default';
                        el.innerHTML = `<div style="font-size: 28px; color: rgba(255,255,255,0.4);">?</div>`;
                        container.appendChild(el);
                    }
                    
                    // Add hidden cards indicator if more than 3 cards
                    if (handSize > 3) {
                        const hiddenEl = document.createElement('div');
                        hiddenEl.style.fontSize = '.75rem';
                        hiddenEl.style.color = 'var(--muted)';
                        hiddenEl.style.textAlign = 'center';
                        hiddenEl.style.marginTop = '6px';
                        hiddenEl.textContent = `+${handSize - 3} hidden`;
                        container.appendChild(hiddenEl);
                    }
                });
            }

            renderPublished() {
                [0, 1, 2].forEach(p => {
                    const containerId = p === 0 ? 'player1Cards' : `player${p + 1}CardsPublished`;
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    
                    // üéØ v4.0.7: Iterate through sequences (2D array)
                    const sequences = this.publishedSequences[p];
                    if (!sequences || sequences.length === 0) return;
                    
                    const uniqueCards = [];
                    const seenIds = new Set();
                    
                    // Flatten all sequences but track unique cards
                    sequences.forEach(seq => {
                        seq.forEach(card => {
                            if (!seenIds.has(card.id)) {
                                uniqueCards.push(card);
                                seenIds.add(card.id);
                            }
                        });
                    });
                    
                    uniqueCards.forEach(card => {
                        const el = document.createElement('div');
                        el.className = `card ${card.getColor()}`;
                        if (card.suit === '‚ô•') el.classList.add('heart');
                        if (card.suit === '‚ô¶') el.classList.add('diamond');
                        el.style.transform = 'scale(0.7)';
                        el.innerHTML = `<div class="card-rank">${card.rank}</div><div class="card-suit">${card.suit}</div>`;
                        container.appendChild(el);
                    });
                });
            }
        }

        // Global functions
        function showPublishSelector(seqs, req) {
            const selector = document.getElementById('publishSelector');
            const options = document.getElementById('publishOptions');
            options.innerHTML = '';

            game.publishSelection = { triples: [], ladders: [] };

            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            // ‚úÖ FIX 5C: Map card IDs to consistent numbers ACROSS ALL SEQUENCES
            const duplicateCards = {};
            const cardIdToNumber = new Map();
            let nextNumber = 1;

            // First pass: Identify all duplicate rank+suit combinations
            game.playerHands[0].forEach(card => {
                const key = card.rank + card.suit;
                if (!duplicateCards[key]) duplicateCards[key] = [];
                duplicateCards[key].push(card);
            });

            // Assign consistent numbers to each UNIQUE CARD ID (only for duplicates)
            Object.entries(duplicateCards).forEach(([key, cards]) => {
                if (cards.length > 1) {
                    cards.forEach(card => {
                        cardIdToNumber.set(card.id, nextNumber++);
                    });
                }
            });

            console.log('%c‚úÖ FIX 5C: Card ID mapping:', 'color:#4a90e2;font-weight:bold');
            cardIdToNumber.forEach((num, id) => {
                const card = game.playerHands[0].find(c => c.id === id);
                if (card) console.log(`  ${card.toString()} (id:${id.substr(0, 4)}) ‚Üí Badge #${num}`);
            });

            if (triplesNeeded > 0) {
                const tripleDiv = document.createElement('div');
                tripleDiv.className = 'publish-option';
                tripleDiv.innerHTML = `<h4>Select ${triplesNeeded} Triple(s):</h4><div class="option-cards" id="tripleOptions"></div>`;
                options.appendChild(tripleDiv);

                const tripleContainer = document.getElementById('tripleOptions');

                seqs.triples.forEach((triple, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;position:relative;';
                    optDiv.onclick = () => toggleTripleSelection(idx, optDiv);

                    triple.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === '‚ô•') cardEl.classList.add('heart');
                        if (card.suit === '‚ô¶') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // ‚úÖ FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                                        <div class="card-rank">${card.rank}</div>
                                        <div class="card-suit">${card.suit}</div>
                                        ${duplicateLabel}
                                    `;
                        optDiv.appendChild(cardEl);
                    });

                    tripleContainer.appendChild(optDiv);
                });
            }

            if (laddersNeeded > 0) {
                const ladderDiv = document.createElement('div');
                ladderDiv.className = 'publish-option';
                ladderDiv.innerHTML = `<h4>Select ${laddersNeeded} Ladder(s):</h4><div class="option-cards" id="ladderOptions"></div>`;
                options.appendChild(ladderDiv);

                const ladderContainer = document.getElementById('ladderOptions');

                seqs.ladders.forEach((ladder, idx) => {
                    const optDiv = document.createElement('div');
                    optDiv.style.cssText = 'display:flex;gap:5px;padding:8px;border:2px solid transparent;border-radius:8px;cursor:pointer;';
                    optDiv.onclick = () => toggleLadderSelection(idx, optDiv);

                    ladder.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${card.getColor()}`;
                        if (card.suit === '‚ô•') cardEl.classList.add('heart');
                        if (card.suit === '‚ô¶') cardEl.classList.add('diamond');
                        cardEl.style.transform = 'scale(0.8)';
                        cardEl.style.position = 'relative';

                        // ‚úÖ FIX 5C: Use CONSISTENT number based on card ID
                        let duplicateLabel = '';
                        if (cardIdToNumber.has(card.id)) {
                            const cardNumber = cardIdToNumber.get(card.id);
                            duplicateLabel = `<div style="position:absolute;top:2px;right:2px;background:#ffd700;color:#000;width:16px;height:16px;border-radius:50%;font-size:10px;font-weight:900;display:flex;align-items:center;justify-content:center;border:1px solid #000;">${cardNumber}</div>`;
                        }

                        cardEl.innerHTML = `
                                        <div class="card-rank">${card.rank}</div>
                                        <div class="card-suit">${card.suit}</div>
                                        ${duplicateLabel}
                                    `;
                        optDiv.appendChild(cardEl);
                    });

                    ladderContainer.appendChild(optDiv);
                });
            }

            selector.classList.add('active');
        }

        function toggleTripleSelection(idx, element) {
            const selected = game.publishSelection.triples;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function toggleLadderSelection(idx, element) {
            const selected = game.publishSelection.ladders;
            const pos = selected.indexOf(idx);
            if (pos > -1) { selected.splice(pos, 1); element.style.border = '2px solid transparent' }
            else { selected.push(idx); element.style.border = '2px solid #ffd700' }
        }

        function confirmManualPublish() {
            const req = game.handReqs[game.currentHand].seqs;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;

            if (game.publishSelection.triples.length !== triplesNeeded ||
                game.publishSelection.ladders.length !== laddersNeeded) {
                game.showModal('Invalid Selection', `You must select exactly ${triplesNeeded} triple(s) and ${laddersNeeded} ladder(s)`);
                return;
            }

            const seqs = game.findSequences(game.playerHands[0]);
            let published = [];
            game.publishSelection.triples.forEach(idx => { published = published.concat(seqs.triples[idx]) });
            game.publishSelection.ladders.forEach(idx => { published = published.concat(seqs.ladders[idx]) });

            // ========== START FIX 5: REPLACE FROM HERE ==========

            // ‚úÖ FIX 5: Check for duplicate card IDs (same physical card used twice)
            const usedCardIds = new Set();
            let hasDuplicateCard = false;
            let duplicateCard = null;

            for (let card of published) {
                if (usedCardIds.has(card.id)) {
                    hasDuplicateCard = true;
                    duplicateCard = card;
                    break;
                }
                usedCardIds.add(card.id);
            }

            if (hasDuplicateCard) {
                console.log('%cüö® FIX 5: Duplicate card detected!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${duplicateCard.toString()} appears in multiple sequences`);
                game.showModal('Duplicate Card',
                    `You selected ${duplicateCard.toString()} in multiple sequences!\n\n` +
                    `Each card can only be used once.\n` +
                    `Please reselect your sequences.`);
                return;
            }

            // ‚úÖ FIX 5: Also check rank+suit counts (belt-and-suspenders validation)
            const selectedCards = {};
            published.forEach(c => {
                const key = c.rank + c.suit;
                selectedCards[key] = (selectedCards[key] || 0) + 1;
            });

            const handCards = {};
            game.playerHands[0].forEach(c => {
                const key = c.rank + c.suit;
                handCards[key] = (handCards[key] || 0) + 1;
            });

            let hasOverlap = false;
            let overlapCard = '';
            for (let key in selectedCards) {
                if (selectedCards[key] > handCards[key]) {
                    hasOverlap = true;
                    overlapCard = key;
                    break;
                }
            }

            if (hasOverlap) {
                console.log('%cüö® FIX 5: Card count overlap!', 'color:#ef4444;font-weight:bold');
                console.log(`  Card: ${overlapCard} - selected more than available`);
                game.showModal('Insufficient Cards',
                    `You selected more ${overlapCard} cards than you have!\n\n` +
                    `Please reselect your sequences.`);
                return;
            }

            console.log('%c‚úÖ FIX 5: Validation passed - no duplicates', 'color:#28a745;font-weight:bold');

            // ========== END FIX 5: REPLACE TO HERE ==========

            // ‚úÖ KEEP EVERYTHING BELOW (Execution section - unchanged)
            published.forEach(c => { const idx = game.playerHands[0].findIndex(card => card.id === c.id); if (idx > -1) game.playerHands[0].splice(idx, 1) });
            
            // üéØ v4.2.7 FIX: Build sequences from user selections, don't re-organize!
            // Don't call separateSequences() - it ignores user's manual selections!
            const sequences = [];
            game.publishSelection.triples.forEach(idx => sequences.push(seqs.triples[idx]));
            game.publishSelection.ladders.forEach(idx => sequences.push(seqs.ladders[idx]));
            game.publishedSequences[0] = sequences;
            
            console.log(`%cüéØ v4.0.7: Published ${sequences.length} separate sequences for Human`, 'color: #27ae60; font-weight: bold;');
            sequences.forEach((seq, i) => {
                console.log(`  Sequence ${i + 1}: ${seq.map(c => c.toString()).join(' ')}`);
            });
            
            game.justPublished = true;
            cancelManualPublish();
            if (game.playerHands[0].length === 0) { game.endHand(0); return }
            game.updateUI();
        }

        function cancelManualPublish() { document.getElementById('publishSelector').classList.remove('active'); game.publishSelection = null }

        function addToPublished(playerIdx) {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            if (game.justPublished) { game.showModal('Cannot Add', 'Cannot add in same turn you published!'); return }
            if (game.publishedSequences[playerIdx].length === 0) {
                game.showModal('Cannot Add', `${playerIdx === 0 ? 'You have' : (playerIdx === 1 ? 'Habot has' : 'Jabot has')} not published yet!`);
                return;
            }

            const cardIdx = game.selectedCards[0];
            const card = game.playerHands[0][cardIdx];
            const req = game.handReqs[game.currentHand].seqs;
            const hasTriples = req.some(s => s === 'triple');
            const hasLadders = req.some(s => s === 'ladder');
            const published = game.getFlatPublished(playerIdx);

            // ‚úÖ FIX 6: Check if card could extend BOTH triple AND ladder (AMBIGUOUS!)
            const rankCounts = {};
            published.forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });

            const canExtendTriple = hasTriples && rankCounts[card.rank] >= 3;

            let canExtendLadder = false;
            if (hasLadders) {
                // ‚úÖ FIX 6A: First separate triples from ladders to avoid confusion
                const allRankCounts = {};
                published.forEach(c => { allRankCounts[c.rank] = (allRankCounts[c.rank] || 0) + 1 });

                const tripleCards = [];
                const ladderCards = [];
                const processedRanks = new Set();

                published.forEach(c => {
                    if (allRankCounts[c.rank] >= 3 && !processedRanks.has(c.rank)) {
                        const sameRank = published.filter(card => card.rank === c.rank);
                        tripleCards.push(...sameRank);
                        processedRanks.add(c.rank);
                    }
                });

                published.forEach(c => {
                    if (!tripleCards.find(tc => tc.id === c.id)) ladderCards.push(c);
                });

                console.log(`%cüîç FIX 6A: Separated - Triples: ${tripleCards.map(c => c.toString()).join(' ')}, Ladders: ${ladderCards.map(c => c.toString()).join(' ')}`, 'color:#4a90e2');

                // Now check if card can extend ONLY the ladder cards (not triples)
                const sameSuit = ladderCards.filter(c => c.suit === card.suit);
                if (sameSuit.length >= 4) {

                    const cardVal = card.getValue();
                    const values = sameSuit.map(c => c.getValue()).sort((a, b) => a - b);
                    const ladders = [];
                    let remainingValues = [...values];
                    const hasAce = values.includes(1);
                    const hasJack = values.includes(11);
                    const hasQueen = values.includes(12);
                    const hasKing = values.includes(13);

                    if (hasAce && hasJack && hasQueen && hasKing) {
                        // üîß FIX 8 (v4.0.7): Extract ALL consecutive cards from King downward
                        // Bug: Previous code only checked v >= 11, missing cards like 9-10
                        const wrapLadder = [1];  // Start with Ace (value 1)
                        
                        // Get ALL non-ace cards sorted from high to low
                        const sortedCards = values.filter(v => v >= 2).sort((a, b) => b - a);
                        
                        // Start from King (13) and work downward, taking consecutive cards
                        let expectedValue = 13;
                        for (let val of sortedCards) {
                            if (val === expectedValue) {
                                wrapLadder.push(val);
                                expectedValue--;
                            } else if (val < expectedValue) {
                                // Gap found - stop here
                                break;
                            }
                        }
                        
                        console.log(`  üîß FIX 8: Wrap-around ladder detected: [${wrapLadder.join(',')}]`);
                        ladders.push(wrapLadder);
                        remainingValues = remainingValues.filter(v => !wrapLadder.includes(v));
                    }

                    if (remainingValues.length >= 4) {
                        let currentLadder = [remainingValues[0]];
                        for (let i = 1; i < remainingValues.length; i++) {
                            if (remainingValues[i] === currentLadder[currentLadder.length - 1] + 1) {
                                currentLadder.push(remainingValues[i]);
                            } else {
                                if (currentLadder.length >= 4) { ladders.push([...currentLadder]) }
                                currentLadder = [remainingValues[i]];
                            }
                        }
                        if (currentLadder.length >= 4) { ladders.push(currentLadder) }
                    }
                    canExtendLadder = ladders.some(ladder => {
                        return game.canCardExtendLadder(cardVal, ladder);
                    });
                }
            }

            // ‚úÖ FIX 6: AMBIGUOUS - card could go to EITHER sequence!
            if (canExtendTriple && canExtendLadder) {
                console.log(`%cüö® FIX 6: AMBIGUOUS - ${card.toString()} could extend BOTH triple and ladder!`, 'color:#ff6b35;font-weight:bold');
                game.showDisambiguationModal(card, playerIdx, cardIdx);
                return;
            }

            // üéØ v4.0.7 FIX: published is already 2D, no need to separate again!
            if (!canExtendTriple && !canExtendLadder) {
                // published is already [[seq1], [seq2], ...] in v4.0.x
                const publishedSeqs = game.publishedSequences[playerIdx];

                console.log(`  üîß PATCH S (v4.0.7): Validating ${card.toString()} against ${publishedSeqs.length} sequences`);

                let canExtendAny = false;
                for (let seq of publishedSeqs) {
                    // seq is already an array of cards, can pass directly
                    if (game.canAddToPublishedSequence(card, seq)) {
                        console.log(`  üîß PATCH S: ‚úÖ Can extend sequence`);
                        canExtendAny = true;
                        break;
                    }
                }

                if (!canExtendAny) {
                    console.log(`  üîß PATCH S: ‚ùå Cannot extend any sequence after validation`);
                    let errorMsg = 'This card does not extend any sequence!\n\n';
                    if (hasTriples && !hasLadders) errorMsg += 'This hand only allows TRIPLES.';
                    else if (hasLadders && !hasTriples) errorMsg += 'This hand only allows LADDERS.';
                    else errorMsg += 'For triples: Need 3+ same rank.\nFor ladders: Need 3+ consecutive same suit.';
                    game.showModal('Invalid Card', errorMsg);
                    return;
                }
            }

            // Only one option available - use executeAddToPublished
            const forceType = canExtendTriple ? 'triple' : 'ladder';
            game.executeAddToPublished(card, playerIdx, cardIdx, forceType);
        }
        //Nash: newGame
        // ============================================
        // EVENT LISTENERS (v4.1.1 - CSP Compliance)
        // ============================================
        window.onload = () => {
            // Main action buttons
            document.getElementById('publishBtn').addEventListener('click', publishSequences);
            document.getElementById('discardBtn').addEventListener('click', discardCard);
            document.getElementById('buyBtn').addEventListener('click', buyCard);
            document.getElementById('newGameBtn').addEventListener('click', newGame);
            
            // Sorting buttons
            document.getElementById('sortByRankBtn').addEventListener('click', sortByRank);
            document.getElementById('sortBySuitBtn').addEventListener('click', sortBySuit);
            document.getElementById('sortByQuantityBtn').addEventListener('click', sortByQuantity);
            
            // Deck interaction
            document.getElementById('drawDeck').addEventListener('click', drawFromDeck);
            document.getElementById('discardPile').addEventListener('click', drawFromDiscard);
            
            // Manual publish buttons
            document.getElementById('confirmManualPublish').addEventListener('click', confirmManualPublish);
            document.getElementById('cancelManualPublish').addEventListener('click', cancelManualPublish);
            
            // Add to published buttons (delegate by data-player attribute)
            document.querySelectorAll('.add-to-published').forEach(btn => {
                btn.addEventListener('click', function() {
                    const playerIdx = parseInt(this.getAttribute('data-player'));
                    addToPublished(playerIdx);
                });
            });
            
            // Start the game
            newGame();
        };

        // ============================================
        // üé® FIX 7B: Custom Confirmation Modal
        // ============================================
        function showConfirmModal(title, message, confirmText = 'Confirm', cancelText = 'Cancel') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                // Set content
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                confirmBtn.textContent = confirmText;
                cancelBtn.textContent = cancelText;

                // Show modal
                modal.classList.add('active');

                // Handle confirm
                const handleConfirm = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                // Handle cancel
                const handleCancel = () => {
                    modal.classList.remove('active');
                    confirmBtn.removeEventListener('click', handleConfirm);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                confirmBtn.addEventListener('click', handleConfirm);
                cancelBtn.addEventListener('click', handleCancel);

                // Close on overlay click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        handleCancel();
                    }
                });

                // Close on ESC key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
            });
        }

        // ============================================
        // üé≠ v2.5.0: CHARACTER BANTER SYSTEM
        // ============================================

        function getOpeningBanter() {
            const banterPool = [
                // Habot aggressive openers
                { speaker: 'Habot', text: "Let's see who fortune favors today!", personality: 'confident' },
                { speaker: 'Habot', text: "High card takes it - may the best player win!", personality: 'competitive' },
                { speaker: 'Habot', text: "Ready to see how luck plays out?", personality: 'eager' },
                { speaker: 'Habot', text: "Time to find out who leads the charge!", personality: 'bold' },

                // Jabot patient responses
                { speaker: 'Jabot', text: "Patience... the cards will tell the story.", personality: 'calm' },
                { speaker: 'Jabot', text: "Let's draw and see what fate decides.", personality: 'measured' },
                { speaker: 'Jabot', text: "The highest card speaks for itself.", personality: 'philosophical' },
                { speaker: 'Jabot', text: "A fair draw reveals the path forward.", personality: 'wise' }
            ];

            // Pick one from each personality
            const habotLine = banterPool.filter(b => b.speaker === 'Habot')[Math.floor(Math.random() * 4)];
            const jabotLine = banterPool.filter(b => b.speaker === 'Jabot')[Math.floor(Math.random() * 4)];

            return [habotLine, jabotLine];
        }

        function getWinReaction(winner, winnerCard, loserCards) {
            const reactions = {
                // Winner reactions
                winner: {
                    0: [  // Human wins
                        "Looks like fortune favors you today!",
                        "Well drawn! You'll lead us off.",
                        "A strong start - the table is yours!",
                        "Lady Luck smiles on you this hand."
                    ],
                    1: [  // Habot wins (confident/aggressive)
                        "Habot: Yes! The rabbit leads the race!",
                        "Habot: Perfect. Time to set the pace.",
                        "Habot: High card, high energy - let's go!",
                        "Habot: I'll show you how it's done."
                    ],
                    2: [  // Jabot wins (calm/strategic)
                        "Jabot: Interesting. I shall start with care.",
                        "Jabot: The cards have spoken. I begin.",
                        "Jabot: A thoughtful start, as it should be.",
                        "Jabot: Patience rewards... even in the draw."
                    ]
                },
                // Loser reactions
                graceful: [
                    "Well drawn!",
                    "Fair enough.",
                    "The cards decided.",
                    "So it goes."
                ],
                competitive: [
                    "Next time!",
                    "We'll see how this plays out.",
                    "The game hasn't started yet.",
                    "Just wait..."
                ]
            };

            const winnerReaction = reactions.winner[winner][Math.floor(Math.random() * 4)];

            // Loser reactions based on personality
            const loserReactions = [];
            if (winner !== 1) {  // Habot lost
                loserReactions.push({ speaker: 'Habot', text: reactions.competitive[Math.floor(Math.random() * 4)] });
            }
            if (winner !== 2) {  // Jabot lost
                loserReactions.push({ speaker: 'Jabot', text: reactions.graceful[Math.floor(Math.random() * 4)] });
            }

            return { winner: winnerReaction, losers: loserReactions };
        }

        function getSuitExplanation() {
            return {
                title: "‚ô†‚ô•‚ô¶‚ô£ Suit Hierarchy",
                message: "In Bridge tradition:\n‚ô† Spades (highest)\n‚ô• Hearts\n‚ô¶ Diamonds  \n‚ô£ Clubs (lowest)",
                tip: "Highest rank wins. If tied, highest suit breaks the tie."
            };
        }

        // ============================================
        // üé® FIX 7D: Info Modal with Auto-Fade
        // ============================================
        function showInfoModal(title, message, buttonText = 'Got it!', icon = 'üí¨', autoFade = true, fadeDelay = 3000) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const modalIcon = document.querySelector('.modal-icon');
                const modalContent = document.querySelector('.modal-content');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                modalIcon.textContent = icon;
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                confirmBtn.textContent = buttonText;
                cancelBtn.style.display = 'none';

                let fadeIndicator = null;
                let skipHint = null;
                if (autoFade) {
                    fadeIndicator = document.createElement('div');
                    fadeIndicator.className = 'modal-auto-fade-indicator';
                    modalContent.appendChild(fadeIndicator);

                    skipHint = document.createElement('div');
                    skipHint.className = 'modal-skip-hint';
                    skipHint.textContent = 'Click or ESC to skip';
                    modalContent.appendChild(skipHint);
                }

                modal.classList.add('active');
                modal.classList.remove('fading-out');

                let fadeTimeout = null;
                let hasResolved = false;

                const handleClose = (wasAutomatic = false) => {
                    if (hasResolved) return;
                    hasResolved = true;

                    if (fadeTimeout) clearTimeout(fadeTimeout);

                    modal.classList.add('fading-out');

                    setTimeout(() => {
                        modal.classList.remove('active', 'fading-out');
                        cancelBtn.style.display = '';

                        if (fadeIndicator && fadeIndicator.parentNode) {
                            fadeIndicator.remove();
                        }
                        if (skipHint && skipHint.parentNode) {
                            skipHint.remove();
                        }

                        confirmBtn.removeEventListener('click', handleManualClose);
                        resolve(true);
                    }, 500);
                };

                const handleManualClose = () => handleClose(false);

                if (autoFade) {
                    fadeTimeout = setTimeout(() => {
                        handleClose(true);
                    }, fadeDelay);
                }

                confirmBtn.addEventListener('click', handleManualClose);

                const handleOverlayClick = (e) => {
                    if (e.target === modal) handleManualClose();
                };
                modal.addEventListener('click', handleOverlayClick);

                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        handleManualClose();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);

                setTimeout(() => {
                    modal.removeEventListener('click', handleOverlayClick);
                    document.removeEventListener('keydown', handleEscape);
                }, fadeDelay + 1000);
            });
        }

        async function newGame() {
            // ‚úÖ FIX 7B: Custom confirmation modal (no "This page says"!)
            if (game && game.gamePhase !== 'end') {
                const confirmed = await showConfirmModal(
                    'Start New Game?',
                    'This will end the current game and reset all scores.\n\nAre you sure you want to continue?',
                    'Start New Game',
                    'Continue Playing'
                );

                if (!confirmed) {
                    return; // User cancelled
                }
            }
            persistentScores = [0, 0, 0];
            game = new GameState(false);
        }

        function drawFromDeck() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;
            if (game.buyWindow.active) game.closeBuyWindow('player-turn');
            if (game.deck.length === 0) { if (!game.reshuffleDeck()) { alert('Deck is empty!'); return } game.updateUI() }
            if (game.deck.length > 0) {
                const drawnCard = game.deck.pop();
                game.playerHands[0].push(drawnCard);
                game.gamePhase = 'discard';
                game.turnCounter++;
                game.updateUI();
            }
        }

        function drawFromDiscard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'draw') return;

            // üîí v4.1.3: Glass vault rule - check if discard pile is accessible
            if (!game.discardPileAccessible) {
                showInfoModal(
                    'Discard Pile Locked',
                    'The discard pile is locked. The last card was taken, so you must draw from the deck.',
                    'Okay',
                    'üîí',
                    true,    // auto-fade
                    2000     // 2 seconds
                );
                return;
            }

            // üé® v2.5: Show modal if discard pile is empty
            if (game.discardPile.length === 0) {
                showInfoModal(
                    'Discard Pile Empty',
                    'The last card was taken by another player. Please draw from the deck instead.',
                    'Okay',
                    'üé¥',
                    true,    // auto-fade
                    2000     // 2 seconds
                );
                return;
            }

            const card = game.discardPile.pop();
            game.playerHands[0].push(card);
            game.discardPileAccessible = false; // üîí v4.1.3: Lock vault after taking card
            if (game.buyWindow.active) game.closeBuyWindow('player-took');
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            game.gamePhase = 'discard';
            game.turnCounter++;
            game.updateUI();
        }

        function discardCard() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard' || game.selectedCards.length !== 1) return;
            const card = game.playerHands[0].splice(game.selectedCards[0], 1)[0];
            game.discardPile.push(card);
            game.discardPileAccessible = true; // üîí v4.1.3: Unlock vault - new card on top of glass
            game.selectedCards = [];
            game.lastDiscard = card;
            game.lastDiscardByPlayer = 0;
            game.justPublished = false;
            if (game.playerHands[0].length === 0) { game.updateUI(); setTimeout(() => { game.endHand(0) }, 500); return }
            game.currentPlayer = 1;
            game.gamePhase = 'draw';
            game.updateUI();
            if (game.currentPlayer !== 0) game.aiTurn();
        }

        function publishSequences() {
            if (!game || game.currentPlayer !== 0 || game.gamePhase !== 'discard') return;
            if (!game.canPublish(0)) { game.showModal('Cannot Publish', 'You do not have the required sequences!'); return }
            const seqs = game.findSequences(game.playerHands[0]);
            const req = game.handReqs[game.currentHand].seqs;
            let needsManualSelection = false;
            const triplesNeeded = req.filter(s => s === 'triple').length;
            const laddersNeeded = req.filter(s => s === 'ladder').length;
            if (seqs.triples.length > triplesNeeded || seqs.ladders.length > laddersNeeded) needsManualSelection = true;
            const rankCounts = {};
            game.playerHands[0].forEach(c => { rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1 });
            Object.values(rankCounts).forEach(count => { if (count >= 4) needsManualSelection = true });
            if (needsManualSelection) showPublishSelector(seqs, req);
            else {
                game.autoPublish(0);
                game.justPublished = true;
                if (game.playerHands[0].length === 0) { game.endHand(0); return }
                game.updateUI();
            }
        }

        function buyCard() {
            if (!game || game.playerBuys[0] <= 0) return;
            if (!game.buyWindow.active || !game.buyWindow.card) return;
            if (game.buyWindow.buyWindowPlayer !== 0) return;
            const card = game.buyWindow.card;
            const idx = game.discardPile.findIndex(c => c.id === card.id);
            if (idx === -1) { game.closeBuyWindow('taken'); showToast('Card no longer available', 'warning', 2000); return }
            game.discardPile.splice(idx, 1);
            game.playerHands[0].push(card);
            game.discardPileAccessible = false; // üîí v4.1.3: Lock vault after buy
            if (game.lastDiscard && game.lastDiscard.rank === card.rank && game.lastDiscard.suit === card.suit) {
                game.lastDiscard = null;
                game.lastDiscardByPlayer = -1;
            }
            if (game.deck.length === 0) { game.reshuffleDeck(); game.updateUI() }
            if (game.deck.length > 0) {
                const penalty = game.deck.pop();
                game.playerHands[0].push(penalty);
            }
            game.playerBuys[0]--;
            showToast(`You bought ${card.toString()}!`, 'buy', 2500);
            game.updateUI();
            game.closeBuyWindow('bought');
        }




        function sortByRank() {
            if (!game) return;
            game.playerHands[0].sort((a, b) => {
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortBySuit() {
            if (!game) return;
            const order = { '‚ô†': 1, '‚ô•': 2, '‚ô¶': 3, '‚ô£': 4 };
            game.playerHands[0].sort((a, b) => {
                if (order[a.suit] !== order[b.suit]) return order[a.suit] - order[b.suit];
                return a.getValue() - b.getValue();
            });
            game.selectedCards = [];
            game.updateUI();
        }

        function sortByQuantity() {
            if (!game) return;
            const counts = {};
            game.playerHands[0].forEach(card => { counts[card.rank] = (counts[card.rank] || 0) + 1 });
            game.playerHands[0].sort((a, b) => {
                const countDiff = counts[b.rank] - counts[a.rank];
                if (countDiff !== 0) return countDiff;
                if (a.getValue() !== b.getValue()) return a.getValue() - b.getValue();
                return a.suit.localeCompare(b.suit);
            });
            game.selectedCards = [];
            game.updateUI();
        }

        // Toast Notification System
        function showToast(message, type = 'info', duration = 2500) {
            const container = document.querySelector('.toast-container') || createToastContainer();
            const toast = document.createElement('div');
            let bgColor, textColor, icon;
            switch (type) {
                case 'buy': bgColor = 'linear-gradient(135deg, #ffc107, #ff9800)'; textColor = '#000'; icon = 'üí∞'; break;
                case 'warning': bgColor = 'linear-gradient(135deg, #ff6b35, #f7931e)'; textColor = '#fff'; icon = '‚ö†Ô∏è'; break;
                case 'win': bgColor = 'linear-gradient(135deg, #ffd700, #ffed4e)'; textColor = '#000'; icon = 'üèÜ'; duration = 3000; break;
                default: bgColor = 'linear-gradient(135deg, #4ade80, #22c55e)'; textColor = '#000'; icon = '‚ÑπÔ∏è';
            }
            toast.style.cssText = `background: ${bgColor}; color: ${textColor}; padding: 16px 24px; border-radius: 12px; font-weight: 900; font-size: 1.1rem; box-shadow: 0 8px 24px rgba(0,0,0,0.4); animation: slideIn 0.3s ease; pointer-events: auto; ${type === 'win' ? 'animation: slideIn 0.3s ease, victoryPulse 0.5s ease 0.3s 3;' : ''}`;
            toast.innerHTML = `${icon} ${message}`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => { toast.remove(); if (container.children.length === 0) container.remove() }, 300);
            }, duration);
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
            return container;
        }

        function showBuyToast(aiName, card) { showToast(`${aiName} BOUGHT ${card.toString()}!`, 'buy') }

        // ============================================
        // üé® v2.5: Modal Notifications (Auto-Fade)
        // ============================================
        function showAITookCardToast(aiName, card) {
            console.log(`%cüö® FIX 2: Showing AI took card modal (auto-fade)`, 'color: #ff6b35; font-weight: bold;');
            // Auto-fades after 2.5 seconds - quick notification
            showInfoModal(
                `${aiName} Bought Card`,
                `${aiName} took the ${card.toString()} from the discard pile.`,
                'Continue',
                'üí∞',
                true,    // auto-fade enabled
                2500     // 2.5 seconds
            );
        }

        function showLastCardToast(playerName) {
            const verb = playerName === 'You' ? 'have' : 'has';
            // NO auto-fade - critical warning!
            showInfoModal(
                '‚ö†Ô∏è Last Card Alert!',
                `${playerName} ${verb} only 1 card remaining!`,
                'Got it!',
                'üÉè',
                false    // NO auto-fade - player must acknowledge
            );
        }

        function showWinToast(playerName) {
            const verb = (playerName === 'You') ? 'Win' : 'Wins';
            // NO auto-fade - game over message!
            showInfoModal(
                'üèÜ Game Over!',
                `${playerName} ${verb}!`,
                'New Game',
                'üéâ',
                false    // NO auto-fade - player must acknowledge
            );
        }


    </script>
</body>
</html>